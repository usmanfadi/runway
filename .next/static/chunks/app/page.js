/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cusman%5C%5Csrc%5C%5Ccomponents%5C%5CPageRenderer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cusman%5C%5Csrc%5C%5Ccomponents%5C%5CPageRenderer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/PageRenderer.tsx */ \"(app-pages-browser)/./src/components/PageRenderer.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q3VzbWFuJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q1BhZ2VSZW5kZXJlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsNExBQThHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MTQ5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcImRlZmF1bHRcIl0gKi8gXCJEOlxcXFx1c21hblxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxQYWdlUmVuZGVyZXIudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cusman%5C%5Csrc%5C%5Ccomponents%5C%5CPageRenderer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/PageRenderer.tsx":
/*!*****************************************!*\
  !*** ./src/components/PageRenderer.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PageRenderer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n// Helper to extract filename from URL (handles query params)\n// IMPORTANT: Asset files are named with alluredigital.net, so always convert rimalweb.net first\nfunction getAssetFilename(url) {\n    try {\n        // ALWAYS convert rimalweb.net to alluredigital.net FIRST - asset files use alluredigital.net\n        let urlToProcess = url;\n        if (url && (url.includes(\"rimalweb.net\") || url.includes(\"Rimalweb.net\") || url.includes(\"RimalWeb.net\") || url.includes(\"RIMALWEB.NET\"))) {\n            urlToProcess = url.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n        }\n        const urlObj = new URL(urlToProcess, \"https://alluredigital.net\");\n        const pathParts = urlObj.pathname.split(\"/\").filter((p)=>p);\n        if (pathParts.length === 0) return null;\n        // For litespeed CSS/JS files, construct full path (matches scraped filename format)\n        if (urlObj.pathname.includes(\"/litespeed/\")) {\n            // Format: domain_path_to_file.css\n            const domain = urlObj.hostname.replace(\"www.\", \"\");\n            const fullPath = domain + urlObj.pathname;\n            // Replace slashes with underscores, keep dots and dashes\n            let filename = fullPath.replace(/\\//g, \"_\");\n            // Remove query params from filename (already handled by scraper)\n            filename = filename.split(\"?\")[0];\n            return filename || null;\n        }\n        // For wp-content/uploads files\n        if (urlObj.pathname.includes(\"/wp-content/uploads/\")) {\n            const domain = urlObj.hostname.replace(\"www.\", \"\");\n            const fullPath = domain + urlObj.pathname;\n            let filename = fullPath.replace(/\\//g, \"_\");\n            filename = filename.split(\"?\")[0];\n            return filename || null;\n        }\n        // For other files, construct domain_path format\n        const domain = urlObj.hostname.replace(\"www.\", \"\");\n        const fullPath = domain + urlObj.pathname;\n        let filename = fullPath.replace(/\\//g, \"_\");\n        filename = filename.split(\"?\")[0];\n        return filename || null;\n    } catch (e) {\n        return null;\n    }\n}\nfunction PageRenderer(param) {\n    let { html } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const scriptsLoadedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const stylesLoadedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const cleanupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const scrollTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!containerRef.current || !html) return;\n        setIsLoading(true);\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html, \"text/html\");\n        // Extract and inject head content FIRST (before body)\n        const head = doc.querySelector(\"head\");\n        const stylePromises = [];\n        if (head) {\n            // Load Google Fonts (Montserrat and Poppins) - same as original website\n            const googleFontsLink = document.createElement(\"link\");\n            googleFontsLink.rel = \"preconnect\";\n            googleFontsLink.href = \"https://fonts.googleapis.com\";\n            document.head.appendChild(googleFontsLink);\n            const googleFontsLink2 = document.createElement(\"link\");\n            googleFontsLink2.rel = \"preconnect\";\n            googleFontsLink2.href = \"https://fonts.gstatic.com\";\n            googleFontsLink2.crossOrigin = \"anonymous\";\n            document.head.appendChild(googleFontsLink2);\n            const fontLink = document.createElement(\"link\");\n            fontLink.rel = \"stylesheet\";\n            fontLink.href = \"https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400&display=swap\";\n            document.head.appendChild(fontLink);\n            // Preload ALL assets first so browser caches them (won't reload on refresh)\n            const allAssets = [];\n            // Collect all CSS files\n            head.querySelectorAll('link[rel=\"stylesheet\"]').forEach((el)=>{\n                const href = el.getAttribute(\"href\") || \"\";\n                if (href.includes(\"alluredigital.net\") && !href.includes(\"fonts.googleapis.com\")) {\n                    const filename = getAssetFilename(href);\n                    if (filename) {\n                        allAssets.push({\n                            href: \"/assets/\".concat(filename),\n                            as: \"style\"\n                        });\n                    }\n                }\n            });\n            // Collect all script files\n            head.querySelectorAll(\"script[src]\").forEach((el)=>{\n                const src = el.getAttribute(\"src\") || \"\";\n                if (src && (src.includes(\"alluredigital.net\") || src.startsWith(\"/assets/\"))) {\n                    const filename = getAssetFilename(src);\n                    if (filename) {\n                        allAssets.push({\n                            href: \"/assets/\".concat(filename),\n                            as: \"script\"\n                        });\n                    }\n                }\n            });\n            // Collect critical images from body\n            const body = doc.querySelector(\"body\");\n            if (body) {\n                // Logo (use small 1.png for navbar)\n                allAssets.push({\n                    href: \"/1.png\",\n                    as: \"image\"\n                });\n                // Hero and important images (first 15)\n                let imageCount = 0;\n                body.querySelectorAll(\"img[src]\").forEach((el)=>{\n                    if (imageCount >= 15) return;\n                    const src = el.getAttribute(\"src\") || \"\";\n                    if (src && (src.includes(\"alluredigital.net\") || src.includes(\"rimalweb.net\") || src.startsWith(\"/assets/\"))) {\n                        const fixedSrc = src.includes(\"/assets/\") ? src : \"/assets/\".concat(getAssetFilename(src) || \"\");\n                        if (fixedSrc && fixedSrc !== \"/assets/\" && !allAssets.some((a)=>a.href === fixedSrc)) {\n                            allAssets.push({\n                                href: fixedSrc,\n                                as: \"image\"\n                            });\n                            imageCount++;\n                        }\n                    }\n                });\n            }\n            // Add preload links for ALL assets (browser will cache them)\n            allAssets.forEach((asset)=>{\n                if (asset.href && !document.querySelector('link[rel=\"preload\"][href=\"'.concat(asset.href, '\"]'))) {\n                    const preloadLink = document.createElement(\"link\");\n                    preloadLink.rel = \"preload\";\n                    preloadLink.as = asset.as;\n                    preloadLink.href = asset.href;\n                    // Add crossorigin for fonts if needed\n                    if (asset.as === \"font\") {\n                        preloadLink.crossOrigin = \"anonymous\";\n                    }\n                    document.head.appendChild(preloadLink);\n                }\n            });\n            // Inject ALL stylesheets (preserve order for animations)\n            head.querySelectorAll('link[rel=\"stylesheet\"], style').forEach((el)=>{\n                if (el.tagName === \"LINK\") {\n                    const href = el.getAttribute(\"href\") || \"\";\n                    const styleId = href;\n                    if (!stylesLoadedRef.current.has(styleId)) {\n                        const clone = el.cloneNode(true);\n                        // Only load local CSS - skip external fonts\n                        if (href.includes(\"fonts.googleapis.com\") || href.includes(\"googleapis.com\") || href.includes(\"gstatic.com\")) {\n                            // Skip external fonts - don't load them\n                            return;\n                        } else if (href.includes(\"alluredigital.net\") || href.startsWith(\"http\")) {\n                            const filename = getAssetFilename(href);\n                            if (filename) {\n                                clone.href = \"/assets/\".concat(filename);\n                            } else {\n                                // Skip if can't find local asset\n                                return;\n                            }\n                        }\n                        clone.setAttribute(\"data-injected\", \"true\");\n                        // Wait for stylesheet to load and be applied\n                        const stylePromise = new Promise((resolve)=>{\n                            let resolved = false;\n                            const resolveOnce = ()=>{\n                                if (!resolved) {\n                                    resolved = true;\n                                    // Wait a bit more to ensure CSS is applied to DOM\n                                    setTimeout(()=>resolve(), 100);\n                                }\n                            };\n                            clone.onload = resolveOnce;\n                            clone.onerror = resolveOnce // Continue even if stylesheet fails\n                            ;\n                            document.head.appendChild(clone);\n                            // Fallback: resolve after reasonable timeout\n                            setTimeout(()=>{\n                                if (!resolved) {\n                                    resolveOnce();\n                                }\n                            }, 2000);\n                        });\n                        stylePromises.push(stylePromise);\n                        stylesLoadedRef.current.add(styleId);\n                    }\n                } else if (el.tagName === \"STYLE\") {\n                    var _el_textContent;\n                    // Inline styles - inject directly\n                    const styleId = ((_el_textContent = el.textContent) === null || _el_textContent === void 0 ? void 0 : _el_textContent.substring(0, 50)) || Math.random().toString();\n                    if (!stylesLoadedRef.current.has(styleId)) {\n                        const clone = el.cloneNode(true);\n                        clone.setAttribute(\"data-injected\", \"true\");\n                        document.head.appendChild(clone);\n                        stylesLoadedRef.current.add(styleId);\n                    }\n                }\n            });\n            // Inject meta tags and title (with branding replacement)\n            head.querySelectorAll(\"meta, title\").forEach((el)=>{\n                if (el.tagName === \"TITLE\") {\n                    // Always update title, whether it exists or not\n                    const titleText = el.textContent || \"\";\n                    const replacedText = titleText.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\").replace(/AllureDigital\\.net/gi, \"Rimalweb\").replace(/alluredigital\\.net/gi, \"Rimalweb\");\n                    // Update document.title directly (this is what shows in browser tab)\n                    document.title = replacedText || \"Rimalweb\";\n                    // Also update/create title tag in head\n                    let existingTitle = document.querySelector(\"title\");\n                    if (existingTitle) {\n                        existingTitle.textContent = replacedText || \"Rimalweb\";\n                    } else {\n                        const newTitle = document.createElement(\"title\");\n                        newTitle.textContent = replacedText || \"Rimalweb\";\n                        document.head.appendChild(newTitle);\n                    }\n                    // Force update after a small delay to ensure it persists\n                    setTimeout(()=>{\n                        document.title = replacedText || \"Rimalweb\";\n                        const titleEl = document.querySelector(\"title\");\n                        if (titleEl) {\n                            titleEl.textContent = replacedText || \"Rimalweb\";\n                        }\n                    }, 100);\n                } else if (el.tagName === \"META\") {\n                    // Handle meta tags\n                    const existing = document.querySelector('meta[name=\"'.concat(el.getAttribute(\"name\") || el.getAttribute(\"property\"), '\"]'));\n                    if (!existing) {\n                        const clone = el.cloneNode(true);\n                        const content = clone.getAttribute(\"content\");\n                        if (content) {\n                            clone.setAttribute(\"content\", content.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\").replace(/alluredigital\\.net/gi, \"rimalweb.com\"));\n                        }\n                        document.head.appendChild(clone);\n                    } else {\n                        // Update existing meta tag\n                        const content = el.getAttribute(\"content\");\n                        if (content) {\n                            const replacedContent = content.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\").replace(/alluredigital\\.net/gi, \"rimalweb.com\");\n                            existing.setAttribute(\"content\", replacedContent);\n                        }\n                    }\n                }\n            });\n        }\n        // Extract body and preserve ALL attributes and classes\n        const body = doc.querySelector(\"body\");\n        if (body && containerRef.current) {\n            // Apply body classes to container to preserve styling\n            const bodyClasses = body.className;\n            if (bodyClasses) {\n                containerRef.current.className = bodyClasses;\n            }\n            // Copy body attributes\n            Array.from(body.attributes).forEach((attr)=>{\n                if (attr.name !== \"class\") {\n                    var _containerRef_current;\n                    (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.setAttribute(attr.name, attr.value);\n                }\n            });\n            // Check if asset file exists (async check)\n            const checkAssetExists = async (path)=>{\n                try {\n                    const response = await fetch(path, {\n                        method: \"HEAD\"\n                    });\n                    return response.ok;\n                } catch (e) {\n                    return false;\n                }\n            };\n            // Fix ALL asset URLs in body BEFORE setting innerHTML\n            // IMPORTANT: Asset files are named with alluredigital.net, so always convert rimalweb.net first\n            const fixAssetUrl = (url)=>{\n                if (!url || url.startsWith(\"data:\") || url.startsWith(\"/assets/\")) return url;\n                // ALWAYS convert rimalweb.net (any case variation) to alluredigital.net FIRST for asset filename lookup\n                let urlToProcess = url;\n                if (/rimalweb\\.net/i.test(url)) {\n                    urlToProcess = url.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                }\n                // Now process with alluredigital.net URL\n                if (urlToProcess.includes(\"alluredigital.net\") || urlToProcess.startsWith(\"http\")) {\n                    const filename = getAssetFilename(urlToProcess);\n                    if (filename) {\n                        // WordPress adds size suffixes like -2048x903, -300x200, etc. to image URLs\n                        // but the actual files don't have these suffixes. Strip them from filename.\n                        const filenameWithoutSize = filename.replace(/-\\d+x\\d+(\\.[a-z]+)$/i, \"$1\");\n                        return \"/assets/\".concat(filenameWithoutSize);\n                    }\n                }\n                return url;\n            };\n            // Fix images and replace logo images with custom SVG logo\n            body.querySelectorAll(\"img[src]\").forEach((img)=>{\n                const src = img.getAttribute(\"src\");\n                if (src) {\n                    var _img_closest, _welcomeSection_textContent, _welcomeSection_textContent1, _welcomeSection_textContent2;\n                    const fixedSrc = fixAssetUrl(src);\n                    img.setAttribute(\"src\", fixedSrc);\n                    // Check if image is in \"Welcome to Rimalweb\" section\n                    const welcomeSection = (_img_closest = img.closest(\"section, div\")) === null || _img_closest === void 0 ? void 0 : _img_closest.querySelector(\"h2, h1, .elementor-heading-title\");\n                    const isWelcomeSection = welcomeSection && (((_welcomeSection_textContent = welcomeSection.textContent) === null || _welcomeSection_textContent === void 0 ? void 0 : _welcomeSection_textContent.includes(\"Welcome to\")) || ((_welcomeSection_textContent1 = welcomeSection.textContent) === null || _welcomeSection_textContent1 === void 0 ? void 0 : _welcomeSection_textContent1.includes(\"Breaking Through\")) || ((_welcomeSection_textContent2 = welcomeSection.textContent) === null || _welcomeSection_textContent2 === void 0 ? void 0 : _welcomeSection_textContent2.includes(\"Digital Impasse\")));\n                    // Make images smaller in Welcome section\n                    if (isWelcomeSection) {\n                        const imgElement = img;\n                        const originalWidth = parseInt(img.getAttribute(\"width\") || (imgElement.offsetWidth ? imgElement.offsetWidth.toString() : \"200\"));\n                        const originalHeight = parseInt(img.getAttribute(\"height\") || (imgElement.offsetHeight ? imgElement.offsetHeight.toString() : \"50\"));\n                        // Reduce size by 30% for Welcome section images\n                        const width = Math.round(originalWidth * 0.7);\n                        const height = Math.round(originalHeight * 0.7);\n                        const currentStyle = img.getAttribute(\"style\") || \"\";\n                        img.setAttribute(\"width\", width.toString());\n                        img.setAttribute(\"height\", height.toString());\n                        img.setAttribute(\"style\", \"width: \".concat(width, \"px; height: \").concat(height, \"px; max-width: \").concat(width, \"px; object-fit: contain; \").concat(currentStyle));\n                    }\n                    // Fix logo carousel slider images - make them smaller\n                    const isInLogoCarousel = img.closest(\".bdt-logo-carousel-wrapper\") !== null || img.closest(\".bdt-logo-carousel-item\") !== null || img.classList.contains(\"bdt-logo-carousel-img\");\n                    if (isInLogoCarousel) {\n                        const imgElement = img;\n                        const currentStyle = img.getAttribute(\"style\") || \"\";\n                        imgElement.style.maxWidth = \"200px\";\n                        imgElement.style.maxHeight = \"100px\";\n                        imgElement.style.width = \"auto\";\n                        imgElement.style.height = \"auto\";\n                        imgElement.style.objectFit = \"contain\";\n                        img.setAttribute(\"style\", \"max-width: 200px; max-height: 100px; width: auto; height: auto; object-fit: contain; \".concat(currentStyle));\n                    }\n                    // Replace logo images in header/footer with custom SVG logo\n                    const srcLower = src.toLowerCase();\n                    const isLogoImage = srcLower.includes(\"allure\") && (srcLower.includes(\"logo\") || srcLower.includes(\"asset-1\") || srcLower.includes(\"symbol\"));\n                    const isInHeader = img.closest(\"header\") !== null || img.closest('[data-elementor-type=\"header\"]') !== null || img.closest('[class*=\"elementor-location-header\" i]') !== null;\n                    const isInFooter = img.closest(\"footer\") !== null || img.closest('[class*=\"footer\" i]') !== null;\n                    const hasLogoClass = img.closest('[class*=\"logo\" i]') !== null || img.closest('[class*=\"brand\" i]') !== null || img.closest('[class*=\"site-logo\" i]') !== null || img.closest('[class*=\"elementor-widget-image\" i]') !== null;\n                    // Replace logo images with small logo from public folder (1.png)\n                    if (isLogoImage && (isInHeader || isInFooter || hasLogoClass)) {\n                        const parent = img.parentElement;\n                        if (parent) {\n                            const imgElement = img;\n                            const originalWidth = parseInt(img.getAttribute(\"width\") || (imgElement.offsetWidth ? imgElement.offsetWidth.toString() : \"200\"));\n                            const originalHeight = parseInt(img.getAttribute(\"height\") || (imgElement.offsetHeight ? imgElement.offsetHeight.toString() : \"50\"));\n                            // Reduce size significantly for navbar to maintain original height\n                            // For header/navbar, use much smaller size (30%); for footer, use even smaller\n                            const sizeMultiplier = isInHeader ? 0.3 : isInFooter ? 0.25 : 0.3;\n                            const width = Math.round(originalWidth * sizeMultiplier);\n                            const height = Math.round(originalHeight * sizeMultiplier);\n                            const classes = img.getAttribute(\"class\") || \"\";\n                            const style = img.getAttribute(\"style\") || \"\";\n                            const alt = img.getAttribute(\"alt\") || \"Rimalweb\";\n                            // Create new image element with small logo (1.png) to keep navbar height small\n                            const newLogo = document.createElement(\"img\");\n                            newLogo.src = \"/1.png\";\n                            newLogo.setAttribute(\"width\", width.toString());\n                            newLogo.setAttribute(\"height\", height.toString());\n                            newLogo.setAttribute(\"alt\", alt);\n                            newLogo.setAttribute(\"class\", classes);\n                            // Make footer logo transparent\n                            const opacityStyle = isInFooter ? \"opacity: 0.5; \" : \"\";\n                            // Keep header logo aligned properly without extra margins\n                            const headerPositionStyle = isInHeader ? \"vertical-align: middle; \" : \"\";\n                            // Add style with smaller size to maintain navbar original height\n                            newLogo.setAttribute(\"style\", \"width: \".concat(width, \"px; height: \").concat(height, \"px; max-width: \").concat(width, \"px; max-height: \").concat(height, \"px; object-fit: contain; \").concat(opacityStyle).concat(headerPositionStyle).concat(style));\n                            // Preserve parent link if exists\n                            if (parent.tagName === \"A\") {\n                                var _parent_parentElement;\n                                const link = parent.cloneNode(false);\n                                Array.from(parent.attributes).forEach((attr)=>{\n                                    link.setAttribute(attr.name, attr.value);\n                                });\n                                link.appendChild(newLogo);\n                                (_parent_parentElement = parent.parentElement) === null || _parent_parentElement === void 0 ? void 0 : _parent_parentElement.replaceChild(link, parent);\n                            } else {\n                                parent.replaceChild(newLogo, img);\n                            }\n                        }\n                    }\n                }\n            });\n            // Fix CSS links in body\n            body.querySelectorAll(\"link[href]\").forEach((link)=>{\n                const href = link.getAttribute(\"href\");\n                if (href) {\n                    link.setAttribute(\"href\", fixAssetUrl(href));\n                }\n            });\n            // Fix background images in style attributes\n            body.querySelectorAll('[style*=\"background\"]').forEach((el)=>{\n                const style = el.getAttribute(\"style\") || \"\";\n                const newStyle = style.replace(/url\\(['\"]?([^'\")]+)['\"]?\\)/g, (match, url)=>{\n                    const fixed = fixAssetUrl(url);\n                    return \"url('\".concat(fixed, \"')\");\n                });\n                el.setAttribute(\"style\", newStyle);\n            });\n            // Fix internal links and replace contact links with dummy data\n            body.querySelectorAll(\"a[href]\").forEach((a)=>{\n                const href = a.getAttribute(\"href\");\n                // Remove Google Maps links and location links\n                if (href && (href.includes(\"maps.google.com\") || href.includes(\"maps.googleapis.com\") || href.includes(\"google.com/maps\") || href.includes(\"goo.gl/maps\") || href.includes(\"maps.app.goo.gl\") || href.toLowerCase().includes(\"find us on google map\") || href.toLowerCase().includes(\"find us on map\") || href.toLowerCase().includes(\"our location\") || href.toLowerCase().includes(\"get directions\") || href.includes(\"q=\") && (href.includes(\"Brooklyn\") || href.includes(\"5300\") || href.includes(\"Kings Highway\")))) {\n                    // Remove the link but keep the text\n                    a.removeAttribute(\"href\");\n                    const linkEl = a;\n                    linkEl.style.pointerEvents = \"none\";\n                    linkEl.style.cursor = \"default\";\n                    linkEl.style.textDecoration = \"none\";\n                    return;\n                }\n                // Replace tel: and mailto: links with dummy data\n                if (href && href.startsWith(\"tel:\")) {\n                    const dummyPhone = \"+1 (555) 123-4567\";\n                    a.setAttribute(\"href\", \"tel:\".concat(dummyPhone.replace(/\\s/g, \"\").replace(/[()]/g, \"\").replace(/-/g, \"\")));\n                } else if (href && href.startsWith(\"mailto:\")) {\n                    const dummyEmail = \"info@rimalweb.com\";\n                    // Replace old email with dummy email\n                    if (href.includes(\"alluredigital.net\")) {\n                        a.setAttribute(\"href\", \"mailto:\".concat(dummyEmail));\n                    } else {\n                        // Keep existing email if it's not alluredigital.net\n                        a.setAttribute(\"href\", href.replace(/mailto:[^@]+@alluredigital\\.net/gi, \"mailto:\".concat(dummyEmail)));\n                    }\n                } else if (href && href.includes(\"alluredigital.net\")) {\n                    // Convert alluredigital.net URLs to local Next.js routes\n                    try {\n                        const url = new URL(href);\n                        let path = url.pathname;\n                        // Remove trailing slash\n                        if (path.endsWith(\"/\") && path !== \"/\") {\n                            path = path.slice(0, -1);\n                        }\n                        // Convert common WordPress paths to Next.js routes\n                        const routeMap = {\n                            \"/social-media-management\": \"/social-media-management\",\n                            \"/social-media-marketing\": \"/social-media-management\",\n                            \"/appian-development\": \"/appian-development\",\n                            \"/software-development\": \"/appian-development\",\n                            \"/local-seo\": \"/local-seo\",\n                            \"/ppc-advertising\": \"/google-ads-management\",\n                            \"/google-ads-management\": \"/google-ads-management\",\n                            \"/wordpress-development\": \"/wordpress-development\",\n                            \"/shopify-development\": \"/shopify-development\",\n                            \"/bricks-builder-development\": \"/bricks-builder-development\",\n                            \"/crm-development\": \"/crm-development\",\n                            \"/google-map-optimization\": \"/google-map-optimization\",\n                            \"/small-business-seo-service\": \"/small-business-seo-service\",\n                            \"/local-business-citations-building\": \"/local-business-citations-building\",\n                            \"/landing-page-optimization\": \"/landing-page-optimization\",\n                            \"/technical-seo-service\": \"/technical-seo-service\",\n                            \"/contact-us\": \"/contact-us\",\n                            \"/who-we-are\": \"/who-we-are\",\n                            \"/portfolio\": \"/portfolio\",\n                            \"/work\": \"/work\",\n                            \"/blog\": \"/blog\",\n                            \"/careers\": \"/careers\"\n                        };\n                        // Check if path exists in route map\n                        if (routeMap[path]) {\n                            a.setAttribute(\"href\", routeMap[path]);\n                        } else if (path.startsWith(\"/blog/\")) {\n                            // Blog posts - keep the path as is\n                            a.setAttribute(\"href\", path);\n                        } else if (path === \"/\" || path === \"\") {\n                            a.setAttribute(\"href\", \"/\");\n                        } else {\n                            // For unknown routes, try to use the path directly\n                            a.setAttribute(\"href\", path);\n                        }\n                    } catch (e) {\n                        // If URL parsing fails, try to extract path manually\n                        const pathMatch = href.match(/alluredigital\\.net([^?#]*)/);\n                        if (pathMatch && pathMatch[1]) {\n                            let path = pathMatch[1];\n                            if (path.endsWith(\"/\") && path !== \"/\") {\n                                path = path.slice(0, -1);\n                            }\n                            a.setAttribute(\"href\", path || \"/\");\n                        }\n                    }\n                }\n            });\n            // Replace branding - Allure Digital to Rimalweb (ONLY visible text, NOT URLs or assets)\n            const replaceBranding = (html)=>{\n                // Replace in text content using DOM manipulation for safety\n                const tempDiv = document.createElement(\"div\");\n                tempDiv.innerHTML = html;\n                // Replace in all text nodes (but NOT in script, style, src, href, or URLs)\n                const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT, null);\n                let node;\n                while(node = walker.nextNode()){\n                    const parent = node.parentElement;\n                    if (!parent) continue;\n                    // Skip script, style, and elements with src/href (images, links, etc.)\n                    // BUT allow text inside links (like breadcrumbs) to be replaced\n                    if (parent.tagName === \"SCRIPT\" || parent.tagName === \"STYLE\" || parent.tagName === \"NOSCRIPT\" || parent.hasAttribute(\"src\") && parent.tagName !== \"A\" || parent.closest(\"img\") && !parent.closest(\"a[href]\")) {\n                        continue;\n                    }\n                    // Allow replacement in link text (breadcrumbs, etc.) but not in href attributes\n                    if (parent.tagName === \"A\" && parent.hasAttribute(\"href\")) {\n                    // This is link text, we can replace it - continue to process\n                    } else if (parent.hasAttribute(\"href\") && parent.tagName !== \"A\") {\n                        continue;\n                    }\n                    if (node.textContent) {\n                        let text = node.textContent;\n                        // Don't trim - preserve whitespace for proper replacement\n                        // Only replace if it's plain text (not part of URL or path)\n                        if (!text.match(/https?:\\/\\//i) && !text.match(/\\/assets\\//) && !text.match(/\\.(png|jpg|jpeg|gif|svg|css|js)/i) && !text.match(/^\\/[^\\/]/)) {\n                            const originalText = text;\n                            // Replace only the company name text (case insensitive, word boundaries)\n                            text = text.replace(/\\bAllure Digital\\b/gi, \"Rimalweb\");\n                            text = text.replace(/\\bAllureDigital\\b/gi, \"Rimalweb\");\n                            text = text.replace(/\\ballure digital\\b/gi, \"Rimalweb\");\n                            if (text !== originalText) {\n                                node.textContent = text;\n                            }\n                        }\n                    }\n                }\n                // Replace in title tag (visible in browser tab)\n                tempDiv.querySelectorAll(\"title\").forEach((title)=>{\n                    if (title.textContent) {\n                        title.textContent = title.textContent.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\");\n                    }\n                });\n                // Replace in alt attributes (for accessibility)\n                tempDiv.querySelectorAll(\"img[alt]\").forEach((img)=>{\n                    const alt = img.getAttribute(\"alt\");\n                    if (alt && (alt.includes(\"Allure\") || alt.includes(\"allure\"))) {\n                        img.setAttribute(\"alt\", alt.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\"));\n                    }\n                });\n                // Replace in heading elements (h1, h2, h3, etc.) - important for hero sections\n                tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6, .elementor-heading-title, .bdt-ep-hover-box-title, [class*=\"heading\"]').forEach((heading)=>{\n                    if (heading.textContent) {\n                        const originalText = heading.textContent;\n                        let newText = originalText.replace(/\\bAllure Digital\\b/gi, \"Rimalweb\").replace(/\\bAllureDigital\\b/gi, \"Rimalweb\").replace(/\\ballure digital\\b/gi, \"Rimalweb\");\n                        if (newText !== originalText) {\n                            heading.textContent = newText;\n                        }\n                    }\n                });\n                // Replace in span and div elements that might contain company name (for hero sections)\n                tempDiv.querySelectorAll(\"span, div, p, li\").forEach((el)=>{\n                    // Skip if it's inside a link href or image src, but allow link text\n                    if (el.closest(\"img\") && !el.closest(\"a[href]\")) return;\n                    // Process if it has text content\n                    if (el.textContent) {\n                        const originalText = el.textContent;\n                        let newText = originalText.replace(/\\bAllure Digital\\b/gi, \"Rimalweb\").replace(/\\bAllureDigital\\b/gi, \"Rimalweb\").replace(/\\ballure digital\\b/gi, \"Rimalweb\");\n                        if (newText !== originalText) {\n                            // Only replace if it's a leaf node or has minimal children\n                            if (el.children.length === 0) {\n                                el.textContent = newText;\n                            } else {\n                                // For elements with children, replace in direct text nodes\n                                const directTextNodes = Array.from(el.childNodes).filter((node)=>node.nodeType === Node.TEXT_NODE);\n                                directTextNodes.forEach((textNode)=>{\n                                    if (textNode.textContent) {\n                                        const text = textNode.textContent;\n                                        const replaced = text.replace(/\\bAllure Digital\\b/gi, \"Rimalweb\").replace(/\\bAllureDigital\\b/gi, \"Rimalweb\").replace(/\\ballure digital\\b/gi, \"Rimalweb\");\n                                        if (replaced !== text) {\n                                            textNode.textContent = replaced;\n                                        }\n                                    }\n                                });\n                            }\n                        }\n                    }\n                });\n                // Replace in data attributes that might contain text\n                tempDiv.querySelectorAll(\"[data-title], [data-text], [data-content], [data-name], [data-label]\").forEach((el)=>{\n                    [\n                        \"data-title\",\n                        \"data-text\",\n                        \"data-content\",\n                        \"data-name\",\n                        \"data-label\"\n                    ].forEach((attr)=>{\n                        const value = el.getAttribute(attr);\n                        if (value && (value.includes(\"Allure\") || value.includes(\"allure\"))) {\n                            el.setAttribute(attr, value.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\"));\n                        }\n                    });\n                });\n                // Replace in aria-labels and other accessibility attributes\n                tempDiv.querySelectorAll(\"[aria-label], [title], [placeholder]\").forEach((el)=>{\n                    [\n                        \"aria-label\",\n                        \"title\",\n                        \"placeholder\"\n                    ].forEach((attr)=>{\n                        const value = el.getAttribute(attr);\n                        if (value && (value.includes(\"Allure\") || value.includes(\"allure\"))) {\n                            el.setAttribute(attr, value.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\"));\n                        }\n                    });\n                });\n                // Replace in script tags that contain JSON-LD or schema data\n                tempDiv.querySelectorAll('script[type=\"application/ld+json\"]').forEach((script)=>{\n                    if (script.textContent) {\n                        try {\n                            const jsonData = JSON.parse(script.textContent);\n                            const jsonString = JSON.stringify(jsonData);\n                            if (jsonString.includes(\"Allure\") || jsonString.includes(\"allure\")) {\n                                // Recursively replace in JSON object\n                                const replaceInObject = (obj)=>{\n                                    if (typeof obj === \"string\") {\n                                        return obj.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\").replace(/alluredigital\\.net/gi, \"rimalweb.com\");\n                                    } else if (Array.isArray(obj)) {\n                                        return obj.map(replaceInObject);\n                                    } else if (obj && typeof obj === \"object\") {\n                                        const replaced = {};\n                                        for(const key in obj){\n                                            replaced[key] = replaceInObject(obj[key]);\n                                        }\n                                        return replaced;\n                                    }\n                                    return obj;\n                                };\n                                const replaced = replaceInObject(jsonData);\n                                script.textContent = JSON.stringify(replaced);\n                            }\n                        } catch (e) {\n                            // If JSON parsing fails, do simple string replacement\n                            if (script.textContent.includes(\"Allure\") || script.textContent.includes(\"allure\")) {\n                                script.textContent = script.textContent.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\").replace(/alluredigital\\.net/gi, \"rimalweb.com\");\n                            }\n                        }\n                    }\n                });\n                // Replace in all other attributes (catch-all)\n                tempDiv.querySelectorAll(\"*\").forEach((el)=>{\n                    Array.from(el.attributes).forEach((attr)=>{\n                        // Skip src, href, and other URL attributes (already handled)\n                        if ([\n                            \"src\",\n                            \"href\",\n                            \"srcset\",\n                            \"data-src\",\n                            \"data-srcset\"\n                        ].includes(attr.name)) {\n                            return;\n                        }\n                        const value = attr.value;\n                        if (value && (value.includes(\"Allure\") || value.includes(\"allure\"))) {\n                            const replaced = value.replace(/Allure Digital/gi, \"Rimalweb\").replace(/AllureDigital/gi, \"Rimalweb\").replace(/allure digital/gi, \"Rimalweb\");\n                            if (replaced !== value) {\n                                el.setAttribute(attr.name, replaced);\n                            }\n                        }\n                    });\n                });\n                return tempDiv.innerHTML;\n            };\n            // Replace contact info (phone, email, address) with dummy data\n            const replaceContactInfo = (html)=>{\n                // Dummy contact data\n                const dummyPhone = \"+1 (555) 123-4567\";\n                const dummyEmail = \"info@rimalweb.com\";\n                const dummyAddress = \"123 Business Street, Suite 100, New York, NY 10001\";\n                // Replace phone numbers (all formats) with dummy phone\n                html = html.replace(/\\(212\\)\\s*301-7615/gi, dummyPhone);\n                html = html.replace(/212-301-7615/gi, dummyPhone);\n                html = html.replace(/\\(212\\)\\s*301\\s*7615/gi, dummyPhone);\n                html = html.replace(/212\\s*301\\s*7615/gi, dummyPhone);\n                html = html.replace(/tel:[\\d\\s\\-\\(\\)]+/gi, (match)=>{\n                    // Replace tel: links with dummy phone\n                    return match.replace(/[\\d\\s\\-\\(\\)]+/g, dummyPhone.replace(/\\s/g, \"-\").replace(/[()]/g, \"\"));\n                });\n                // Replace email addresses with dummy email\n                html = html.replace(/info@alluredigital\\.net/gi, dummyEmail);\n                html = html.replace(/[a-zA-Z0-9._%+-]+@alluredigital\\.net/gi, dummyEmail);\n                html = html.replace(/mailto:([a-zA-Z0-9._%+-]+@alluredigital\\.net)/gi, \"mailto:\".concat(dummyEmail));\n                // Replace addresses with dummy address\n                html = html.replace(/5300\\s*Kings\\s*Highway\\s*Brooklyn[^<]*/gi, dummyAddress);\n                html = html.replace(/Brooklyn,\\s*NY\\s*11234/gi, \"New York, NY 10001\");\n                html = html.replace(/1000\\s*Broadway,\\s*Brooklyn,\\s*NY\\s*11211/gi, dummyAddress);\n                // Replace contact info in text content\n                const tempDiv = document.createElement(\"div\");\n                tempDiv.innerHTML = html;\n                tempDiv.querySelectorAll(\"*\").forEach((el)=>{\n                    if (el.textContent) {\n                        let text = el.textContent;\n                        const originalText = text;\n                        // Replace phone numbers\n                        text = text.replace(/\\(212\\)\\s*301-7615/gi, dummyPhone);\n                        text = text.replace(/212-301-7615/gi, dummyPhone);\n                        text = text.replace(/\\(212\\)\\s*301\\s*7615/gi, dummyPhone);\n                        text = text.replace(/212\\s*301\\s*7615/gi, dummyPhone);\n                        // Replace emails\n                        text = text.replace(/info@alluredigital\\.net/gi, dummyEmail);\n                        text = text.replace(/[a-zA-Z0-9._%+-]+@alluredigital\\.net/gi, dummyEmail);\n                        // Replace addresses\n                        text = text.replace(/5300\\s*Kings\\s*Highway/gi, \"123 Business Street, Suite 100\");\n                        text = text.replace(/Brooklyn,\\s*NY\\s*11234/gi, \"New York, NY 10001\");\n                        text = text.replace(/1000\\s*Broadway,\\s*Brooklyn,\\s*NY\\s*11211/gi, dummyAddress);\n                        if (text !== originalText && el.childNodes.length === 1 && el.childNodes[0].nodeType === 3) {\n                            el.textContent = text.trim();\n                        } else if (text !== originalText) {\n                            // For elements with children, replace in direct text nodes\n                            const directTextNodes = Array.from(el.childNodes).filter((node)=>node.nodeType === Node.TEXT_NODE);\n                            directTextNodes.forEach((textNode)=>{\n                                if (textNode.textContent) {\n                                    let nodeText = textNode.textContent;\n                                    const originalNodeText = nodeText;\n                                    nodeText = nodeText.replace(/\\(212\\)\\s*301-7615/gi, dummyPhone);\n                                    nodeText = nodeText.replace(/212-301-7615/gi, dummyPhone);\n                                    nodeText = nodeText.replace(/info@alluredigital\\.net/gi, dummyEmail);\n                                    nodeText = nodeText.replace(/5300\\s*Kings\\s*Highway/gi, \"123 Business Street, Suite 100\");\n                                    nodeText = nodeText.replace(/Brooklyn,\\s*NY\\s*11234/gi, \"New York, NY 10001\");\n                                    if (nodeText !== originalNodeText) {\n                                        textNode.textContent = nodeText;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                // Also replace in href attributes (tel: and mailto: links) and remove Google Maps links\n                tempDiv.querySelectorAll(\"a[href]\").forEach((a)=>{\n                    const href = a.getAttribute(\"href\") || \"\";\n                    // Remove Google Maps links\n                    if (href && (href.includes(\"maps.google.com\") || href.includes(\"maps.googleapis.com\") || href.includes(\"google.com/maps\") || href.includes(\"goo.gl/maps\") || href.includes(\"maps.app.goo.gl\") || href.toLowerCase().includes(\"find us on google map\") || href.toLowerCase().includes(\"find us on map\") || href.toLowerCase().includes(\"our location\") || href.toLowerCase().includes(\"get directions\") || href.includes(\"q=\") && (href.includes(\"Brooklyn\") || href.includes(\"5300\") || href.includes(\"Kings Highway\")))) {\n                        a.removeAttribute(\"href\");\n                        const htmlEl = a;\n                        htmlEl.style.pointerEvents = \"none\";\n                        htmlEl.style.cursor = \"default\";\n                        htmlEl.style.textDecoration = \"none\";\n                        return;\n                    }\n                    if (href.startsWith(\"tel:\")) {\n                        a.setAttribute(\"href\", \"tel:\".concat(dummyPhone.replace(/\\s/g, \"\").replace(/[()]/g, \"\").replace(/-/g, \"\")));\n                    } else if (href.startsWith(\"mailto:\") && href.includes(\"alluredigital.net\")) {\n                        a.setAttribute(\"href\", \"mailto:\".concat(dummyEmail));\n                    }\n                });\n                return tempDiv.innerHTML;\n            };\n            // Set body content - fix asset URLs first, then replace branding, then remove contact info\n            // First, fix all asset URLs in the body HTML string (BEFORE any text replacement)\n            let bodyHtml = body.innerHTML;\n            // Fix URLs in data-settings attributes (JSON strings) - CRITICAL: Must be done first\n            bodyHtml = bodyHtml.replace(/data-settings=\"([^\"]*)\"/gi, (match, jsonStr)=>{\n                try {\n                    // Decode HTML entities properly\n                    const decoded = jsonStr.replace(/&amp;/g, \"&\") // Must decode &amp; first\n                    .replace(/&quot;/g, '\"').replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&#39;/g, \"'\").replace(/&#x27;/g, \"'\");\n                    // Try to parse JSON to validate structure\n                    let parsed = null;\n                    try {\n                        parsed = JSON.parse(decoded);\n                    } catch (parseError) {\n                        // If JSON is invalid, just fix URLs in the raw string without parsing\n                        let fixed = jsonStr.replace(/https?:\\/\\/([^\"\\/]+\\.)?(alluredigital|rimalweb)\\.net([^\"]*)/gi, (urlMatch, subdomain, domain, path)=>{\n                            // Case-insensitive check for rimalweb domain\n                            const urlToFix = /rimalweb/i.test(domain || urlMatch) ? urlMatch.replace(/rimalweb\\.net/gi, \"alluredigital.net\") : urlMatch;\n                            const fixedUrl = fixAssetUrl(urlToFix);\n                            // Escape the fixed URL properly for JSON\n                            return fixedUrl.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"');\n                        });\n                        return 'data-settings=\"'.concat(fixed, '\"');\n                    }\n                    // If JSON is valid, recursively fix URLs in all string values\n                    const fixUrlsInObject = (obj)=>{\n                        if (typeof obj === \"string\") {\n                            // Fix URLs in string values (case-insensitive)\n                            return obj.replace(/https?:\\/\\/([^\"\\/]+\\.)?(alluredigital|rimalweb)\\.net([^\"]*)/gi, (urlMatch, subdomain, domain, path)=>{\n                                // Case-insensitive check for rimalweb domain\n                                const urlToFix = /rimalweb/i.test(domain || urlMatch) ? urlMatch.replace(/rimalweb\\.net/gi, \"alluredigital.net\") : urlMatch;\n                                return fixAssetUrl(urlToFix);\n                            });\n                        } else if (Array.isArray(obj)) {\n                            return obj.map(fixUrlsInObject);\n                        } else if (obj && typeof obj === \"object\") {\n                            const fixed = {};\n                            for(const key in obj){\n                                fixed[key] = fixUrlsInObject(obj[key]);\n                            }\n                            return fixed;\n                        }\n                        return obj;\n                    };\n                    // Keep original slideshow - don't replace with about-banner\n                    // Removed code that was replacing slideshow with about-banner image\n                    // Also fix classic background images\n                    if (parsed.background_background === \"classic\" && parsed.background_image && parsed.background_image.url) {\n                        parsed.background_image.url = fixUrlsInObject(parsed.background_image.url);\n                    }\n                    const fixedObj = fixUrlsInObject(parsed);\n                    const fixedJson = JSON.stringify(fixedObj);\n                    // Re-encode for HTML attribute (properly escape)\n                    const reEncoded = fixedJson.replace(/&/g, \"&amp;\") // Must encode & first\n                    .replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n                    return 'data-settings=\"'.concat(reEncoded, '\"');\n                } catch (e) {\n                    // If anything fails, return original to prevent breaking the page\n                    console.warn(\"Failed to process data-settings attribute:\", e);\n                    return match;\n                }\n            });\n            // Fix URLs in src attributes (preserve exact URL format)\n            bodyHtml = bodyHtml.replace(/src=\"([^\"]*alluredigital\\.net[^\"]*)\"/gi, (match, url)=>{\n                const fixed = fixAssetUrl(url);\n                return 'src=\"'.concat(fixed, '\"');\n            });\n            // Fix URLs in srcset attributes\n            bodyHtml = bodyHtml.replace(/srcset=\"([^\"]*)\"/gi, (match, srcset)=>{\n                const fixedSrcset = srcset.split(\",\").map((src)=>{\n                    const parts = src.trim().split(/\\s+/);\n                    if (parts[0] && (/alluredigital\\.net/i.test(parts[0]) || /rimalweb\\.net/i.test(parts[0]))) {\n                        // If already has rimalweb.net (any case), convert back to alluredigital.net for filename\n                        let urlToFix = parts[0];\n                        if (/rimalweb\\.net/i.test(parts[0])) {\n                            urlToFix = parts[0].replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                        }\n                        return fixAssetUrl(urlToFix) + (parts[1] ? \" \" + parts[1] : \"\");\n                    }\n                    return src.trim();\n                }).join(\", \");\n                return 'srcset=\"'.concat(fixedSrcset, '\"');\n            });\n            // Fix URLs in style background images (including inline styles in HTML)\n            // IMPORTANT: Always convert rimalweb.net (any case) to alluredigital.net for asset filename lookup\n            bodyHtml = bodyHtml.replace(/url\\(['\"]?([^'\")]*(?:alluredigital|rimalweb)\\.net[^'\")]*)['\"]?\\)/gi, (match, url)=>{\n                // Convert rimalweb.net (any case variation) back to alluredigital.net for filename lookup\n                let urlToFix = url;\n                if (/rimalweb\\.net/gi.test(url)) {\n                    urlToFix = url.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                }\n                const fixed = fixAssetUrl(urlToFix);\n                return \"url('\".concat(fixed, \"')\");\n            });\n            // Also fix background-image in style attributes directly\n            // IMPORTANT: Always convert rimalweb.net to alluredigital.net for asset filename lookup\n            bodyHtml = bodyHtml.replace(/background-image:\\s*url\\(['\"]?([^'\")]*(?:alluredigital|rimalweb)\\.net[^'\")]*)['\"]?\\)/gi, (match, url)=>{\n                // ALWAYS convert rimalweb.net (any case) to alluredigital.net for asset filename lookup\n                // Asset files are named with alluredigital.net, not rimalweb.net\n                let urlToFix = url;\n                if (/rimalweb\\.net/gi.test(url)) {\n                    urlToFix = url.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                }\n                const fixed = fixAssetUrl(urlToFix);\n                return \"background-image: url('\".concat(fixed, \"')\");\n            });\n            // Also fix any rimalweb.net URLs that might have been replaced in HTML (case-insensitive)\n            bodyHtml = bodyHtml.replace(/src=\"([^\"]*rimalweb\\.net[^\"]*)\"/gi, (match, url)=>{\n                // Convert back to alluredigital.net for filename (handles all case variations)\n                const urlToFix = url.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                const fixed = fixAssetUrl(urlToFix);\n                return 'src=\"'.concat(fixed, '\"');\n            });\n            // Fix href attributes with rimalweb.net URLs (case-insensitive)\n            bodyHtml = bodyHtml.replace(/href=\"([^\"]*rimalweb\\.net[^\"]*)\"/gi, (match, url)=>{\n                // Convert back to alluredigital.net for filename (handles all case variations)\n                const urlToFix = url.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                const fixed = fixAssetUrl(urlToFix);\n                return 'href=\"'.concat(fixed, '\"');\n            });\n            // CRITICAL: Final cleanup - catch any /assets/Rimalweb.net URLs that slipped through\n            // This handles URLs that are already in /assets/ format but still have Rimalweb.net\n            // Direct replacement of /assets/Rimalweb.net_ to /assets/alluredigital.net_ (case-insensitive)\n            bodyHtml = bodyHtml.replace(/\\/assets\\/[Rr]imalweb\\.net_/gi, \"/assets/alluredigital.net_\");\n            bodyHtml = bodyHtml.replace(/\\/assets\\/[Rr]imal[Ww]eb\\.net_/gi, \"/assets/alluredigital.net_\");\n            // Also catch URLs in attribute values (src, href, style, etc.) that already have /assets/Rimalweb.net\n            bodyHtml = bodyHtml.replace(/((?:src|href|srcset|style|data-[^=]*)=['\"]([^'\"]*))\\/assets\\/[Rr]imalweb\\.net([^'\"]*)/gi, (match, prefix, before, after)=>{\n                return prefix + \"/assets/alluredigital.net\" + after;\n            });\n            // Catch in url() CSS functions\n            bodyHtml = bodyHtml.replace(/url\\(['\"]?([^'\"]*)\\/assets\\/[Rr]imalweb\\.net([^'\"]*)['\"]?\\)/gi, (match, before, after)=>{\n                return \"url('\".concat(before, \"/assets/alluredigital.net\").concat(after, \"')\");\n            });\n            // Now replace branding (this won't affect already-fixed URLs)\n            let cleanedHtml = replaceBranding(bodyHtml);\n            cleanedHtml = replaceContactInfo(cleanedHtml);\n            // Modify homepage headings to avoid copyright (similar but different wording)\n            const modifyHomepageHeadings = (html)=>{\n                const tempDiv = document.createElement(\"div\");\n                tempDiv.innerHTML = html;\n                // Heading replacements (similar meaning, different wording)\n                const headingReplacements = {\n                    \"Let Us Help You\": \"We're Here to Assist You\",\n                    \"Get a Tailored Approach with our Digital Marketing Agency in Brooklyn\": \"Experience Customized Solutions with our Digital Marketing Agency in New York\",\n                    \"Get a Tailored Approach with our Digital Marketing Agency in Brooklyn NY\": \"Experience Customized Solutions with our Digital Marketing Agency in New York\",\n                    \"Providing Innovative Digital Solutions for Clients since 2010\": \"Delivering Cutting-Edge Digital Solutions for Businesses since 2015\",\n                    \"A Glimpse into the Brands That Became Successful with Us\": \"Discover the Companies That Achieved Success with Us\",\n                    \"Our Working Philosophy\": \"Our Approach to Success\",\n                    \"SEO - Turn Your Web Traffic Into Profits with SEO\": \"SEO - Transform Your Website Visitors Into Revenue with SEO\",\n                    \"Unleash Your Business's Digital Potential with Our Services\": \"Unlock Your Company's Digital Growth with Our Services\",\n                    \"WE SPECIALIZE IN\": \"OUR EXPERTISE INCLUDES\",\n                    \"How Our Digital Marketing Creates a Strong Impact\": \"How Our Digital Marketing Drives Powerful Results\",\n                    \"Think Big\\nPlan Smart\\nExecute Flawlessly\": \"Dream Big\\nStrategize Wisely\\nDeliver Excellence\"\n                };\n                // Replace in all heading elements (including ha-gradient-heading for SERVICES section)\n                tempDiv.querySelectorAll(\"h1, h2, h3, h4, h5, h6, .elementor-heading-title, .ha-gradient-heading, .ep-heading\").forEach((heading)=>{\n                    if (heading.textContent) {\n                        let text = heading.textContent.trim();\n                        const originalText = text;\n                        // Handle multi-line text (like \"Unleash Your Business's Digital Potential with Our Services\\n\")\n                        text = text.replace(/\\n\\s*/g, \" \").trim();\n                        // Check for exact matches first\n                        if (headingReplacements[text]) {\n                            heading.textContent = headingReplacements[text];\n                            return;\n                        }\n                        // Check for partial matches and replace\n                        for (const [original, replacement] of Object.entries(headingReplacements)){\n                            if (text.includes(original)) {\n                                text = text.replace(original, replacement);\n                                if (text !== originalText) {\n                                    heading.textContent = text;\n                                    return;\n                                }\n                            }\n                        }\n                        // Also check trimmed original text\n                        const trimmedOriginal = originalText.replace(/\\n\\s*/g, \" \").trim();\n                        if (headingReplacements[trimmedOriginal]) {\n                            heading.textContent = headingReplacements[trimmedOriginal];\n                            return;\n                        }\n                    }\n                });\n                // Also replace in data attributes that might contain heading text (like animated headlines)\n                tempDiv.querySelectorAll(\"[data-settings]\").forEach((el)=>{\n                    const settings = el.getAttribute(\"data-settings\");\n                    if (settings && settings.includes(\"rotating_text\")) {\n                        try {\n                            const decoded = settings.replace(/&amp;/g, \"&\").replace(/&quot;/g, '\"').replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&#39;/g, \"'\");\n                            const parsed = JSON.parse(decoded);\n                            if (parsed.rotating_text) {\n                                let rotatingText = parsed.rotating_text;\n                                if (rotatingText.includes(\"Think Big\")) {\n                                    rotatingText = rotatingText.replace(/Think Big[\\s\\n]*Plan Smart[\\s\\n]*Execute Flawlessly/gi, \"Dream Big\\nStrategize Wisely\\nDeliver Excellence\");\n                                    parsed.rotating_text = rotatingText;\n                                    const fixedJson = JSON.stringify(parsed);\n                                    const reEncoded = fixedJson.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n                                    el.setAttribute(\"data-settings\", reEncoded);\n                                }\n                            }\n                        } catch (e) {\n                        // Silently continue if JSON parsing fails\n                        }\n                    }\n                });\n                return tempDiv.innerHTML;\n            };\n            // Check if this is the homepage (by checking URL or specific homepage content)\n            const isHomepage =  true && (window.location.pathname === \"/\" || window.location.pathname === \"\" || bodyHtml.includes(\"Get a Tailored Approach\") || bodyHtml.includes(\"Welcome to\") && bodyHtml.includes(\"Breaking Through\"));\n            // Only modify headings on homepage\n            if (isHomepage) {\n                cleanedHtml = modifyHomepageHeadings(cleanedHtml);\n            }\n            // FINAL SAFETY CHECK: One more pass to catch any remaining /assets/Rimalweb.net URLs\n            // This is critical as some URLs might have been missed in previous steps\n            cleanedHtml = cleanedHtml.replace(/\\/assets\\/[Rr]imal[Ww]?eb\\.net_/gi, \"/assets/alluredigital.net_\");\n            containerRef.current.innerHTML = cleanedHtml;\n            // Fix logo carousel slider images - make them smaller\n            if (containerRef.current) {\n                containerRef.current.querySelectorAll(\".bdt-logo-carousel-wrapper img, .bdt-logo-carousel-item img, .bdt-logo-carousel-img\").forEach((img)=>{\n                    const imgEl = img;\n                    imgEl.style.maxWidth = \"200px\";\n                    imgEl.style.maxHeight = \"100px\";\n                    imgEl.style.width = \"auto\";\n                    imgEl.style.height = \"auto\";\n                    imgEl.style.objectFit = \"contain\";\n                });\n            }\n            // Fix hover box images - ensure they work on hover\n            if (containerRef.current) {\n                const hoverBoxes = containerRef.current.querySelectorAll(\".bdt-ep-hover-box\");\n                hoverBoxes.forEach((hoverBox)=>{\n                    const hoverBoxEl = hoverBox;\n                    const hoverItems = hoverBoxEl.querySelectorAll(\".bdt-ep-hover-box-item\");\n                    const hoverContents = hoverBoxEl.querySelectorAll(\".bdt-ep-hover-box-content\");\n                    // Initialize - show first content by default\n                    if (hoverContents.length > 0) {\n                        hoverContents.forEach((content, index)=>{\n                            const contentEl = content;\n                            if (index === 0) {\n                                contentEl.classList.add(\"bdt-active\");\n                                contentEl.style.opacity = \"1\";\n                                contentEl.style.visibility = \"visible\";\n                                contentEl.style.display = \"block\";\n                                contentEl.style.zIndex = \"10\";\n                                // Ensure first image is visible\n                                const img = contentEl.querySelector(\".bdt-ep-hover-box-img\");\n                                if (img) {\n                                    img.style.opacity = \"1\";\n                                    img.style.visibility = \"visible\";\n                                    img.style.display = \"block\";\n                                    img.style.backgroundSize = \"cover\";\n                                    img.style.backgroundPosition = \"center\";\n                                    img.style.backgroundRepeat = \"no-repeat\";\n                                }\n                            } else {\n                                contentEl.classList.remove(\"bdt-active\");\n                                contentEl.style.opacity = \"0\";\n                                contentEl.style.visibility = \"hidden\";\n                                contentEl.style.display = \"none\";\n                                contentEl.style.zIndex = \"1\";\n                            }\n                        });\n                    }\n                    // Helper function to show hover content by data-id\n                    const showHoverContent = (dataId)=>{\n                        // Hide all contents first\n                        hoverContents.forEach((content)=>{\n                            const contentEl = content;\n                            contentEl.classList.remove(\"bdt-active\");\n                            contentEl.style.opacity = \"0\";\n                            contentEl.style.visibility = \"hidden\";\n                            contentEl.style.display = \"none\";\n                            contentEl.style.zIndex = \"1\";\n                            // Hide images inside\n                            const img = contentEl.querySelector(\".bdt-ep-hover-box-img\");\n                            if (img) {\n                                img.style.opacity = \"0\";\n                                img.style.visibility = \"hidden\";\n                                img.style.display = \"none\";\n                            }\n                        });\n                        // Show corresponding content\n                        const targetContent = hoverBoxEl.querySelector(\"#\".concat(dataId));\n                        if (targetContent) {\n                            targetContent.classList.add(\"bdt-active\");\n                            targetContent.style.opacity = \"1\";\n                            targetContent.style.visibility = \"visible\";\n                            targetContent.style.display = \"block\";\n                            targetContent.style.zIndex = \"10\";\n                            // Ensure the image inside is visible and loaded\n                            const img = targetContent.querySelector(\".bdt-ep-hover-box-img\");\n                            if (img) {\n                                // Get background image URL from style attribute\n                                const styleAttr = img.getAttribute(\"style\") || \"\";\n                                const bgMatch = styleAttr.match(/background-image:\\s*url\\(['\"]?([^'\")]+)['\"]?\\)/i);\n                                let imgUrl = bgMatch ? bgMatch[1] : null;\n                                // If no URL in style, check computed style\n                                if (!imgUrl) {\n                                    const computedStyle = window.getComputedStyle(img);\n                                    const bgImage = computedStyle.backgroundImage;\n                                    if (bgImage && bgImage !== \"none\") {\n                                        const urlMatch = bgImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/i);\n                                        imgUrl = urlMatch ? urlMatch[1] : null;\n                                    }\n                                }\n                                // Set image styles\n                                img.style.opacity = \"1\";\n                                img.style.visibility = \"visible\";\n                                img.style.display = \"block\";\n                                img.style.backgroundSize = \"cover\";\n                                img.style.backgroundPosition = \"center\";\n                                img.style.backgroundRepeat = \"no-repeat\";\n                                // If we have a URL, ensure it's loaded\n                                if (imgUrl) {\n                                    // Fix URL if needed\n                                    // IMPORTANT: Always convert rimalweb.net to alluredigital.net for asset filename lookup\n                                    let fixedUrl = imgUrl;\n                                    if (imgUrl && (/alluredigital\\.net/i.test(imgUrl) || /rimalweb\\.net/i.test(imgUrl))) {\n                                        // ALWAYS convert rimalweb.net (any case) to alluredigital.net - asset files use alluredigital.net\n                                        let urlToFix = imgUrl;\n                                        if (/rimalweb\\.net/i.test(imgUrl)) {\n                                            urlToFix = imgUrl.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                                        }\n                                        fixedUrl = fixAssetUrl(urlToFix);\n                                    }\n                                    // Set background image\n                                    img.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                                    // Preload to ensure it's loaded\n                                    const testImg = new Image();\n                                    testImg.onload = function() {\n                                        img.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                                        img.style.opacity = \"1\";\n                                        img.style.visibility = \"visible\";\n                                    };\n                                    testImg.onerror = function() {\n                                        // Try without size suffix\n                                        const altUrl = fixedUrl.replace(/-\\d+x\\d+(\\.[a-z]+)$/i, \"$1\");\n                                        if (altUrl !== fixedUrl) {\n                                            img.style.backgroundImage = \"url('\".concat(altUrl, \"')\");\n                                            const altTestImg = new Image();\n                                            altTestImg.onload = function() {\n                                                img.style.backgroundImage = \"url('\".concat(altUrl, \"')\");\n                                            };\n                                            altTestImg.src = altUrl;\n                                        }\n                                    };\n                                    testImg.src = fixedUrl;\n                                }\n                            }\n                        }\n                    };\n                    // Add hover event listeners to ALL items (all 5 services)\n                    // Services: bdt-box-10e85857, bdt-box-20e85857, bdt-box-30e85857, bdt-box-40e85857, bdt-box-50e85857\n                    hoverItems.forEach((item, index)=>{\n                        const itemEl = item;\n                        const dataId = itemEl.getAttribute(\"data-id\");\n                        if (dataId) {\n                            // Create hover handler function for this specific item\n                            const handleHover = ()=>{\n                                showHoverContent(dataId);\n                            };\n                            // Add hover to item itself\n                            itemEl.addEventListener(\"mouseenter\", handleHover);\n                            itemEl.addEventListener(\"mouseleave\", ()=>{\n                            // Keep the current hovered content visible when mouse leaves item\n                            });\n                            // Add hover to ALL title links inside the item\n                            // This ensures links work: .bdt-ep-hover-box-title-link, .bdt-ep-hover-box-title, a, h2\n                            const titleLinks = itemEl.querySelectorAll(\".bdt-ep-hover-box-title-link, .bdt-ep-hover-box-title, a, h2, .ep-title\");\n                            titleLinks.forEach((link)=>{\n                                const linkEl = link;\n                                // Add multiple event types to ensure hover works on all links\n                                linkEl.addEventListener(\"mouseenter\", (e)=>{\n                                    e.stopPropagation();\n                                    handleHover();\n                                });\n                                linkEl.addEventListener(\"mouseover\", (e)=>{\n                                    e.stopPropagation();\n                                    handleHover();\n                                });\n                                linkEl.addEventListener(\"focus\", (e)=>{\n                                    e.stopPropagation();\n                                    handleHover();\n                                });\n                            });\n                            // Use event delegation on item - capture phase to catch all child events\n                            itemEl.addEventListener(\"mouseenter\", (e)=>{\n                                handleHover();\n                            }, true);\n                            itemEl.addEventListener(\"mouseover\", (e)=>{\n                                handleHover();\n                            }, true);\n                            // Add hover to parent wrapper if exists\n                            const itemWrap = itemEl.closest(\".bdt-ep-hover-box-item-wrap\");\n                            if (itemWrap && itemWrap !== itemEl) {\n                                itemWrap.addEventListener(\"mouseenter\", handleHover);\n                            }\n                            // Also handle direct hover on any child element\n                            itemEl.addEventListener(\"mouseenter\", handleHover);\n                        }\n                    });\n                    // Also handle hover box container mouse leave\n                    hoverBoxEl.addEventListener(\"mouseleave\", ()=>{\n                        // Reset to first content when mouse leaves the entire hover box\n                        if (hoverContents.length > 0) {\n                            hoverContents.forEach((content, index)=>{\n                                const contentEl = content;\n                                if (index === 0) {\n                                    contentEl.classList.add(\"bdt-active\");\n                                    contentEl.style.opacity = \"1\";\n                                    contentEl.style.visibility = \"visible\";\n                                    contentEl.style.display = \"block\";\n                                    contentEl.style.zIndex = \"10\";\n                                    // Ensure first image is visible\n                                    const img = contentEl.querySelector(\".bdt-ep-hover-box-img\");\n                                    if (img) {\n                                        img.style.opacity = \"1\";\n                                        img.style.visibility = \"visible\";\n                                        img.style.display = \"block\";\n                                    }\n                                } else {\n                                    contentEl.classList.remove(\"bdt-active\");\n                                    contentEl.style.opacity = \"0\";\n                                    contentEl.style.visibility = \"hidden\";\n                                    contentEl.style.display = \"none\";\n                                }\n                            });\n                        }\n                    });\n                    // Preload ALL hover box images to ensure they're ready\n                    hoverContents.forEach((content)=>{\n                        const contentEl = content;\n                        const img = contentEl.querySelector(\".bdt-ep-hover-box-img\");\n                        if (img) {\n                            const style = img.getAttribute(\"style\") || \"\";\n                            const bgMatch = style.match(/background-image:\\s*url\\(['\"]?([^'\")]+)['\"]?\\)/i);\n                            if (bgMatch && bgMatch[1]) {\n                                let imgUrl = bgMatch[1];\n                                // Fix URL if needed\n                                // IMPORTANT: Always convert rimalweb.net (any case) to alluredigital.net for asset filename lookup\n                                if (imgUrl && (/alluredigital\\.net/i.test(imgUrl) || /rimalweb\\.net/i.test(imgUrl))) {\n                                    // ALWAYS convert rimalweb.net (any case) to alluredigital.net - asset files use alluredigital.net\n                                    let urlToFix = imgUrl;\n                                    if (/rimalweb\\.net/i.test(imgUrl)) {\n                                        urlToFix = imgUrl.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                                    }\n                                    imgUrl = fixAssetUrl(urlToFix);\n                                }\n                                // Preload image\n                                const preloadImg = new Image();\n                                preloadImg.src = imgUrl;\n                            }\n                        }\n                    });\n                });\n            }\n            // Fix header and navbar width issues - ensure full width\n            if (containerRef.current) {\n                // Fix sticky header sections - make them full width\n                containerRef.current.querySelectorAll(\".elementor-sticky, .elementor-sticky--active, .elementor-sticky__spacer\").forEach((el)=>{\n                    const htmlEl = el;\n                    // Remove fixed width and set to 100%\n                    htmlEl.style.width = \"100%\";\n                    htmlEl.style.maxWidth = \"100%\";\n                    htmlEl.style.left = \"0\";\n                    htmlEl.style.right = \"0\";\n                    // Ensure proper positioning\n                    if (htmlEl.style.position === \"fixed\" || htmlEl.classList.contains(\"elementor-sticky--active\")) {\n                        htmlEl.style.position = \"fixed\";\n                        htmlEl.style.top = \"0\";\n                        htmlEl.style.zIndex = \"9999\";\n                    }\n                });\n                // Fix header container width\n                containerRef.current.querySelectorAll('header[data-elementor-type=\"header\"]').forEach((header)=>{\n                    const headerEl = header;\n                    headerEl.style.width = \"100%\";\n                    headerEl.style.maxWidth = \"100%\";\n                    headerEl.style.left = \"0\";\n                    headerEl.style.right = \"0\";\n                });\n                // Fix top banner section (black section) - ensure full width\n                containerRef.current.querySelectorAll('.elementor-element-a6de6a2, [data-id=\"a6de6a2\"]').forEach((el)=>{\n                    const htmlEl = el;\n                    htmlEl.style.width = \"100%\";\n                    htmlEl.style.maxWidth = \"100%\";\n                    htmlEl.style.left = \"0\";\n                    htmlEl.style.right = \"0\";\n                    // Fix container inside\n                    const container = htmlEl.querySelector(\".elementor-container\");\n                    if (container) {\n                        const containerEl = container;\n                        containerEl.style.maxWidth = \"100%\";\n                        containerEl.style.width = \"100%\";\n                    }\n                });\n                // Fix navbar sections - ensure full width\n                containerRef.current.querySelectorAll(\"header .elementor-section, header section\").forEach((el)=>{\n                    const htmlEl = el;\n                    // Only fix if it's a sticky or header section\n                    if (htmlEl.classList.contains(\"elementor-sticky\") || htmlEl.closest(\"header\") !== null || htmlEl.getAttribute(\"data-elementor-type\") === \"section\") {\n                        htmlEl.style.width = \"100%\";\n                        htmlEl.style.maxWidth = \"100%\";\n                        htmlEl.style.left = \"0\";\n                        htmlEl.style.right = \"0\";\n                    }\n                });\n                // Add global CSS to ensure header sections are full width\n                const styleId = \"header-width-fix\";\n                if (!document.getElementById(styleId)) {\n                    const style = document.createElement(\"style\");\n                    style.id = styleId;\n                    style.textContent = '\\n            /* Fix header and navbar width issues */\\n            header[data-elementor-type=\"header\"],\\n            header .elementor-sticky,\\n            header .elementor-sticky--active,\\n            header .elementor-sticky__spacer,\\n            .elementor-element-a6de6a2,\\n            [data-id=\"a6de6a2\"] {\\n              width: 100% !important;\\n              max-width: 100% !important;\\n              left: 0 !important;\\n              right: 0 !important;\\n            }\\n            \\n            /* Fix sticky header positioning */\\n            .elementor-sticky--active {\\n              position: fixed !important;\\n              top: 0 !important;\\n              z-index: 9999 !important;\\n              width: 100% !important;\\n              max-width: 100% !important;\\n            }\\n            \\n            /* Fix header container */\\n            header[data-elementor-type=\"header\"] .elementor-container {\\n              max-width: 100% !important;\\n              width: 100% !important;\\n            }\\n            \\n            /* Ensure body doesn\\'t have overflow issues */\\n            body {\\n              overflow-x: hidden !important;\\n            }\\n            \\n            /* Fix navbar when scrolling */\\n            .elementor-sticky--effects {\\n              width: 100% !important;\\n              max-width: 100% !important;\\n            }\\n            \\n            /* Fix all header sections to be full width */\\n            header .elementor-section {\\n              width: 100% !important;\\n              max-width: 100% !important;\\n            }\\n            \\n            /* Keep navbar logo very small to maintain navbar height */\\n            header img[src*=\"1.png\"],\\n            header img[src*=\"/1.png\"],\\n            header .elementor-widget-image img,\\n            header [class*=\"logo\"] img {\\n              max-height: 40px !important;\\n              max-width: 150px !important;\\n              height: auto !important;\\n              width: auto !important;\\n              object-fit: contain !important;\\n            }\\n            \\n            /* Ensure navbar doesn\\'t expand due to logo */\\n            header .elementor-widget-image {\\n              display: flex !important;\\n              align-items: center !important;\\n            }\\n            \\n            /* Fix offcanvas menu to show properly from right side */\\n            .bdt-offcanvas {\\n              position: fixed !important;\\n              top: 0 !important;\\n              right: 0 !important;\\n              width: 400px !important;\\n              max-width: 90vw !important;\\n              height: 100vh !important;\\n              background: #fff !important;\\n              z-index: 10000 !important;\\n              transform: translateX(100%) !important;\\n              transition: transform 0.3s ease !important;\\n              overflow-y: auto !important;\\n              box-shadow: -2px 0 10px rgba(0,0,0,0.1) !important;\\n              display: none !important;\\n              visibility: hidden !important;\\n              opacity: 0 !important;\\n            }\\n            \\n            .bdt-offcanvas.bdt-open,\\n            .bdt-offcanvas[aria-hidden=\"false\"],\\n            .bdt-offcanvas[style*=\"display: block\"] {\\n              display: block !important;\\n              visibility: visible !important;\\n              opacity: 1 !important;\\n              transform: translateX(0) !important;\\n            }\\n            \\n            /* Hide offcanvas by default - only show when opened */\\n            .bdt-offcanvas:not(.bdt-open):not([aria-hidden=\"false\"]) {\\n              display: none !important;\\n              visibility: hidden !important;\\n            }\\n            \\n            .bdt-offcanvas-bar {\\n              padding: 30px !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n            }\\n            \\n            /* Offcanvas overlay */\\n            .bdt-offcanvas-page::before {\\n              content: \\'\\' !important;\\n              position: fixed !important;\\n              top: 0 !important;\\n              left: 0 !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n              background: rgba(0,0,0,0.5) !important;\\n              z-index: 9999 !important;\\n            }\\n            \\n            /* Offcanvas button styling */\\n            .bdt-offcanvas-button {\\n              cursor: pointer !important;\\n              display: inline-flex !important;\\n              align-items: center !important;\\n            }\\n            \\n            /* Ensure offcanvas content is visible */\\n            .bdt-offcanvas .elementor-section,\\n            .bdt-offcanvas .elementor-widget {\\n              opacity: 1 !important;\\n              visibility: visible !important;\\n            }\\n            \\n            /* Fix logo carousel slider images - make them smaller */\\n            .bdt-logo-carousel-wrapper .bdt-logo-carousel-img,\\n            .bdt-logo-carousel-item img,\\n            .bdt-logo-carousel-figure img {\\n              max-width: 200px !important;\\n              max-height: 100px !important;\\n              width: auto !important;\\n              height: auto !important;\\n              object-fit: contain !important;\\n            }\\n            \\n            .bdt-logo-carousel-item {\\n              display: flex !important;\\n              align-items: center !important;\\n              justify-content: center !important;\\n            }\\n            \\n            .bdt-logo-carousel-figure {\\n              display: flex !important;\\n              align-items: center !important;\\n              justify-content: center !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n            }\\n            \\n            /* Fix hover box images - ensure they are visible on hover */\\n            .bdt-ep-hover-box {\\n              position: relative !important;\\n            }\\n            \\n            .bdt-ep-hover-box-img {\\n              opacity: 1 !important;\\n              visibility: visible !important;\\n              background-size: cover !important;\\n              background-position: center !important;\\n              background-repeat: no-repeat !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n              transition: opacity 0.3s ease !important;\\n            }\\n            \\n            /* Ensure hover box images don\\'t get purple gradient - override any gradient */\\n            .bdt-ep-hover-box-img[style*=\"linear-gradient\"] {\\n              background: transparent !important;\\n            }\\n            \\n            .bdt-ep-hover-box-content {\\n              opacity: 0 !important;\\n              visibility: hidden !important;\\n              transition: opacity 0.3s ease, visibility 0.3s ease !important;\\n              position: absolute !important;\\n              top: 0 !important;\\n              left: 0 !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n              z-index: 1 !important;\\n            }\\n            \\n            .bdt-ep-hover-box-content.bdt-active {\\n              opacity: 1 !important;\\n              visibility: visible !important;\\n              display: block !important;\\n              z-index: 10 !important;\\n            }\\n            \\n            .bdt-ep-hover-box-content.bdt-active .bdt-ep-hover-box-img {\\n              opacity: 1 !important;\\n              visibility: visible !important;\\n              display: block !important;\\n              background-size: cover !important;\\n              background-position: center !important;\\n              background-repeat: no-repeat !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n            }\\n            \\n            /* Ensure hover works on all parts of the service item */\\n            .bdt-ep-hover-box-item,\\n            .bdt-ep-hover-box-item *,\\n            .bdt-ep-hover-box-title,\\n            .bdt-ep-hover-box-title-link {\\n              cursor: pointer !important;\\n            }\\n            \\n            .bdt-ep-hover-box-item:hover,\\n            .bdt-ep-hover-box-title:hover,\\n            .bdt-ep-hover-box-title-link:hover {\\n              opacity: 1 !important;\\n            }\\n            \\n            /* Make sure hover items trigger image change */\\n            .bdt-ep-hover-box-item-wrap {\\n              position: relative !important;\\n              z-index: 10 !important;\\n            }\\n            \\n            /* Hero Section Animations - Ensure animations work properly */\\n            .animated-fast,\\n            .animated-slow,\\n            .animated,\\n            .elementor-invisible {\\n              visibility: visible !important;\\n            }\\n            \\n            /* SlideInUp Animation */\\n            @keyframes slideInUp {\\n              from {\\n                opacity: 0;\\n                transform: translate3d(0, 40px, 0);\\n              }\\n              to {\\n                opacity: 1;\\n                transform: translate3d(0, 0, 0);\\n              }\\n            }\\n            \\n            .animated-slideInUp,\\n            .animated-fast.animated.slideInUp,\\n            .animated-slow.animated.fadeInLeft {\\n              animation-fill-mode: both;\\n            }\\n            \\n            .animated-fast {\\n              animation-duration: 0.6s !important;\\n            }\\n            \\n            .animated-slow {\\n              animation-duration: 1s !important;\\n            }\\n            \\n            .elementor-widget[data-settings*=\"_animation\"]:not(.elementor-invisible),\\n            .elementor-widget.animated-fast:not(.elementor-invisible),\\n            .elementor-widget.animated-slow:not(.elementor-invisible) {\\n              opacity: 1 !important;\\n              visibility: visible !important;\\n            }\\n            \\n            /* FadeInLeft Animation */\\n            @keyframes fadeInLeft {\\n              from {\\n                opacity: 0;\\n                transform: translate3d(-40px, 0, 0);\\n              }\\n              to {\\n                opacity: 1;\\n                transform: translate3d(0, 0, 0);\\n              }\\n            }\\n            \\n            /* FadeInUp Animation */\\n            @keyframes fadeInUp {\\n              from {\\n                opacity: 0;\\n                transform: translate3d(0, 40px, 0);\\n              }\\n              to {\\n                opacity: 1;\\n                transform: translate3d(0, 0, 0);\\n              }\\n            }\\n            \\n            .animated-fadeInLeft {\\n              animation-name: fadeInLeft;\\n              animation-fill-mode: both;\\n            }\\n            \\n            .animated-fadeInUp {\\n              animation-name: fadeInUp;\\n              animation-fill-mode: both;\\n            }\\n            \\n            /* Animated Headline - Rotating Text */\\n            .elementor-headline {\\n              display: inline-block;\\n              margin-top: 15px !important;\\n              padding-top: 0 !important;\\n              overflow: visible !important;\\n              white-space: nowrap !important;\\n            }\\n            \\n            .elementor-headline-text-wrapper {\\n              display: inline-block;\\n              position: relative;\\n              width: auto !important;\\n              min-width: fit-content !important;\\n              overflow: visible !important;\\n              white-space: nowrap !important;\\n            }\\n            \\n            .elementor-headline-dynamic-text {\\n              opacity: 0;\\n              position: absolute;\\n              top: 0;\\n              left: 0;\\n              white-space: nowrap !important;\\n              overflow: visible !important;\\n              width: auto !important;\\n            }\\n            \\n            .elementor-headline-text-active {\\n              opacity: 1;\\n              position: relative;\\n              white-space: nowrap !important;\\n              overflow: visible !important;\\n              width: auto !important;\\n            }\\n            \\n            .elementor-headline-dynamic-wrapper {\\n              width: auto !important;\\n              min-width: fit-content !important;\\n              overflow: visible !important;\\n              white-space: nowrap !important;\\n            }\\n            \\n            /* Add spacing to animated headline widget container */\\n            .elementor-widget-animated-headline {\\n              margin-top: 15px !important;\\n            }\\n            \\n            .elementor-widget-animated-headline .elementor-widget-container {\\n              margin-top: 15px !important;\\n            }\\n            \\n            /* Hero Section Fonts */\\n            body,\\n            .elementor-heading-title,\\n            .elementor-widget-heading .elementor-heading-title,\\n            h1, h2, h3, h4, h5, h6 {\\n              font-family: \\'Montserrat\\', -apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;\\n            }\\n            \\n            .elementor-headline,\\n            .elementor-headline-dynamic-text {\\n              font-family: \\'Montserrat\\', sans-serif !important;\\n            }\\n            \\n            /* Ensure Poppins is used where specified */\\n            [style*=\"font-family: Poppins\"],\\n            [style*=\"font-family: \\'Poppins\\'\"],\\n            [style*=\"Poppins-Bold\"],\\n            [style*=\"Poppins-SemiBold\"] {\\n              font-family: \\'Poppins\\', sans-serif !important;\\n            }\\n            \\n            /* Hero Section Slideshow - Ensure only one slide is visible at a time */\\n            .elementor-background-slideshow {\\n              position: absolute !important;\\n              top: 0 !important;\\n              left: 0 !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n              z-index: 0 !important;\\n            }\\n            \\n            .elementor-background-slideshow .swiper-wrapper {\\n              position: relative !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n            }\\n            \\n            .elementor-background-slideshow__slide {\\n              position: absolute !important;\\n              top: 0 !important;\\n              left: 0 !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n              opacity: 0 !important;\\n              transition: opacity 1.8s ease !important;\\n            }\\n            \\n            /* Only active/visible slides should be visible */\\n            .elementor-background-slideshow__slide.swiper-slide-active,\\n            .elementor-background-slideshow__slide.swiper-slide-visible {\\n              opacity: 1 !important;\\n              z-index: 1 !important;\\n            }\\n            \\n            /* Hide duplicate slides but keep them for loop */\\n            .elementor-background-slideshow__slide.swiper-slide-duplicate {\\n              opacity: 0 !important;\\n              visibility: hidden !important;\\n              display: block !important; /* Keep display for loop */\\n            }\\n            \\n            /* Ensure slide images fill properly */\\n            .elementor-background-slideshow__slide__image {\\n              position: absolute !important;\\n              top: 0 !important;\\n              left: 0 !important;\\n              width: 100% !important;\\n              height: 100% !important;\\n              background-size: cover !important;\\n              background-position: center !important;\\n              background-repeat: no-repeat !important;\\n            }\\n            \\n            /* Hide phone and email in hero section */\\n            [data-id=\"82105a4\"] .elementor-icon-list-item,\\n            [data-id=\"15371e5\"] .elementor-icon-list-item {\\n              /* Hide items containing phone or email */\\n            }\\n            \\n            [data-id=\"82105a4\"] .elementor-icon-list-item:has(a[href*=\"tel:\"]),\\n            [data-id=\"15371e5\"] .elementor-icon-list-item:has(a[href*=\"tel:\"]),\\n            [data-id=\"82105a4\"] .elementor-icon-list-item:has(a[href*=\"mailto:\"]),\\n            [data-id=\"15371e5\"] .elementor-icon-list-item:has(a[href*=\"mailto:\"]) {\\n              display: none !important;\\n              visibility: hidden !important;\\n              opacity: 0 !important;\\n              height: 0 !important;\\n              margin: 0 !important;\\n              padding: 0 !important;\\n              overflow: hidden !important;\\n            }\\n            \\n            /* Hide icon list widgets that contain only phone/email */\\n            [data-id=\"82105a4\"] .elementor-icon-list:has(.elementor-icon-list-item:only-child a[href*=\"tel:\"]),\\n            [data-id=\"15371e5\"] .elementor-icon-list:has(.elementor-icon-list-item:only-child a[href*=\"tel:\"]),\\n            [data-id=\"82105a4\"] .elementor-icon-list:has(.elementor-icon-list-item:only-child a[href*=\"mailto:\"]),\\n            [data-id=\"15371e5\"] .elementor-icon-list:has(.elementor-icon-list-item:only-child a[href*=\"mailto:\"]) {\\n              display: none !important;\\n              visibility: hidden !important;\\n              opacity: 0 !important;\\n              height: 0 !important;\\n              margin: 0 !important;\\n              padding: 0 !important;\\n            }\\n            \\n            /* Hide specific widget IDs that might contain phone/email */\\n            [data-id=\"82105a4\"] [data-id=\"0d5e304\"],\\n            [data-id=\"82105a4\"] [data-id=\"c06f9c4\"],\\n            [data-id=\"15371e5\"] [data-id=\"0d5e304\"],\\n            [data-id=\"15371e5\"] [data-id=\"c06f9c4\"] {\\n              display: none !important;\\n              visibility: hidden !important;\\n              opacity: 0 !important;\\n              height: 0 !important;\\n              margin: 0 !important;\\n              padding: 0 !important;\\n            }\\n          ';\n                    document.head.appendChild(style);\n                }\n                // Add scroll listener to continuously fix width on scroll\n                const fixHeaderWidth = ()=>{\n                    if (!containerRef.current) return;\n                    // Fix all sticky elements on scroll\n                    containerRef.current.querySelectorAll(\".elementor-sticky, .elementor-sticky--active, .elementor-sticky__spacer\").forEach((el)=>{\n                        const htmlEl = el;\n                        htmlEl.style.width = \"100%\";\n                        htmlEl.style.maxWidth = \"100%\";\n                        htmlEl.style.left = \"0\";\n                        htmlEl.style.right = \"0\";\n                    });\n                    // Fix header sections\n                    containerRef.current.querySelectorAll(\"header .elementor-section\").forEach((el)=>{\n                        const htmlEl = el;\n                        htmlEl.style.width = \"100%\";\n                        htmlEl.style.maxWidth = \"100%\";\n                    });\n                };\n                // Run on scroll with throttling\n                const scrollHandler = ()=>{\n                    if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);\n                    scrollTimeoutRef.current = setTimeout(fixHeaderWidth, 10);\n                };\n                window.addEventListener(\"scroll\", scrollHandler, {\n                    passive: true\n                });\n                // Also run on resize\n                window.addEventListener(\"resize\", fixHeaderWidth, {\n                    passive: true\n                });\n                // Store cleanup function in ref\n                cleanupRef.current = ()=>{\n                    window.removeEventListener(\"scroll\", scrollHandler);\n                    window.removeEventListener(\"resize\", fixHeaderWidth);\n                    if (scrollTimeoutRef.current) {\n                        clearTimeout(scrollTimeoutRef.current);\n                        scrollTimeoutRef.current = null;\n                    }\n                };\n            }\n            // Initialize Hero Section Animations\n            if (containerRef.current) {\n                // Remove elementor-invisible from hero section elements\n                const heroSections = containerRef.current.querySelectorAll('[data-id=\"82105a4\"], [data-id=\"15371e5\"]');\n                heroSections.forEach((heroSection)=>{\n                    // Hide phone and email icon lists in hero section\n                    const phoneEmailElements = heroSection.querySelectorAll(\".elementor-icon-list-item\");\n                    phoneEmailElements.forEach((el)=>{\n                        const htmlEl = el;\n                        const text = htmlEl.textContent || \"\";\n                        // Hide if contains phone number or email\n                        if (text.includes(\"(212)\") || text.includes(\"301-7615\") || text.includes(\"@\") || text.includes(\"tel:\") || text.includes(\"mailto:\")) {\n                            htmlEl.style.display = \"none\";\n                            htmlEl.style.visibility = \"hidden\";\n                            htmlEl.style.opacity = \"0\";\n                            htmlEl.style.height = \"0\";\n                            htmlEl.style.margin = \"0\";\n                            htmlEl.style.padding = \"0\";\n                        }\n                    });\n                    // Also hide parent icon-list containers if they only contain phone/email\n                    const iconLists = heroSection.querySelectorAll(\".elementor-icon-list\");\n                    iconLists.forEach((iconList)=>{\n                        const listEl = iconList;\n                        const items = listEl.querySelectorAll(\".elementor-icon-list-item\");\n                        let allHidden = true;\n                        items.forEach((item)=>{\n                            const itemEl = item;\n                            if (itemEl.style.display !== \"none\") {\n                                allHidden = false;\n                            }\n                        });\n                        if (allHidden && items.length > 0) {\n                            listEl.style.display = \"none\";\n                            listEl.style.visibility = \"hidden\";\n                            listEl.style.opacity = \"0\";\n                            listEl.style.height = \"0\";\n                            listEl.style.margin = \"0\";\n                            listEl.style.padding = \"0\";\n                        }\n                    });\n                    heroSection.querySelectorAll(\".elementor-invisible, .animated-fast, .animated-slow, .animated\").forEach((el)=>{\n                        const htmlEl = el;\n                        // Remove invisible class\n                        el.classList.remove(\"elementor-invisible\");\n                        // Get animation settings\n                        const settings = htmlEl.getAttribute(\"data-settings\");\n                        if (settings) {\n                            try {\n                                const decoded = settings.replace(/&quot;/g, '\"').replace(/&amp;/g, \"&\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n                                const parsed = JSON.parse(decoded);\n                                if (parsed._animation) {\n                                    const animationType = parsed._animation;\n                                    const animationDelay = parsed._animation_delay || 0;\n                                    // Apply animation\n                                    setTimeout(()=>{\n                                        htmlEl.style.visibility = \"visible\";\n                                        htmlEl.style.opacity = \"1\";\n                                        // Add animation classes\n                                        if (animationType === \"slideInUp\") {\n                                            htmlEl.style.animation = \"slideInUp 0.6s ease-out \".concat(animationDelay, \"ms both\");\n                                        } else if (animationType === \"fadeInLeft\") {\n                                            htmlEl.style.animation = \"fadeInLeft 1s ease-out \".concat(animationDelay, \"ms both\");\n                                        } else if (animationType === \"fadeInUp\") {\n                                            htmlEl.style.animation = \"fadeInUp 0.6s ease-out \".concat(animationDelay, \"ms both\");\n                                        }\n                                    }, animationDelay);\n                                } else {\n                                    // No animation delay, show immediately\n                                    htmlEl.style.visibility = \"visible\";\n                                    htmlEl.style.opacity = \"1\";\n                                }\n                            } catch (e) {\n                                // If parsing fails, just make visible\n                                htmlEl.style.visibility = \"visible\";\n                                htmlEl.style.opacity = \"1\";\n                            }\n                        } else {\n                            // No settings, make visible immediately\n                            htmlEl.style.visibility = \"visible\";\n                            htmlEl.style.opacity = \"1\";\n                        }\n                    });\n                });\n                // Initialize Animated Headline (rotating text) for hero section\n                const animatedHeadlines = containerRef.current.querySelectorAll(\".elementor-headline\");\n                animatedHeadlines.forEach((headline)=>{\n                    const headlineEl = headline;\n                    const widgetEl = headlineEl.closest('[data-settings*=\"rotating_text\"]');\n                    const settings = widgetEl === null || widgetEl === void 0 ? void 0 : widgetEl.getAttribute(\"data-settings\");\n                    if (settings && widgetEl) {\n                        try {\n                            // Remove elementor-invisible class from widget and headline\n                            widgetEl.classList.remove(\"elementor-invisible\");\n                            headlineEl.classList.remove(\"elementor-invisible\");\n                            const decoded = settings.replace(/&quot;/g, '\"').replace(/&amp;/g, \"&\").replace(/&#39;/g, \"'\");\n                            const parsed = JSON.parse(decoded);\n                            if (parsed.rotating_text) {\n                                // Ensure headline is visible and add spacing\n                                headlineEl.style.visibility = \"visible\";\n                                headlineEl.style.opacity = \"1\";\n                                headlineEl.style.marginTop = \"15px\";\n                                widgetEl.style.visibility = \"visible\";\n                                widgetEl.style.opacity = \"1\";\n                                widgetEl.style.marginTop = \"15px\";\n                                // Also add margin to widget container\n                                const widgetContainer = widgetEl.querySelector(\".elementor-widget-container\");\n                                if (widgetContainer) {\n                                    widgetContainer.style.marginTop = \"15px\";\n                                }\n                                // Get all text spans\n                                const textSpans = headlineEl.querySelectorAll(\".elementor-headline-dynamic-text\");\n                                // Fix text wrapper width to show full text\n                                const textWrapper = headlineEl.querySelector(\".elementor-headline-text-wrapper\");\n                                if (textWrapper) {\n                                    // Remove fixed width to allow text to expand\n                                    textWrapper.style.width = \"auto\";\n                                    textWrapper.style.minWidth = \"fit-content\";\n                                    textWrapper.style.overflow = \"visible\";\n                                    textWrapper.style.whiteSpace = \"nowrap\";\n                                }\n                                // Fix dynamic wrapper width\n                                const dynamicWrapper = headlineEl.querySelector(\".elementor-headline-dynamic-wrapper\");\n                                if (dynamicWrapper) {\n                                    dynamicWrapper.style.width = \"auto\";\n                                    dynamicWrapper.style.minWidth = \"fit-content\";\n                                    dynamicWrapper.style.overflow = \"visible\";\n                                    dynamicWrapper.style.whiteSpace = \"nowrap\";\n                                }\n                                // Ensure headline itself doesn't clip\n                                headlineEl.style.overflow = \"visible\";\n                                headlineEl.style.whiteSpace = \"nowrap\";\n                                if (textSpans.length > 1) {\n                                    // Get rotation settings\n                                    const loop = parsed.loop !== \"no\";\n                                    const iterationDelay = parsed.rotate_iteration_delay || 2500;\n                                    const animationType = parsed.animation_type || \"clip\";\n                                    // Clear any existing interval for this headline\n                                    const headlineId = widgetEl.getAttribute(\"data-id\") || \"default\";\n                                    if (window[\"headlineInterval_\".concat(headlineId)]) {\n                                        clearInterval(window[\"headlineInterval_\".concat(headlineId)]);\n                                    }\n                                    let currentIndex = 0;\n                                    // Find initial active text and ensure all text spans are properly styled\n                                    let maxWidth = 0;\n                                    textSpans.forEach((span, idx)=>{\n                                        // Fix each text span to show full text\n                                        span.style.overflow = \"visible\";\n                                        span.style.whiteSpace = \"nowrap\";\n                                        span.style.width = \"auto\";\n                                        span.style.textOverflow = \"clip\";\n                                        const isActive = span.classList.contains(\"elementor-headline-text-active\");\n                                        if (isActive) {\n                                            // Active text should be visible and relative positioned\n                                            span.style.visibility = \"visible\";\n                                            span.style.opacity = \"1\";\n                                            span.style.display = \"block\";\n                                            span.style.position = \"relative\";\n                                            span.style.zIndex = \"2\";\n                                            currentIndex = idx;\n                                        } else {\n                                            // Inactive texts should be hidden and absolutely positioned\n                                            span.style.visibility = \"hidden\";\n                                            span.style.opacity = \"0\";\n                                            span.style.display = \"none\" // Hide completely to avoid duplication\n                                            ;\n                                            span.style.position = \"absolute\";\n                                            span.style.zIndex = \"0\";\n                                        }\n                                        // Temporarily make visible only to measure width\n                                        const originalVisibility = span.style.visibility;\n                                        const originalDisplay = span.style.display;\n                                        const originalPosition = span.style.position;\n                                        span.style.visibility = \"visible\";\n                                        span.style.opacity = \"1\";\n                                        span.style.display = \"block\";\n                                        span.style.position = \"relative\";\n                                        // Measure text width\n                                        const textWidth = span.offsetWidth || span.scrollWidth || 0;\n                                        if (textWidth > maxWidth) {\n                                            maxWidth = textWidth;\n                                        }\n                                        // Restore to original state\n                                        span.style.visibility = originalVisibility;\n                                        span.style.display = originalDisplay;\n                                        span.style.position = originalPosition;\n                                    });\n                                    // Set wrapper to fit the longest text\n                                    if (textWrapper && maxWidth > 0) {\n                                        textWrapper.style.width = \"auto\";\n                                        textWrapper.style.minWidth = \"\".concat(maxWidth, \"px\");\n                                    }\n                                    if (dynamicWrapper && maxWidth > 0) {\n                                        dynamicWrapper.style.width = \"auto\";\n                                        dynamicWrapper.style.minWidth = \"\".concat(maxWidth, \"px\");\n                                    }\n                                    // Function to rotate to next text\n                                    const rotateText = ()=>{\n                                        if (!loop && currentIndex >= textSpans.length - 1) {\n                                            return; // Stop if loop is disabled and reached end\n                                        }\n                                        // Remove active class from current and hide it\n                                        textSpans.forEach((span)=>{\n                                            span.classList.remove(\"elementor-headline-text-active\");\n                                            span.classList.add(\"elementor-headline-text-inactive\");\n                                            // Hide inactive text completely to prevent duplication\n                                            span.style.visibility = \"hidden\";\n                                            span.style.opacity = \"0\";\n                                            span.style.display = \"none\";\n                                            span.style.position = \"absolute\";\n                                            span.style.zIndex = \"0\";\n                                        });\n                                        // Move to next (with loop)\n                                        currentIndex = (currentIndex + 1) % textSpans.length;\n                                        // Add active class to new text and show it\n                                        const nextSpan = textSpans[currentIndex];\n                                        if (nextSpan) {\n                                            nextSpan.classList.remove(\"elementor-headline-text-inactive\");\n                                            nextSpan.classList.add(\"elementor-headline-text-active\");\n                                            // Show only the active text\n                                            nextSpan.style.visibility = \"visible\";\n                                            nextSpan.style.opacity = \"1\";\n                                            nextSpan.style.display = \"block\";\n                                            nextSpan.style.position = \"relative\";\n                                            nextSpan.style.zIndex = \"2\";\n                                            // Ensure wrapper expands to fit the new text\n                                            if (textWrapper) {\n                                                // Update wrapper width to fit the text\n                                                const textWidth = nextSpan.offsetWidth || nextSpan.scrollWidth;\n                                                if (textWidth > 0) {\n                                                    textWrapper.style.width = \"auto\";\n                                                    textWrapper.style.minWidth = \"\".concat(textWidth, \"px\");\n                                                }\n                                            }\n                                        }\n                                    };\n                                    // Start rotation if loop is enabled or if we have more than one text\n                                    if (loop || textSpans.length > 1) {\n                                        window[\"headlineInterval_\".concat(headlineId)] = setInterval(()=>{\n                                            rotateText();\n                                        }, iterationDelay);\n                                    }\n                                }\n                            }\n                        } catch (e) {\n                            console.warn(\"Failed to initialize animated headline:\", e);\n                            // Still ensure visibility even if parsing fails\n                            widgetEl === null || widgetEl === void 0 ? void 0 : widgetEl.classList.remove(\"elementor-invisible\");\n                            headlineEl.classList.remove(\"elementor-invisible\");\n                            headlineEl.style.visibility = \"visible\";\n                            headlineEl.style.opacity = \"1\";\n                        }\n                    }\n                });\n            }\n            // Remove elementor-invisible class from footer elements so they show immediately\n            if (containerRef.current) {\n                const footer = containerRef.current.querySelector(\"footer\");\n                if (footer) {\n                    // Remove invisible class from all footer elements\n                    footer.querySelectorAll(\".elementor-invisible\").forEach((el)=>{\n                        el.classList.remove(\"elementor-invisible\");\n                        // Also ensure visibility\n                        const htmlEl = el;\n                        if (htmlEl.style) {\n                            htmlEl.style.visibility = \"visible\";\n                            htmlEl.style.opacity = \"1\";\n                        }\n                    });\n                    // Also remove from footer sections\n                    footer.querySelectorAll('[class*=\"elementor-invisible\"]').forEach((el)=>{\n                        el.classList.remove(\"elementor-invisible\");\n                        const htmlEl = el;\n                        if (htmlEl.style) {\n                            htmlEl.style.visibility = \"visible\";\n                            htmlEl.style.opacity = \"1\";\n                        }\n                    });\n                }\n            }\n            // Handle missing images - add placeholders for all missing images\n            if (containerRef.current) {\n                // Fix hover box background images - ensure they load properly\n                containerRef.current.querySelectorAll(\".bdt-ep-hover-box-img\").forEach((img)=>{\n                    const imgEl = img;\n                    const style = imgEl.getAttribute(\"style\") || \"\";\n                    const bgMatch = style.match(/background-image:\\s*url\\(['\"]?([^'\")]+)['\"]?\\)/i);\n                    if (bgMatch && bgMatch[1]) {\n                        const bgUrl = bgMatch[1];\n                        // Fix URL if needed\n                        // IMPORTANT: Always convert rimalweb.net (any case) to alluredigital.net for asset filename lookup\n                        let fixedUrl = bgUrl;\n                        if (bgUrl && (/alluredigital\\.net/i.test(bgUrl) || /rimalweb\\.net/i.test(bgUrl))) {\n                            // ALWAYS convert rimalweb.net (any case) to alluredigital.net - asset files use alluredigital.net\n                            let urlToFix = bgUrl;\n                            if (/rimalweb\\.net/i.test(bgUrl)) {\n                                urlToFix = bgUrl.replace(/rimalweb\\.net/gi, \"alluredigital.net\");\n                            }\n                            fixedUrl = fixAssetUrl(urlToFix);\n                        }\n                        // Update style with fixed URL immediately\n                        if (fixedUrl !== bgUrl) {\n                            const newStyle = style.replace(bgUrl, fixedUrl);\n                            imgEl.setAttribute(\"style\", newStyle);\n                            imgEl.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                        } else {\n                            // Even if URL doesn't change, ensure background image is set\n                            imgEl.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                        }\n                        // Remove any existing gradient fallback first\n                        let currentStyle = imgEl.getAttribute(\"style\") || \"\";\n                        if (currentStyle.includes(\"linear-gradient\")) {\n                            // Remove gradient and keep only background-image\n                            currentStyle = currentStyle.replace(/background:\\s*linear-gradient[^;]+;/gi, \"\");\n                            currentStyle = currentStyle.replace(/background-color:\\s*[^;]+;/gi, \"\");\n                            imgEl.setAttribute(\"style\", currentStyle);\n                        }\n                        // Ensure visibility and proper sizing\n                        imgEl.style.opacity = \"1\";\n                        imgEl.style.visibility = \"visible\";\n                        imgEl.style.display = \"block\";\n                        imgEl.style.backgroundSize = \"cover\";\n                        imgEl.style.backgroundPosition = \"center\";\n                        imgEl.style.backgroundRepeat = \"no-repeat\";\n                        imgEl.style.width = \"100%\";\n                        imgEl.style.height = \"100%\";\n                        imgEl.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                        // Ensure parent content is visible if this is the first image\n                        const parentContent = imgEl.closest(\".bdt-ep-hover-box-content\");\n                        if (parentContent && parentContent.classList.contains(\"bdt-active\")) {\n                            parentContent.style.opacity = \"1\";\n                            parentContent.style.visibility = \"visible\";\n                            parentContent.style.display = \"block\";\n                            parentContent.style.zIndex = \"10\";\n                        }\n                        // Preload image to ensure it loads (don't set fallback gradient)\n                        const testImg = new Image();\n                        testImg.onload = function() {\n                            imgEl.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                            imgEl.style.opacity = \"1\";\n                            imgEl.style.visibility = \"visible\";\n                            imgEl.style.display = \"block\";\n                            // Ensure no gradient is applied\n                            currentStyle = imgEl.getAttribute(\"style\") || \"\";\n                            if (currentStyle.includes(\"linear-gradient\")) {\n                                currentStyle = currentStyle.replace(/background:\\s*linear-gradient[^;]+;/gi, \"\");\n                                currentStyle = currentStyle.replace(/background-color:\\s*[^;]+;/gi, \"\");\n                                imgEl.setAttribute(\"style\", currentStyle);\n                                imgEl.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                            }\n                        };\n                        testImg.onerror = function() {\n                            console.warn(\"Hover box image failed to load:\", fixedUrl);\n                            // Try alternative paths (without size suffix)\n                            const altUrl = fixedUrl.replace(/-\\d+x\\d+(\\.[a-z]+)$/i, \"$1\");\n                            if (altUrl !== fixedUrl) {\n                                const altTestImg = new Image();\n                                altTestImg.onload = function() {\n                                    imgEl.style.backgroundImage = \"url('\".concat(altUrl, \"')\");\n                                    imgEl.style.opacity = \"1\";\n                                    imgEl.style.visibility = \"visible\";\n                                };\n                                altTestImg.src = altUrl;\n                            }\n                        };\n                        testImg.src = fixedUrl;\n                    }\n                });\n                // Helper function to create a nice placeholder SVG\n                const createPlaceholderSvg = (width, height)=>{\n                    const w = typeof width === \"string\" ? parseInt(width) || 400 : width || 400;\n                    const h = typeof height === \"string\" ? parseInt(height) || 300 : height || 300;\n                    return 'data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(w, '\" height=\"').concat(h, '\"%3E%3Crect width=\"100%25\" height=\"100%25\" fill=\"%23f5f5f5\"/%3E%3Crect x=\"0\" y=\"0\" width=\"100%25\" height=\"100%25\" fill=\"url(%23gradient)\"/%3E%3Cdefs%3E%3ClinearGradient id=\"gradient\" x1=\"0%25\" y1=\"0%25\" x2=\"100%25\" y2=\"100%25\"%3E%3Cstop offset=\"0%25\" style=\"stop-color:%23f0f0f0;stop-opacity:1\" /%3E%3Cstop offset=\"100%25\" style=\"stop-color:%23e0e0e0;stop-opacity:1\" /%3E%3C/linearGradient%3E%3C/defs%3E%3Ctext x=\"50%25\" y=\"50%25\" text-anchor=\"middle\" dy=\".3em\" font-family=\"Arial, sans-serif\" font-size=\"16\" fill=\"%23999\"%3EImage%3C/text%3E%3C/svg%3E');\n                };\n                // Handle img tags - add error handlers for missing images\n                containerRef.current.querySelectorAll(\"img[src]\").forEach((img)=>{\n                    const imgElement = img;\n                    let src = imgElement.getAttribute(\"src\") || \"\";\n                    // Skip if already a placeholder\n                    if (src.includes(\"data:image/svg+xml\")) return;\n                    // IMPORTANT: Fix URL if it contains rimalweb.net (any case) - convert to alluredigital.net for asset lookup\n                    if (/rimalweb\\.net/i.test(src)) {\n                        const fixedSrc = fixAssetUrl(src);\n                        // Update the src attribute if it was changed\n                        if (fixedSrc !== src) {\n                            imgElement.setAttribute(\"src\", fixedSrc);\n                            src = fixedSrc;\n                        }\n                    }\n                    // Add error handler for missing images\n                    imgElement.onerror = function() {\n                        // Only replace if it's a local asset that failed\n                        if ((src.includes(\"/assets/\") || src.includes(\"alluredigital.net\") || /rimalweb\\.net/i.test(src)) && !src.includes(\"data:\")) {\n                            // Get original dimensions\n                            const width = imgElement.getAttribute(\"width\") || imgElement.offsetWidth || 400;\n                            const height = imgElement.getAttribute(\"height\") || imgElement.offsetHeight || 300;\n                            // Create placeholder SVG\n                            const placeholderSvg = createPlaceholderSvg(width, height);\n                            // Prevent infinite loop\n                            imgElement.onerror = null;\n                            imgElement.src = placeholderSvg;\n                            imgElement.style.objectFit = \"contain\";\n                            imgElement.style.backgroundColor = \"#f5f5f5\";\n                        }\n                    };\n                    // Pre-check image existence for local assets\n                    if ((src.includes(\"/assets/\") || src.includes(\"alluredigital.net\") || /rimalweb\\.net/i.test(src)) && !src.includes(\"data:\")) {\n                        const testImg = new Image();\n                        testImg.onerror = function() {\n                            const width = imgElement.getAttribute(\"width\") || imgElement.offsetWidth || 400;\n                            const height = imgElement.getAttribute(\"height\") || imgElement.offsetHeight || 300;\n                            const placeholderSvg = createPlaceholderSvg(width, height);\n                            imgElement.src = placeholderSvg;\n                            imgElement.style.objectFit = \"contain\";\n                            imgElement.style.backgroundColor = \"#f5f5f5\";\n                        };\n                        testImg.src = src;\n                    }\n                });\n                // Handle background images - add fallback for missing background images\n                containerRef.current.querySelectorAll('[style*=\"background-image\"], .bdt-scroll-image').forEach((el)=>{\n                    var _element_closest_querySelector_textContent, _element_closest_querySelector, _element_closest, _element_closest_querySelector_textContent1, _element_closest_querySelector1, _element_closest1, _element_closest_querySelector_textContent2, _element_closest_querySelector2, _element_closest2;\n                    const element = el;\n                    // Welcome section - use original scraped HTML, don't modify it\n                    const isWelcomeSection = ((_element_closest = element.closest(\"section, div\")) === null || _element_closest === void 0 ? void 0 : (_element_closest_querySelector = _element_closest.querySelector(\"h2, h1\")) === null || _element_closest_querySelector === void 0 ? void 0 : (_element_closest_querySelector_textContent = _element_closest_querySelector.textContent) === null || _element_closest_querySelector_textContent === void 0 ? void 0 : _element_closest_querySelector_textContent.includes(\"Welcome to\")) || ((_element_closest1 = element.closest(\"section, div\")) === null || _element_closest1 === void 0 ? void 0 : (_element_closest_querySelector1 = _element_closest1.querySelector(\"h2, h1\")) === null || _element_closest_querySelector1 === void 0 ? void 0 : (_element_closest_querySelector_textContent1 = _element_closest_querySelector1.textContent) === null || _element_closest_querySelector_textContent1 === void 0 ? void 0 : _element_closest_querySelector_textContent1.includes(\"Breaking Through\")) || ((_element_closest2 = element.closest(\"section, div\")) === null || _element_closest2 === void 0 ? void 0 : (_element_closest_querySelector2 = _element_closest2.querySelector(\"h2, h1\")) === null || _element_closest_querySelector2 === void 0 ? void 0 : (_element_closest_querySelector_textContent2 = _element_closest_querySelector2.textContent) === null || _element_closest_querySelector_textContent2 === void 0 ? void 0 : _element_closest_querySelector_textContent2.includes(\"Digital Impasse\"));\n                    // Skip modifying welcome section - use original scraped HTML\n                    if (isWelcomeSection && element.classList.contains(\"bdt-scroll-image\")) {\n                        // Just fix URL if needed, but don't replace the image\n                        const style = element.getAttribute(\"style\") || \"\";\n                        const bgMatch = style.match(/background-image:\\s*url\\(['\"]?([^'\")]+)['\"]?\\)/i);\n                        if (bgMatch && bgMatch[1]) {\n                            let bgUrl = bgMatch[1];\n                            // Fix URL if it contains rimalweb.net (any case) - convert to alluredigital.net for asset lookup\n                            if (/rimalweb\\.net/i.test(bgUrl)) {\n                                const fixedBgUrl = fixAssetUrl(bgUrl);\n                                if (fixedBgUrl !== bgUrl) {\n                                    element.style.backgroundImage = \"url('\".concat(fixedBgUrl, \"')\");\n                                    bgUrl = fixedBgUrl;\n                                }\n                            }\n                            // Preload image to ensure it loads\n                            if ((bgUrl.includes(\"/assets/\") || bgUrl.includes(\"alluredigital.net\") || /rimalweb\\.net/i.test(bgUrl)) && !bgUrl.includes(\"data:\")) {\n                                const testImg = new Image();\n                                testImg.onload = function() {\n                                    element.style.backgroundImage = \"url('\".concat(bgUrl, \"')\");\n                                };\n                                testImg.onerror = function() {\n                                    // Try without size suffix\n                                    const altUrl = bgUrl.replace(/-\\d+x\\d+/, \"\");\n                                    if (altUrl !== bgUrl) {\n                                        element.style.backgroundImage = \"url('\".concat(altUrl, \"')\");\n                                    }\n                                };\n                                testImg.src = bgUrl;\n                            }\n                        }\n                        return; // Skip the rest for this element\n                    }\n                    // For other background images, check if they exist\n                    // Skip hover box images - they are handled separately\n                    const isHoverBoxImage = element.classList.contains(\"bdt-ep-hover-box-img\") || element.closest(\".bdt-ep-hover-box\") !== null;\n                    if (isHoverBoxImage) {\n                        return; // Skip fallback for hover box images - they are handled above\n                    }\n                    const style = element.getAttribute(\"style\") || \"\";\n                    const bgMatch = style.match(/background-image:\\s*url\\(['\"]?([^'\")]+)['\"]?\\)/i);\n                    if (bgMatch && bgMatch[1]) {\n                        let bgUrl = bgMatch[1];\n                        // IMPORTANT: Fix URL if it contains rimalweb.net (any case) - convert to alluredigital.net for asset lookup\n                        if (/rimalweb\\.net/i.test(bgUrl)) {\n                            const fixedBgUrl = fixAssetUrl(bgUrl);\n                            // Update the style attribute if URL was changed\n                            if (fixedBgUrl !== bgUrl) {\n                                const updatedStyle = style.replace(/background-image:\\s*url\\(['\"]?[^'\")]+['\"]?\\)/i, \"background-image: url('\".concat(fixedBgUrl, \"')\"));\n                                element.setAttribute(\"style\", updatedStyle);\n                                bgUrl = fixedBgUrl;\n                            }\n                        }\n                        // Preload background image to check if it exists\n                        if ((bgUrl.includes(\"/assets/\") || bgUrl.includes(\"alluredigital.net\") || /rimalweb\\.net/i.test(bgUrl)) && !bgUrl.includes(\"data:\")) {\n                            const testImg = new Image();\n                            testImg.onerror = function() {\n                                // If image fails to load, set a fallback gradient background\n                                // BUT NOT for hover box images\n                                const currentStyle = element.getAttribute(\"style\") || \"\";\n                                const fallbackStyle = currentStyle.replace(/background-image:\\s*url\\([^)]+\\)/gi, \"background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #f5f5f5 100%); background-color: #f5f5f5\");\n                                element.setAttribute(\"style\", fallbackStyle);\n                            };\n                            testImg.src = bgUrl;\n                        }\n                    }\n                });\n                // Also handle data-settings background slideshow images - ALLOW ORIGINAL SLIDESHOW\n                // Find homepage hero section and ensure slideshow images load properly\n                const homepageHeroSection = containerRef.current.querySelector('[data-settings*=\"background_slideshow_gallery\"]');\n                if (homepageHeroSection) {\n                    const heroEl = homepageHeroSection;\n                    // Ensure slideshow is visible and working\n                    const slideshow = heroEl.querySelector(\".elementor-background-slideshow\");\n                    if (slideshow) {\n                        // Keep slideshow visible - don't remove it\n                        const slideshowEl = slideshow;\n                        slideshowEl.style.display = \"block\";\n                        slideshowEl.style.visibility = \"visible\";\n                        slideshowEl.style.opacity = \"1\";\n                        // Try to enable loop on existing Swiper instance\n                        setTimeout(()=>{\n                            const swiperInstance = slideshowEl === null || slideshowEl === void 0 ? void 0 : slideshowEl.swiper;\n                            if (swiperInstance) {\n                                // ALWAYS enable loop for images (force loop) - destroy and recreate if needed\n                                if (!swiperInstance.params.loop || swiperInstance.params.loop === false) {\n                                    // Destroy existing loop if any\n                                    if (swiperInstance.loopDestroy) {\n                                        swiperInstance.loopDestroy();\n                                    }\n                                    // Force enable loop\n                                    swiperInstance.params.loop = true;\n                                    swiperInstance.params.loopedSlides = undefined // Let Swiper calculate automatically\n                                    ;\n                                    swiperInstance.params.loopAdditionalSlides = 2;\n                                    // Create loop\n                                    if (swiperInstance.loopCreate) {\n                                        swiperInstance.loopCreate();\n                                    }\n                                    // Update to apply changes\n                                    swiperInstance.update();\n                                    swiperInstance.updateSlides();\n                                    swiperInstance.updateSlidesClasses();\n                                } else {\n                                    // Even if loop is already enabled, ensure it's working properly\n                                    swiperInstance.params.loop = true;\n                                    if (swiperInstance.loopCreate) {\n                                        swiperInstance.loopCreate();\n                                    }\n                                    swiperInstance.update();\n                                    swiperInstance.updateSlides();\n                                    swiperInstance.updateSlidesClasses();\n                                }\n                                // Set speed/transition to 0 for instant transition (no gap)\n                                swiperInstance.params.speed = 0;\n                                // Ensure autoplay is running with seamless loop (no gap)\n                                if (swiperInstance.params.autoplay) {\n                                    swiperInstance.params.autoplay.disableOnInteraction = false;\n                                    swiperInstance.params.autoplay.pauseOnMouseEnter = false;\n                                    swiperInstance.params.autoplay.waitForTransition = false // Don't wait for transition\n                                    ;\n                                }\n                                // Ensure slideshow is visible\n                                slideshowEl.style.display = \"block\";\n                                slideshowEl.style.visibility = \"visible\";\n                                slideshowEl.style.opacity = \"1\";\n                                // Ensure autoplay is running and will continue\n                                if (!swiperInstance.params.autoplay) {\n                                    swiperInstance.params.autoplay = {\n                                        delay: 5500,\n                                        disableOnInteraction: false,\n                                        pauseOnMouseEnter: false,\n                                        waitForTransition: false,\n                                        stopOnLastSlide: false,\n                                        reverseDirection: false\n                                    };\n                                } else {\n                                    swiperInstance.params.autoplay.disableOnInteraction = false;\n                                    swiperInstance.params.autoplay.pauseOnMouseEnter = false;\n                                    swiperInstance.params.autoplay.waitForTransition = false;\n                                    swiperInstance.params.autoplay.stopOnLastSlide = false // Don't stop on last slide\n                                    ;\n                                }\n                                if (!swiperInstance.autoplay || !swiperInstance.autoplay.running) {\n                                    if (swiperInstance.autoplay) {\n                                        swiperInstance.autoplay.start();\n                                    }\n                                } else {\n                                    // Restart autoplay to ensure seamless loop\n                                    swiperInstance.autoplay.stop();\n                                    setTimeout(()=>{\n                                        swiperInstance.autoplay.start();\n                                    }, 100);\n                                }\n                                // Force update to apply all changes\n                                swiperInstance.update();\n                                swiperInstance.updateSlides();\n                                swiperInstance.updateSlidesClasses();\n                                // Monitor and restart autoplay if it stops\n                                const checkAutoplay = setInterval(()=>{\n                                    if (swiperInstance && swiperInstance.autoplay && !swiperInstance.autoplay.running) {\n                                        swiperInstance.autoplay.start();\n                                    }\n                                    // Ensure slideshow is still visible\n                                    slideshowEl.style.display = \"block\";\n                                    slideshowEl.style.visibility = \"visible\";\n                                    slideshowEl.style.opacity = \"1\";\n                                }, 1000);\n                                // Store interval reference for cleanup\n                                const heroSlideshowId = heroEl.getAttribute(\"data-id\") || \"hero-default\";\n                                window[\"autoplayMonitor_\".concat(heroSlideshowId)] = checkAutoplay;\n                            }\n                        }, 1000);\n                    }\n                    // Ensure hero section has proper height\n                    heroEl.style.setProperty(\"min-height\", \"500px\", \"important\");\n                }\n                containerRef.current.querySelectorAll(\"[data-settings]\").forEach((el)=>{\n                    const settings = el.getAttribute(\"data-settings\");\n                    if (settings && (settings.includes(\"background_slideshow_gallery\") || settings.includes(\"background_image\"))) {\n                        try {\n                            // Decode HTML entities properly\n                            const decoded = settings.replace(/&amp;/g, \"&\") // Must decode &amp; first\n                            .replace(/&quot;/g, '\"').replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&#39;/g, \"'\");\n                            const parsed = JSON.parse(decoded);\n                            // Handle hero section background images - ensure they display properly\n                            const element = el;\n                            // Handle classic background images\n                            if (parsed.background_background === \"classic\" && parsed.background_image && parsed.background_image.url) {\n                                const bgUrl = fixAssetUrl(parsed.background_image.url);\n                                // Force background image to display immediately\n                                element.style.backgroundImage = \"url('\".concat(bgUrl, \"')\");\n                                element.style.backgroundSize = \"cover\";\n                                element.style.backgroundPosition = \"center\";\n                                element.style.backgroundRepeat = \"no-repeat\";\n                                element.style.minHeight = \"500px\" // Ensure section has height\n                                ;\n                                // Preload and verify image loads\n                                const testImg = new Image();\n                                testImg.onload = function() {\n                                    element.style.backgroundImage = \"url('\".concat(bgUrl, \"')\");\n                                    element.style.opacity = \"1\";\n                                };\n                                testImg.onerror = function() {\n                                    console.warn(\"Background image failed to load:\", bgUrl);\n                                    // Try alternative image paths\n                                    const altUrl = bgUrl.replace(/-\\d+x\\d+/, \"\") // Remove size suffix\n                                    ;\n                                    if (altUrl !== bgUrl) {\n                                        element.style.backgroundImage = \"url('\".concat(altUrl, \"')\");\n                                    }\n                                };\n                                testImg.src = bgUrl;\n                            }\n                            // Handle slideshow background images - ALLOW ORIGINAL SLIDESHOW TO WORK\n                            if (parsed.background_background === \"slideshow\" && parsed.background_slideshow_gallery && Array.isArray(parsed.background_slideshow_gallery) && parsed.background_slideshow_gallery.length > 0) {\n                                // Ensure slideshow element is visible\n                                const slideshowEl = element.querySelector(\".elementor-background-slideshow\");\n                                if (slideshowEl) {\n                                    slideshowEl.style.display = \"block\";\n                                    slideshowEl.style.visibility = \"visible\";\n                                    slideshowEl.style.opacity = \"1\";\n                                }\n                                // Ensure section has proper height\n                                element.style.minHeight = \"500px\";\n                                // Initialize or reinitialize Swiper with loop and autoplay\n                                const slideDuration = parsed.background_slideshow_slide_duration || 5500;\n                                // Set transition duration to 0 for no time gap between slides\n                                const transitionDuration = 0;\n                                // Always enable loop for images\n                                const shouldLoop = true;\n                                // Use setTimeout to ensure Swiper is initialized after DOM is ready\n                                setTimeout(()=>{\n                                    // Check if Swiper is already initialized on this element\n                                    const swiperElement = slideshowEl;\n                                    // If Swiper exists, update its settings\n                                    if (swiperElement && swiperElement.swiper) {\n                                        const swiper = swiperElement.swiper;\n                                        // ALWAYS enable loop for images (force loop) - destroy and recreate if needed\n                                        if (!swiper.params.loop || swiper.params.loop === false) {\n                                            // Destroy existing loop if any\n                                            if (swiper.loopDestroy) {\n                                                swiper.loopDestroy();\n                                            }\n                                            // Force enable loop\n                                            swiper.params.loop = true;\n                                            swiper.params.loopedSlides = undefined // Let Swiper calculate automatically\n                                            ;\n                                            swiper.params.loopAdditionalSlides = 2;\n                                            // Create loop\n                                            if (swiper.loopCreate) {\n                                                swiper.loopCreate();\n                                            }\n                                            // Update to apply changes\n                                            swiper.update();\n                                            swiper.updateSlides();\n                                            swiper.updateSlidesClasses();\n                                        } else {\n                                            // Even if loop is already enabled, ensure it's working properly\n                                            swiper.params.loop = true;\n                                            if (swiper.loopCreate) {\n                                                swiper.loopCreate();\n                                            }\n                                            swiper.update();\n                                            swiper.updateSlides();\n                                            swiper.updateSlidesClasses();\n                                        }\n                                        // Set speed/transition to 0 for instant transition (no gap)\n                                        swiper.params.speed = 0;\n                                        swiper.params.slideToClickedSlide = false;\n                                        // Ensure slideshow is visible\n                                        if (slideshowEl) {\n                                            slideshowEl.style.display = \"block\";\n                                            slideshowEl.style.visibility = \"visible\";\n                                            slideshowEl.style.opacity = \"1\";\n                                        }\n                                        // Enable autoplay with seamless loop (no gap between cycles) - ensure it never stops\n                                        if (!swiper.params.autoplay) {\n                                            swiper.params.autoplay = {\n                                                delay: slideDuration,\n                                                disableOnInteraction: false,\n                                                pauseOnMouseEnter: false,\n                                                waitForTransition: false,\n                                                stopOnLastSlide: false,\n                                                reverseDirection: false\n                                            };\n                                        } else {\n                                            // Update existing autoplay settings - ensure it never stops\n                                            swiper.params.autoplay.delay = slideDuration;\n                                            swiper.params.autoplay.disableOnInteraction = false;\n                                            swiper.params.autoplay.pauseOnMouseEnter = false;\n                                            swiper.params.autoplay.waitForTransition = false;\n                                            swiper.params.autoplay.stopOnLastSlide = false // Don't stop on last slide - critical for continuous loop\n                                            ;\n                                        }\n                                        // Start autoplay if not running\n                                        if (!swiper.autoplay.running) {\n                                            swiper.autoplay.start();\n                                        } else {\n                                            // Restart autoplay to apply new settings\n                                            swiper.autoplay.stop();\n                                            setTimeout(()=>{\n                                                swiper.autoplay.start();\n                                            }, 100);\n                                        }\n                                        // Force update to apply all changes\n                                        swiper.update();\n                                        swiper.updateSlides();\n                                        swiper.updateSlidesClasses();\n                                        // Monitor and restart autoplay if it stops\n                                        const checkAutoplay = setInterval(()=>{\n                                            if (swiper && swiper.autoplay && !swiper.autoplay.running) {\n                                                swiper.autoplay.start();\n                                            }\n                                            // Ensure slideshow is still visible\n                                            if (slideshowEl) {\n                                                slideshowEl.style.display = \"block\";\n                                                slideshowEl.style.visibility = \"visible\";\n                                                slideshowEl.style.opacity = \"1\";\n                                            }\n                                        }, 1000);\n                                        // Store interval reference for cleanup\n                                        const slideshowId = element.getAttribute(\"data-id\") || \"default\";\n                                        window[\"autoplayMonitor_\".concat(slideshowId)] = checkAutoplay;\n                                    } else {\n                                        // Manual slideshow rotation if Swiper is not available\n                                        const slides = element.querySelectorAll(\".elementor-background-slideshow__slide:not(.swiper-slide-duplicate)\");\n                                        // Get only actual slides (not duplicates)\n                                        const actualSlides = [];\n                                        slides.forEach((slide)=>{\n                                            if (!slide.classList.contains(\"swiper-slide-duplicate\")) {\n                                                actualSlides.push(slide);\n                                            }\n                                        });\n                                        if (actualSlides.length > 1) {\n                                            let currentSlideIndex = 0;\n                                            const showSlide = (index)=>{\n                                                const actualIndex = index % actualSlides.length;\n                                                actualSlides.forEach((slide, idx)=>{\n                                                    if (idx === actualIndex) {\n                                                        // No transition for instant change (0ms gap)\n                                                        slide.style.transition = \"opacity 0ms ease\";\n                                                        slide.style.opacity = \"1\";\n                                                        slide.style.visibility = \"visible\";\n                                                        slide.style.zIndex = \"2\";\n                                                        slide.style.display = \"block\";\n                                                    } else {\n                                                        // No transition for instant change (0ms gap)\n                                                        slide.style.transition = \"opacity 0ms ease\";\n                                                        slide.style.opacity = \"0\";\n                                                        slide.style.visibility = \"hidden\";\n                                                        slide.style.zIndex = \"0\";\n                                                        slide.style.display = \"block\";\n                                                    }\n                                                });\n                                            };\n                                            // Show first slide\n                                            showSlide(0);\n                                            // Always enable loop for images - FIXED: Use proper transition duration\n                                            const transitionDurationActual = parsed.background_slideshow_transition_duration || 1800;\n                                            // Update showSlide function to use proper transition for smooth fade\n                                            const showSlideWithTransition = (index)=>{\n                                                const actualIndex = index % actualSlides.length;\n                                                actualSlides.forEach((slide, idx)=>{\n                                                    if (idx === actualIndex) {\n                                                        slide.style.transition = \"opacity \".concat(transitionDurationActual, \"ms ease\");\n                                                        slide.style.opacity = \"1\";\n                                                        slide.style.visibility = \"visible\";\n                                                        slide.style.zIndex = \"2\";\n                                                        slide.style.display = \"block\";\n                                                    } else {\n                                                        slide.style.transition = \"opacity \".concat(transitionDurationActual, \"ms ease\");\n                                                        slide.style.opacity = \"0\";\n                                                        slide.style.visibility = \"hidden\";\n                                                        slide.style.zIndex = \"0\";\n                                                        slide.style.display = \"block\";\n                                                    }\n                                                });\n                                            };\n                                            // Clear any existing interval for this slideshow\n                                            const slideshowId = element.getAttribute(\"data-id\") || \"default\";\n                                            if (window[\"slideshowInterval_\".concat(slideshowId)]) {\n                                                clearInterval(window[\"slideshowInterval_\".concat(slideshowId)]);\n                                            }\n                                            // Start new interval with proper loop - ensure continuous rotation\n                                            if (typeof console !== \"undefined\" && console.log) {\n                                                console.log(\"Starting hero slideshow loop: \".concat(actualSlides.length, \" slides, \").concat(slideDuration, \"ms delay, \").concat(transitionDurationActual, \"ms transition\"));\n                                            }\n                                            window[\"slideshowInterval_\".concat(slideshowId)] = setInterval(()=>{\n                                                currentSlideIndex = (currentSlideIndex + 1) % actualSlides.length;\n                                                showSlideWithTransition(currentSlideIndex);\n                                            }, slideDuration) // Use slideDuration - loop will continue indefinitely\n                                            ;\n                                            if (typeof console !== \"undefined\" && console.log) {\n                                                console.log(\"Hero slideshow manual rotation ACTIVE - will loop continuously\");\n                                            }\n                                        } else {\n                                            console.warn(\"Hero slideshow: Not enough slides found for loop\", actualSlides.length);\n                                        }\n                                    }\n                                }, 1500) // Increased timeout to ensure DOM is ready and Swiper initialized\n                                ;\n                                // Preload all slideshow images to ensure they load properly\n                                parsed.background_slideshow_gallery.forEach((item, index)=>{\n                                    if (item && item.url) {\n                                        const imageUrl = fixAssetUrl(item.url);\n                                        // Preload image\n                                        const testImg = new Image();\n                                        testImg.onload = function() {\n                                            // Image loaded successfully\n                                            // Update slideshow slide images directly\n                                            const slides = element.querySelectorAll(\".elementor-background-slideshow__slide__image\");\n                                            slides.forEach((slide, slideIndex)=>{\n                                                const slideEl = slide;\n                                                const slideStyle = slideEl.getAttribute(\"style\") || \"\";\n                                                // If this slide contains this image URL, ensure it's fixed\n                                                if (slideStyle.includes(imageUrl) || slideStyle.includes(item.url)) {\n                                                    // Fix URL in slide if needed\n                                                    if (slideStyle.includes(item.url) && !slideStyle.includes(imageUrl)) {\n                                                        slideEl.style.backgroundImage = \"url('\".concat(imageUrl, \"')\");\n                                                    }\n                                                }\n                                            });\n                                        };\n                                        testImg.onerror = function() {\n                                            console.warn(\"Slideshow image failed to load:\", imageUrl);\n                                            // Try alternative path without size suffix\n                                            const altUrl = imageUrl.replace(/-\\d+x\\d+/, \"\");\n                                            if (altUrl !== imageUrl) {\n                                                testImg.src = altUrl;\n                                            }\n                                        };\n                                        testImg.src = imageUrl;\n                                    }\n                                });\n                            }\n                        } catch (e) {\n                            console.warn(\"Failed to parse data-settings for background:\", e);\n                        }\n                    }\n                });\n                // Fix slideshow slide images directly (they have inline styles)\n                // Don't hide duplicate slides - they are needed for loop to work\n                containerRef.current.querySelectorAll(\".elementor-background-slideshow__slide, .swiper-slide\").forEach((slide)=>{\n                    const slideEl = slide;\n                    // Only show active/visible slides - hide all others\n                    // Keep duplicate slides visible (with opacity 0) for loop to work\n                    if (slideEl.classList.contains(\"swiper-slide-active\") || slideEl.classList.contains(\"swiper-slide-visible\")) {\n                        slideEl.style.opacity = \"1\";\n                        slideEl.style.visibility = \"visible\";\n                        slideEl.style.zIndex = \"1\";\n                        slideEl.style.display = \"block\";\n                    } else if (slideEl.classList.contains(\"swiper-slide-duplicate\")) {\n                        // Keep duplicate slides but hidden - needed for seamless loop\n                        slideEl.style.opacity = \"0\";\n                        slideEl.style.visibility = \"hidden\";\n                        slideEl.style.display = \"block\" // Keep display: block for loop\n                        ;\n                    } else {\n                        // Hide inactive slides\n                        slideEl.style.opacity = \"0\";\n                        slideEl.style.visibility = \"hidden\";\n                        slideEl.style.display = \"block\" // Keep display: block\n                        ;\n                    }\n                    // Fix image URL in slide\n                    const slideImage = slideEl.querySelector(\".elementor-background-slideshow__slide__image\");\n                    if (slideImage) {\n                        const bgImage = slideImage.style.backgroundImage || slideImage.getAttribute(\"style\") || \"\";\n                        if (bgImage && bgImage.includes(\"alluredigital.net\")) {\n                            // Extract URL from style\n                            const urlMatch = bgImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n                            if (urlMatch && urlMatch[1]) {\n                                const fixedUrl = fixAssetUrl(urlMatch[1]);\n                                slideImage.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                                slideImage.style.backgroundSize = \"cover\";\n                                slideImage.style.backgroundPosition = \"center\";\n                                // Preload image\n                                const testImg = new Image();\n                                testImg.onload = function() {\n                                    slideImage.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                                };\n                                testImg.onerror = function() {\n                                    // Try without size suffix\n                                    const altUrl = fixedUrl.replace(/-\\d+x\\d+/, \"\");\n                                    if (altUrl !== fixedUrl) {\n                                        slideImage.style.backgroundImage = \"url('\".concat(altUrl, \"')\");\n                                    }\n                                };\n                                testImg.src = fixedUrl;\n                            }\n                        }\n                    }\n                });\n                // Also check for hero section by class/id and force background images\n                containerRef.current.querySelectorAll(\".elementor-section, section\").forEach((section)=>{\n                    const sectionEl = section;\n                    const computedStyle = window.getComputedStyle(sectionEl);\n                    const bgImage = computedStyle.backgroundImage;\n                    // If section has a background image URL that needs fixing\n                    if (bgImage && bgImage !== \"none\" && bgImage.includes(\"alluredigital.net\")) {\n                        const urlMatch = bgImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n                        if (urlMatch && urlMatch[1]) {\n                            const fixedUrl = fixAssetUrl(urlMatch[1]);\n                            sectionEl.style.backgroundImage = \"url('\".concat(fixedUrl, \"')\");\n                            sectionEl.style.backgroundSize = \"cover\";\n                            sectionEl.style.backgroundPosition = \"center\";\n                        }\n                    }\n                });\n            }\n            // Now load scripts AFTER body is set (preserve order)\n            const allScripts = doc.querySelectorAll(\"script\");\n            const scriptPromises = [];\n            allScripts.forEach((script)=>{\n                if (script.src) {\n                    const src = script.getAttribute(\"src\") || \"\";\n                    const scriptId = src;\n                    // Skip external APIs - only load local assets\n                    if (src.includes(\"maps.googleapis.com\") || src.includes(\"googleapis.com\") || src.includes(\"gstatic.com\") || src.includes(\"googletagmanager.com\") || src.includes(\"google-analytics.com\") || src.includes(\"facebook.net\") || src.includes(\"clarity.ms\") || src.includes(\"cleantalk.org\") || src.includes(\"pearldiver.io\") || src.includes(\"usbrowserspeed.com\") || src.includes(\"recaptcha\")) {\n                        // Skip external APIs\n                        return;\n                    }\n                    if (!scriptsLoadedRef.current.has(scriptId)) {\n                        const newScript = document.createElement(\"script\");\n                        // Only load local assets\n                        if (src.includes(\"alluredigital.net\") || src.startsWith(\"http\")) {\n                            const filename = getAssetFilename(src);\n                            if (filename) {\n                                newScript.src = \"/assets/\".concat(filename);\n                            } else {\n                                // Skip if can't find local asset\n                                return;\n                            }\n                        } else {\n                            newScript.src = src;\n                        }\n                        // Copy ALL attributes\n                        Array.from(script.attributes).forEach((attr)=>{\n                            if (attr.name !== \"src\") {\n                                newScript.setAttribute(attr.name, attr.value);\n                            }\n                        });\n                        // Handle async/defer\n                        if (script.hasAttribute(\"async\")) newScript.async = true;\n                        if (script.hasAttribute(\"defer\")) newScript.defer = true;\n                        const loadPromise = new Promise((resolve)=>{\n                            newScript.onload = ()=>resolve();\n                            newScript.onerror = ()=>resolve() // Continue even if script fails\n                            ;\n                            document.head.appendChild(newScript);\n                        });\n                        scriptPromises.push(loadPromise);\n                        scriptsLoadedRef.current.add(scriptId);\n                    }\n                } else if (script.textContent) {\n                    // Skip inline scripts that reference external APIs\n                    const scriptText = script.textContent;\n                    if (scriptText.includes(\"gtag\") || scriptText.includes(\"fbq\") || scriptText.includes(\"clarity\") || scriptText.includes(\"dataLayer\") || scriptText.includes(\"google\") || scriptText.includes(\"maps\") || scriptText.includes(\"recaptcha\")) {\n                        // Skip analytics/tracking scripts\n                        return;\n                    }\n                    // Inline scripts - execute after DOM is ready\n                    const scriptId = scriptText.substring(0, 50);\n                    if (!scriptsLoadedRef.current.has(scriptId)) {\n                        const newScript = document.createElement(\"script\");\n                        newScript.textContent = scriptText;\n                        // Copy attributes\n                        Array.from(script.attributes).forEach((attr)=>{\n                            newScript.setAttribute(attr.name, attr.value);\n                        });\n                        document.head.appendChild(newScript);\n                        scriptsLoadedRef.current.add(scriptId);\n                    }\n                }\n            });\n            // Wait for CSS to load first (critical), then scripts, then show content\n            // CSS must be fully loaded before showing content to prevent broken layout\n            if (stylePromises.length > 0) {\n                // Wait for ALL CSS to load first\n                Promise.all(stylePromises).then(()=>{\n                    // Force a reflow to ensure CSS is applied\n                    if (containerRef.current) {\n                        containerRef.current.offsetHeight // Trigger reflow\n                        ;\n                    }\n                    // Wait for CSS to be fully applied to DOM\n                    requestAnimationFrame(()=>{\n                        requestAnimationFrame(()=>{\n                            // Now load scripts in background (non-blocking)\n                            if (scriptPromises.length > 0) {\n                                Promise.all(scriptPromises).then(()=>{\n                                    // Trigger DOMContentLoaded for scripts that depend on it\n                                    if (document.readyState === \"loading\") {\n                                        document.dispatchEvent(new Event(\"DOMContentLoaded\"));\n                                    }\n                                    // Trigger jQuery ready if jQuery is loaded\n                                    if ( true && window.jQuery) {\n                                        window.jQuery(document).ready(()=>{\n                                            // Elementor and other scripts will initialize\n                                            // Initialize BDT Offcanvas menu if available\n                                            if (window.UIkit) {\n                                                // UIkit is loaded, offcanvas should work automatically\n                                                // But ensure it's properly initialized\n                                                setTimeout(()=>{\n                                                    if (containerRef.current) {\n                                                        const offcanvasButtons = containerRef.current.querySelectorAll('[data-bdt-toggle=\"target\"]');\n                                                        offcanvasButtons.forEach((btn)=>{\n                                                            // Ensure click handler works\n                                                            btn.addEventListener(\"click\", (e)=>{\n                                                                var _btn_getAttribute;\n                                                                e.preventDefault();\n                                                                const targetId = (_btn_getAttribute = btn.getAttribute(\"data-bdt-toggle\")) === null || _btn_getAttribute === void 0 ? void 0 : _btn_getAttribute.replace(\"target: \", \"\");\n                                                                if (targetId) {\n                                                                    const target = document.querySelector(targetId);\n                                                                    if (target && window.UIkit) {\n                                                                        const offcanvas = window.UIkit.offcanvas(target);\n                                                                        if (offcanvas) {\n                                                                            offcanvas.show();\n                                                                        }\n                                                                    }\n                                                                }\n                                                            });\n                                                        });\n                                                    }\n                                                }, 500);\n                                            }\n                                        });\n                                    }\n                                    // Also initialize offcanvas after a delay to ensure scripts are loaded\n                                    setTimeout(()=>{\n                                        if (containerRef.current) {\n                                            // Hide offcanvas menu by default - only show when button is clicked\n                                            const offcanvasMenus = containerRef.current.querySelectorAll(\".bdt-offcanvas\");\n                                            offcanvasMenus.forEach((menu)=>{\n                                                const menuEl = menu;\n                                                // Hide menu by default to prevent white screen\n                                                menuEl.style.display = \"none\";\n                                                menuEl.style.visibility = \"hidden\";\n                                                menuEl.style.opacity = \"0\";\n                                                menuEl.classList.remove(\"bdt-open\");\n                                            });\n                                            // Fix offcanvas button click handlers\n                                            const offcanvasButtons = containerRef.current.querySelectorAll('.bdt-offcanvas-button, [data-bdt-toggle*=\"offcanvas\"]');\n                                            offcanvasButtons.forEach((btn)=>{\n                                                btn.addEventListener(\"click\", function(e) {\n                                                    e.preventDefault();\n                                                    e.stopPropagation();\n                                                    const targetAttr = this.getAttribute(\"data-bdt-toggle\");\n                                                    if (targetAttr) {\n                                                        const targetId = targetAttr.replace(\"target: \", \"\").trim();\n                                                        const target = document.querySelector(targetId);\n                                                        if (target) {\n                                                            // Toggle offcanvas\n                                                            if (window.UIkit) {\n                                                                const offcanvas = window.UIkit.offcanvas(target);\n                                                                if (offcanvas) {\n                                                                    offcanvas.toggle();\n                                                                }\n                                                            } else {\n                                                                // Fallback: manually toggle\n                                                                const isOpen = target.classList.contains(\"bdt-open\");\n                                                                if (isOpen) {\n                                                                    // Close menu\n                                                                    target.classList.remove(\"bdt-open\");\n                                                                    target.style.display = \"none\";\n                                                                    target.style.visibility = \"hidden\";\n                                                                    target.style.opacity = \"0\";\n                                                                    document.body.classList.remove(\"bdt-offcanvas-page\");\n                                                                } else {\n                                                                    // Open menu\n                                                                    target.classList.add(\"bdt-open\");\n                                                                    target.style.display = \"block\";\n                                                                    target.style.visibility = \"visible\";\n                                                                    target.style.opacity = \"1\";\n                                                                    document.body.classList.add(\"bdt-offcanvas-page\");\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                });\n                                            });\n                                            // Fix offcanvas close button handlers\n                                            const closeButtons = containerRef.current.querySelectorAll(\".bdt-offcanvas-close, [data-bdt-close]\");\n                                            closeButtons.forEach((btn)=>{\n                                                btn.addEventListener(\"click\", function(e) {\n                                                    e.preventDefault();\n                                                    e.stopPropagation();\n                                                    const offcanvas = this.closest(\".bdt-offcanvas\");\n                                                    if (offcanvas) {\n                                                        const menuEl = offcanvas;\n                                                        menuEl.classList.remove(\"bdt-open\");\n                                                        menuEl.style.display = \"none\";\n                                                        menuEl.style.visibility = \"hidden\";\n                                                        menuEl.style.opacity = \"0\";\n                                                        document.body.classList.remove(\"bdt-offcanvas-page\");\n                                                    }\n                                                });\n                                            });\n                                        }\n                                    }, 1000);\n                                }).catch(()=>{\n                                // Scripts failed but continue\n                                });\n                            }\n                            // Show content after CSS is loaded and applied\n                            setTimeout(()=>{\n                                setIsLoading(false);\n                            }, 150);\n                        });\n                    });\n                }).catch(()=>{\n                    // Even if CSS fails, wait a bit then show content\n                    setTimeout(()=>{\n                        setIsLoading(false);\n                    }, 300);\n                });\n            } else if (scriptPromises.length > 0) {\n                // No CSS but has scripts\n                Promise.all(scriptPromises).then(()=>{\n                    setTimeout(()=>{\n                        setIsLoading(false);\n                    }, 100);\n                }).catch(()=>{\n                    setTimeout(()=>{\n                        setIsLoading(false);\n                    }, 200);\n                });\n            } else {\n                // No assets to load, wait a bit for initial render\n                setTimeout(()=>{\n                    setIsLoading(false);\n                }, 200);\n            }\n        }\n        // Cleanup function for useEffect\n        return ()=>{\n            if (cleanupRef.current) {\n                cleanupRef.current();\n                cleanupRef.current = null;\n            }\n        };\n    }, [\n        html\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            isLoading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"fixed\",\n                    top: 0,\n                    left: 0,\n                    width: \"100%\",\n                    height: \"100%\",\n                    background: \"linear-gradient(135deg, #667eea 0%, #764ba2 100%)\",\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    alignItems: \"center\",\n                    justifyContent: \"center\",\n                    zIndex: 9999,\n                    fontFamily: \"system-ui, -apple-system, sans-serif\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            width: \"80px\",\n                            height: \"80px\",\n                            border: \"5px solid rgba(255, 255, 255, 0.3)\",\n                            borderTop: \"5px solid #ffffff\",\n                            borderRadius: \"50%\",\n                            animation: \"spin 1s linear infinite\",\n                            marginBottom: \"30px\",\n                            boxShadow: \"0 4px 20px rgba(0, 0, 0, 0.2)\"\n                        }\n                    }, void 0, false, {\n                        fileName: \"D:\\\\usman\\\\src\\\\components\\\\PageRenderer.tsx\",\n                        lineNumber: 3372,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            color: \"#ffffff\",\n                            fontSize: \"24px\",\n                            fontWeight: 600,\n                            marginBottom: \"10px\",\n                            textShadow: \"0 2px 10px rgba(0, 0, 0, 0.2)\"\n                        },\n                        children: \"Rimalweb\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\usman\\\\src\\\\components\\\\PageRenderer.tsx\",\n                        lineNumber: 3382,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            color: \"rgba(255, 255, 255, 0.9)\",\n                            fontSize: \"16px\",\n                            fontWeight: 400\n                        },\n                        children: \"Loading...\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\usman\\\\src\\\\components\\\\PageRenderer.tsx\",\n                        lineNumber: 3391,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"style\", {\n                        children: \"\\n            @keyframes spin {\\n              0% { transform: rotate(0deg); }\\n              100% { transform: rotate(360deg); }\\n            }\\n          \"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\usman\\\\src\\\\components\\\\PageRenderer.tsx\",\n                        lineNumber: 3398,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\usman\\\\src\\\\components\\\\PageRenderer.tsx\",\n                lineNumber: 3358,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: containerRef,\n                style: {\n                    opacity: isLoading ? 0 : 1,\n                    transition: \"opacity 0.3s ease-in-out\"\n                }\n            }, void 0, false, {\n                fileName: \"D:\\\\usman\\\\src\\\\components\\\\PageRenderer.tsx\",\n                lineNumber: 3406,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(PageRenderer, \"6Av/s/8xB919jbgmNGEJjz42xyo=\");\n_c = PageRenderer;\nvar _c;\n$RefreshReg$(_c, \"PageRenderer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1BhZ2VSZW5kZXJlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRW1EO0FBTW5ELDZEQUE2RDtBQUM3RCxnR0FBZ0c7QUFDaEcsU0FBU0csaUJBQWlCQyxHQUFXO0lBQ25DLElBQUk7UUFDRiw2RkFBNkY7UUFDN0YsSUFBSUMsZUFBZUQ7UUFDbkIsSUFBSUEsT0FBUUEsQ0FBQUEsSUFBSUUsUUFBUSxDQUFDLG1CQUFtQkYsSUFBSUUsUUFBUSxDQUFDLG1CQUFtQkYsSUFBSUUsUUFBUSxDQUFDLG1CQUFtQkYsSUFBSUUsUUFBUSxDQUFDLGVBQWMsR0FBSTtZQUN6SUQsZUFBZUQsSUFBSUcsT0FBTyxDQUFDLG1CQUFtQjtRQUNoRDtRQUVBLE1BQU1DLFNBQVMsSUFBSUMsSUFBSUosY0FBYztRQUNyQyxNQUFNSyxZQUFZRixPQUFPRyxRQUFRLENBQUNDLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLENBQUFBLElBQUtBO1FBQ3pELElBQUlKLFVBQVVLLE1BQU0sS0FBSyxHQUFHLE9BQU87UUFFbkMsb0ZBQW9GO1FBQ3BGLElBQUlQLE9BQU9HLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDLGdCQUFnQjtZQUMzQyxrQ0FBa0M7WUFDbEMsTUFBTVUsU0FBU1IsT0FBT1MsUUFBUSxDQUFDVixPQUFPLENBQUMsUUFBUTtZQUMvQyxNQUFNVyxXQUFXRixTQUFTUixPQUFPRyxRQUFRO1lBQ3pDLHlEQUF5RDtZQUN6RCxJQUFJUSxXQUFXRCxTQUFTWCxPQUFPLENBQUMsT0FBTztZQUN2QyxpRUFBaUU7WUFDakVZLFdBQVdBLFNBQVNQLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNqQyxPQUFPTyxZQUFZO1FBQ3JCO1FBRUEsK0JBQStCO1FBQy9CLElBQUlYLE9BQU9HLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDLHlCQUF5QjtZQUNwRCxNQUFNVSxTQUFTUixPQUFPUyxRQUFRLENBQUNWLE9BQU8sQ0FBQyxRQUFR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LGdCQUFnQjtvQkFDaEJqTSxRQUFRO29CQUNSa00sWUFBWTtnQkFDZDs7a0NBQ0UsOERBQUNMO3dCQUFJeFQsT0FBTzs0QkFDVlAsT0FBTzs0QkFDUEUsUUFBUTs0QkFDUm1VLFFBQVE7NEJBQ1JDLFdBQVc7NEJBQ1hDLGNBQWM7NEJBQ2Q3SSxXQUFXOzRCQUNYOEksY0FBYzs0QkFDZEMsV0FBVzt3QkFDYjs7Ozs7O2tDQUNBLDhEQUFDVjt3QkFBSXhULE9BQU87NEJBQ1ZtVSxPQUFPOzRCQUNQQyxVQUFVOzRCQUNWQyxZQUFZOzRCQUNaSixjQUFjOzRCQUNkSyxZQUFZO3dCQUNkO2tDQUFHOzs7Ozs7a0NBR0gsOERBQUNkO3dCQUFJeFQsT0FBTzs0QkFDVm1VLE9BQU87NEJBQ1BDLFVBQVU7NEJBQ1ZDLFlBQVk7d0JBQ2Q7a0NBQUc7Ozs7OztrQ0FHSCw4REFBQ3JVO2tDQUFROzs7Ozs7Ozs7Ozs7MEJBUWIsOERBQUN3VDtnQkFDQ2UsS0FBSy9hO2dCQUNMd0csT0FBTztvQkFDTHdILFNBQVM1TixZQUFZLElBQUk7b0JBQ3pCZ1gsWUFBWTtnQkFDZDs7Ozs7Ozs7QUFJUjtHQS94R3dCdFg7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvUGFnZVJlbmRlcmVyLnRzeD84MGMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuaW50ZXJmYWNlIFBhZ2VSZW5kZXJlclByb3BzIHtcbiAgaHRtbDogc3RyaW5nXG59XG5cbi8vIEhlbHBlciB0byBleHRyYWN0IGZpbGVuYW1lIGZyb20gVVJMIChoYW5kbGVzIHF1ZXJ5IHBhcmFtcylcbi8vIElNUE9SVEFOVDogQXNzZXQgZmlsZXMgYXJlIG5hbWVkIHdpdGggYWxsdXJlZGlnaXRhbC5uZXQsIHNvIGFsd2F5cyBjb252ZXJ0IHJpbWFsd2ViLm5ldCBmaXJzdFxuZnVuY3Rpb24gZ2V0QXNzZXRGaWxlbmFtZSh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICB0cnkge1xuICAgIC8vIEFMV0FZUyBjb252ZXJ0IHJpbWFsd2ViLm5ldCB0byBhbGx1cmVkaWdpdGFsLm5ldCBGSVJTVCAtIGFzc2V0IGZpbGVzIHVzZSBhbGx1cmVkaWdpdGFsLm5ldFxuICAgIGxldCB1cmxUb1Byb2Nlc3MgPSB1cmxcbiAgICBpZiAodXJsICYmICh1cmwuaW5jbHVkZXMoJ3JpbWFsd2ViLm5ldCcpIHx8IHVybC5pbmNsdWRlcygnUmltYWx3ZWIubmV0JykgfHwgdXJsLmluY2x1ZGVzKCdSaW1hbFdlYi5uZXQnKSB8fCB1cmwuaW5jbHVkZXMoJ1JJTUFMV0VCLk5FVCcpKSkge1xuICAgICAgdXJsVG9Qcm9jZXNzID0gdXJsLnJlcGxhY2UoL3JpbWFsd2ViXFwubmV0L2dpLCAnYWxsdXJlZGlnaXRhbC5uZXQnKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybFRvUHJvY2VzcywgJ2h0dHBzOi8vYWxsdXJlZGlnaXRhbC5uZXQnKVxuICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHVybE9iai5wYXRobmFtZS5zcGxpdCgnLycpLmZpbHRlcihwID0+IHApXG4gICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gICAgXG4gICAgLy8gRm9yIGxpdGVzcGVlZCBDU1MvSlMgZmlsZXMsIGNvbnN0cnVjdCBmdWxsIHBhdGggKG1hdGNoZXMgc2NyYXBlZCBmaWxlbmFtZSBmb3JtYXQpXG4gICAgaWYgKHVybE9iai5wYXRobmFtZS5pbmNsdWRlcygnL2xpdGVzcGVlZC8nKSkge1xuICAgICAgLy8gRm9ybWF0OiBkb21haW5fcGF0aF90b19maWxlLmNzc1xuICAgICAgY29uc3QgZG9tYWluID0gdXJsT2JqLmhvc3RuYW1lLnJlcGxhY2UoJ3d3dy4nLCAnJylcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gZG9tYWluICsgdXJsT2JqLnBhdGhuYW1lXG4gICAgICAvLyBSZXBsYWNlIHNsYXNoZXMgd2l0aCB1bmRlcnNjb3Jlcywga2VlcCBkb3RzIGFuZCBkYXNoZXNcbiAgICAgIGxldCBmaWxlbmFtZSA9IGZ1bGxQYXRoLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgICAvLyBSZW1vdmUgcXVlcnkgcGFyYW1zIGZyb20gZmlsZW5hbWUgKGFscmVhZHkgaGFuZGxlZCBieSBzY3JhcGVyKVxuICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zcGxpdCgnPycpWzBdXG4gICAgICByZXR1cm4gZmlsZW5hbWUgfHwgbnVsbFxuICAgIH1cbiAgICBcbiAgICAvLyBGb3Igd3AtY29udGVudC91cGxvYWRzIGZpbGVzXG4gICAgaWYgKHVybE9iai5wYXRobmFtZS5pbmNsdWRlcygnL3dwLWNvbnRlbnQvdXBsb2Fkcy8nKSkge1xuICAgICAgY29uc3QgZG9tYWluID0gdXJsT2JqLmhvc3RuYW1lLnJlcGxhY2UoJ3d3dy4nLCAnJylcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gZG9tYWluICsgdXJsT2JqLnBhdGhuYW1lXG4gICAgICBsZXQgZmlsZW5hbWUgPSBmdWxsUGF0aC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zcGxpdCgnPycpWzBdXG4gICAgICByZXR1cm4gZmlsZW5hbWUgfHwgbnVsbFxuICAgIH1cbiAgICBcbiAgICAvLyBGb3Igb3RoZXIgZmlsZXMsIGNvbnN0cnVjdCBkb21haW5fcGF0aCBmb3JtYXRcbiAgICBjb25zdCBkb21haW4gPSB1cmxPYmouaG9zdG5hbWUucmVwbGFjZSgnd3d3LicsICcnKVxuICAgIGNvbnN0IGZ1bGxQYXRoID0gZG9tYWluICsgdXJsT2JqLnBhdGhuYW1lXG4gICAgbGV0IGZpbGVuYW1lID0gZnVsbFBhdGgucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNwbGl0KCc/JylbMF1cbiAgICBcbiAgICByZXR1cm4gZmlsZW5hbWUgfHwgbnVsbFxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2VSZW5kZXJlcih7IGh0bWwgfTogUGFnZVJlbmRlcmVyUHJvcHMpIHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBzY3JpcHRzTG9hZGVkUmVmID0gdXNlUmVmPFNldDxzdHJpbmc+PihuZXcgU2V0KCkpXG4gIGNvbnN0IHN0eWxlc0xvYWRlZFJlZiA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKVxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcbiAgY29uc3QgY2xlYW51cFJlZiA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuICBjb25zdCBzY3JvbGxUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQgfHwgIWh0bWwpIHJldHVyblxuICAgIFxuICAgIHNldElzTG9hZGluZyh0cnVlKVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXG4gICAgY29uc3QgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCAndGV4dC9odG1sJylcblxuICAgIC8vIEV4dHJhY3QgYW5kIGluamVjdCBoZWFkIGNvbnRlbnQgRklSU1QgKGJlZm9yZSBib2R5KVxuICAgIGNvbnN0IGhlYWQgPSBkb2MucXVlcnlTZWxlY3RvcignaGVhZCcpXG4gICAgY29uc3Qgc3R5bGVQcm9taXNlczogUHJvbWlzZTx2b2lkPltdID0gW11cbiAgICBcbiAgICBpZiAoaGVhZCkge1xuICAgICAgICAvLyBMb2FkIEdvb2dsZSBGb250cyAoTW9udHNlcnJhdCBhbmQgUG9wcGlucykgLSBzYW1lIGFzIG9yaWdpbmFsIHdlYnNpdGVcbiAgICAgICAgY29uc3QgZ29vZ2xlRm9udHNMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgICAgIGdvb2dsZUZvbnRzTGluay5yZWwgPSAncHJlY29ubmVjdCdcbiAgICAgICAgZ29vZ2xlRm9udHNMaW5rLmhyZWYgPSAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbSdcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChnb29nbGVGb250c0xpbmspXG4gICAgICAgIFxuICAgICAgICBjb25zdCBnb29nbGVGb250c0xpbmsyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgICAgIGdvb2dsZUZvbnRzTGluazIucmVsID0gJ3ByZWNvbm5lY3QnXG4gICAgICAgIGdvb2dsZUZvbnRzTGluazIuaHJlZiA9ICdodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tJ1xuICAgICAgICBnb29nbGVGb250c0xpbmsyLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChnb29nbGVGb250c0xpbmsyKVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZm9udExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcbiAgICAgICAgZm9udExpbmsucmVsID0gJ3N0eWxlc2hlZXQnXG4gICAgICAgIGZvbnRMaW5rLmhyZWYgPSAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Nb250c2VycmF0Oml0YWwsd2dodEAwLDQwMDswLDUwMDswLDYwMDswLDcwMDswLDgwMDsxLDQwMCZmYW1pbHk9UG9wcGluczppdGFsLHdnaHRAMCw0MDA7MCw1MDA7MCw2MDA7MCw3MDA7MSw0MDAmZGlzcGxheT1zd2FwJ1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGZvbnRMaW5rKVxuICAgICAgICBcbiAgICAgIC8vIFByZWxvYWQgQUxMIGFzc2V0cyBmaXJzdCBzbyBicm93c2VyIGNhY2hlcyB0aGVtICh3b24ndCByZWxvYWQgb24gcmVmcmVzaClcbiAgICAgIGNvbnN0IGFsbEFzc2V0czogQXJyYXk8eyBocmVmOiBzdHJpbmc7IGFzOiBzdHJpbmcgfT4gPSBbXVxuICAgICAgXG4gICAgICAvLyBDb2xsZWN0IGFsbCBDU1MgZmlsZXNcbiAgICAgIGhlYWQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgY29uc3QgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnXG4gICAgICAgIGlmIChocmVmLmluY2x1ZGVzKCdhbGx1cmVkaWdpdGFsLm5ldCcpICYmICFocmVmLmluY2x1ZGVzKCdmb250cy5nb29nbGVhcGlzLmNvbScpKSB7XG4gICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBnZXRBc3NldEZpbGVuYW1lKGhyZWYpXG4gICAgICAgICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICBhbGxBc3NldHMucHVzaCh7IGhyZWY6IGAvYXNzZXRzLyR7ZmlsZW5hbWV9YCwgYXM6ICdzdHlsZScgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENvbGxlY3QgYWxsIHNjcmlwdCBmaWxlc1xuICAgICAgaGVhZC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbc3JjXScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGVsLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJydcbiAgICAgICAgaWYgKHNyYyAmJiAoc3JjLmluY2x1ZGVzKCdhbGx1cmVkaWdpdGFsLm5ldCcpIHx8IHNyYy5zdGFydHNXaXRoKCcvYXNzZXRzLycpKSkge1xuICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2V0QXNzZXRGaWxlbmFtZShzcmMpXG4gICAgICAgICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICBhbGxBc3NldHMucHVzaCh7IGhyZWY6IGAvYXNzZXRzLyR7ZmlsZW5hbWV9YCwgYXM6ICdzY3JpcHQnIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBDb2xsZWN0IGNyaXRpY2FsIGltYWdlcyBmcm9tIGJvZHlcbiAgICAgIGNvbnN0IGJvZHkgPSBkb2MucXVlcnlTZWxlY3RvcignYm9keScpXG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICAvLyBMb2dvICh1c2Ugc21hbGwgMS5wbmcgZm9yIG5hdmJhcilcbiAgICAgICAgYWxsQXNzZXRzLnB1c2goeyBocmVmOiAnLzEucG5nJywgYXM6ICdpbWFnZScgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEhlcm8gYW5kIGltcG9ydGFudCBpbWFnZXMgKGZpcnN0IDE1KVxuICAgICAgICBsZXQgaW1hZ2VDb3VudCA9IDBcbiAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbc3JjXScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgaWYgKGltYWdlQ291bnQgPj0gMTUpIHJldHVyblxuICAgICAgICAgIGNvbnN0IHNyYyA9IChlbCBhcyBIVE1MSW1hZ2VFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ3NyYycpIHx8ICcnXG4gICAgICAgICAgaWYgKHNyYyAmJiAoc3JjLmluY2x1ZGVzKCdhbGx1cmVkaWdpdGFsLm5ldCcpIHx8IHNyYy5pbmNsdWRlcygncmltYWx3ZWIubmV0JykgfHwgc3JjLnN0YXJ0c1dpdGgoJy9hc3NldHMvJykpKSB7XG4gICAgICAgICAgICBjb25zdCBmaXhlZFNyYyA9IHNyYy5pbmNsdWRlcygnL2Fzc2V0cy8nKSA/IHNyYyA6IGAvYXNzZXRzLyR7Z2V0QXNzZXRGaWxlbmFtZShzcmMpIHx8ICcnfWBcbiAgICAgICAgICAgIGlmIChmaXhlZFNyYyAmJiBmaXhlZFNyYyAhPT0gJy9hc3NldHMvJyAmJiAhYWxsQXNzZXRzLnNvbWUoYSA9PiBhLmhyZWYgPT09IGZpeGVkU3JjKSkge1xuICAgICAgICAgICAgICBhbGxBc3NldHMucHVzaCh7IGhyZWY6IGZpeGVkU3JjLCBhczogJ2ltYWdlJyB9KVxuICAgICAgICAgICAgICBpbWFnZUNvdW50KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBwcmVsb2FkIGxpbmtzIGZvciBBTEwgYXNzZXRzIChicm93c2VyIHdpbGwgY2FjaGUgdGhlbSlcbiAgICAgIGFsbEFzc2V0cy5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgICBpZiAoYXNzZXQuaHJlZiAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJwcmVsb2FkXCJdW2hyZWY9XCIke2Fzc2V0LmhyZWZ9XCJdYCkpIHtcbiAgICAgICAgICBjb25zdCBwcmVsb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgICAgICAgIHByZWxvYWRMaW5rLnJlbCA9ICdwcmVsb2FkJ1xuICAgICAgICAgIHByZWxvYWRMaW5rLmFzID0gYXNzZXQuYXNcbiAgICAgICAgICBwcmVsb2FkTGluay5ocmVmID0gYXNzZXQuaHJlZlxuICAgICAgICAgIC8vIEFkZCBjcm9zc29yaWdpbiBmb3IgZm9udHMgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKGFzc2V0LmFzID09PSAnZm9udCcpIHtcbiAgICAgICAgICAgIHByZWxvYWRMaW5rLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChwcmVsb2FkTGluaylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gSW5qZWN0IEFMTCBzdHlsZXNoZWV0cyAocHJlc2VydmUgb3JkZXIgZm9yIGFuaW1hdGlvbnMpXG4gICAgICBoZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXSwgc3R5bGUnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ0xJTksnKSB7XG4gICAgICAgICAgY29uc3QgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnXG4gICAgICAgICAgY29uc3Qgc3R5bGVJZCA9IGhyZWZcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXN0eWxlc0xvYWRlZFJlZi5jdXJyZW50LmhhcyhzdHlsZUlkKSkge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTExpbmtFbGVtZW50XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9ubHkgbG9hZCBsb2NhbCBDU1MgLSBza2lwIGV4dGVybmFsIGZvbnRzXG4gICAgICAgICAgICBpZiAoaHJlZi5pbmNsdWRlcygnZm9udHMuZ29vZ2xlYXBpcy5jb20nKSB8fCBcbiAgICAgICAgICAgICAgICBocmVmLmluY2x1ZGVzKCdnb29nbGVhcGlzLmNvbScpIHx8XG4gICAgICAgICAgICAgICAgaHJlZi5pbmNsdWRlcygnZ3N0YXRpYy5jb20nKSkge1xuICAgICAgICAgICAgICAvLyBTa2lwIGV4dGVybmFsIGZvbnRzIC0gZG9uJ3QgbG9hZCB0aGVtXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSBlbHNlIGlmIChocmVmLmluY2x1ZGVzKCdhbGx1cmVkaWdpdGFsLm5ldCcpIHx8IGhyZWYuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2V0QXNzZXRGaWxlbmFtZShocmVmKVxuICAgICAgICAgICAgICBpZiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBjbG9uZS5ocmVmID0gYC9hc3NldHMvJHtmaWxlbmFtZX1gXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpZiBjYW4ndCBmaW5kIGxvY2FsIGFzc2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdkYXRhLWluamVjdGVkJywgJ3RydWUnKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBXYWl0IGZvciBzdHlsZXNoZWV0IHRvIGxvYWQgYW5kIGJlIGFwcGxpZWRcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlXG4gICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVPbmNlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCBtb3JlIHRvIGVuc3VyZSBDU1MgaXMgYXBwbGllZCB0byBET01cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCAxMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjbG9uZS5vbmxvYWQgPSByZXNvbHZlT25jZVxuICAgICAgICAgICAgICBjbG9uZS5vbmVycm9yID0gcmVzb2x2ZU9uY2UgLy8gQ29udGludWUgZXZlbiBpZiBzdHlsZXNoZWV0IGZhaWxzXG4gICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY2xvbmUpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBGYWxsYmFjazogcmVzb2x2ZSBhZnRlciByZWFzb25hYmxlIHRpbWVvdXRcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZU9uY2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMjAwMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzdHlsZVByb21pc2VzLnB1c2goc3R5bGVQcm9taXNlKVxuICAgICAgICAgICAgc3R5bGVzTG9hZGVkUmVmLmN1cnJlbnQuYWRkKHN0eWxlSWQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09ICdTVFlMRScpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgc3R5bGVzIC0gaW5qZWN0IGRpcmVjdGx5XG4gICAgICAgICAgY29uc3Qgc3R5bGVJZCA9IGVsLnRleHRDb250ZW50Py5zdWJzdHJpbmcoMCwgNTApIHx8IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKVxuICAgICAgICAgIGlmICghc3R5bGVzTG9hZGVkUmVmLmN1cnJlbnQuaGFzKHN0eWxlSWQpKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MU3R5bGVFbGVtZW50XG4gICAgICAgICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5qZWN0ZWQnLCAndHJ1ZScpXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGNsb25lKVxuICAgICAgICAgICAgc3R5bGVzTG9hZGVkUmVmLmN1cnJlbnQuYWRkKHN0eWxlSWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBJbmplY3QgbWV0YSB0YWdzIGFuZCB0aXRsZSAod2l0aCBicmFuZGluZyByZXBsYWNlbWVudClcbiAgICAgIGhlYWQucXVlcnlTZWxlY3RvckFsbCgnbWV0YSwgdGl0bGUnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ1RJVExFJykge1xuICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgdGl0bGUsIHdoZXRoZXIgaXQgZXhpc3RzIG9yIG5vdFxuICAgICAgICAgIGNvbnN0IHRpdGxlVGV4dCA9IGVsLnRleHRDb250ZW50IHx8ICcnXG4gICAgICAgICAgY29uc3QgcmVwbGFjZWRUZXh0ID0gdGl0bGVUZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlIERpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlRGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9hbGx1cmUgZGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9BbGx1cmVEaWdpdGFsXFwubmV0L2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL2FsbHVyZWRpZ2l0YWxcXC5uZXQvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGRvY3VtZW50LnRpdGxlIGRpcmVjdGx5ICh0aGlzIGlzIHdoYXQgc2hvd3MgaW4gYnJvd3NlciB0YWIpXG4gICAgICAgICAgZG9jdW1lbnQudGl0bGUgPSByZXBsYWNlZFRleHQgfHwgJ1JpbWFsd2ViJ1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gdXBkYXRlL2NyZWF0ZSB0aXRsZSB0YWcgaW4gaGVhZFxuICAgICAgICAgIGxldCBleGlzdGluZ1RpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKVxuICAgICAgICAgIGlmIChleGlzdGluZ1RpdGxlKSB7XG4gICAgICAgICAgICBleGlzdGluZ1RpdGxlLnRleHRDb250ZW50ID0gcmVwbGFjZWRUZXh0IHx8ICdSaW1hbHdlYidcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3VGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aXRsZScpXG4gICAgICAgICAgICBuZXdUaXRsZS50ZXh0Q29udGVudCA9IHJlcGxhY2VkVGV4dCB8fCAnUmltYWx3ZWInXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG5ld1RpdGxlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3JjZSB1cGRhdGUgYWZ0ZXIgYSBzbWFsbCBkZWxheSB0byBlbnN1cmUgaXQgcGVyc2lzdHNcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnRpdGxlID0gcmVwbGFjZWRUZXh0IHx8ICdSaW1hbHdlYidcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd0aXRsZScpXG4gICAgICAgICAgICBpZiAodGl0bGVFbCkge1xuICAgICAgICAgICAgICB0aXRsZUVsLnRleHRDb250ZW50ID0gcmVwbGFjZWRUZXh0IHx8ICdSaW1hbHdlYidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDApXG4gICAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZSA9PT0gJ01FVEEnKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIG1ldGEgdGFnc1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBgbWV0YVtuYW1lPVwiJHtlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3Byb3BlcnR5Jyl9XCJdYFxuICAgICAgICApXG4gICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNsb25lLmdldEF0dHJpYnV0ZSgnY29udGVudCcpXG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCBjb250ZW50XG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZSBEaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9BbGx1cmVEaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9hbGx1cmUgZGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgJ3JpbWFsd2ViLmNvbScpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY2xvbmUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBtZXRhIHRhZ1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsLmdldEF0dHJpYnV0ZSgnY29udGVudCcpXG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICBjb25zdCByZXBsYWNlZENvbnRlbnQgPSBjb250ZW50XG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZSBEaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9BbGx1cmVEaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9hbGx1cmUgZGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgJ3JpbWFsd2ViLmNvbScpXG4gICAgICAgICAgICAgIGV4aXN0aW5nLnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHJlcGxhY2VkQ29udGVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBib2R5IGFuZCBwcmVzZXJ2ZSBBTEwgYXR0cmlidXRlcyBhbmQgY2xhc3Nlc1xuICAgIGNvbnN0IGJvZHkgPSBkb2MucXVlcnlTZWxlY3RvcignYm9keScpXG4gICAgaWYgKGJvZHkgJiYgY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIEFwcGx5IGJvZHkgY2xhc3NlcyB0byBjb250YWluZXIgdG8gcHJlc2VydmUgc3R5bGluZ1xuICAgICAgY29uc3QgYm9keUNsYXNzZXMgPSBib2R5LmNsYXNzTmFtZVxuICAgICAgaWYgKGJvZHlDbGFzc2VzKSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LmNsYXNzTmFtZSA9IGJvZHlDbGFzc2VzXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvcHkgYm9keSBhdHRyaWJ1dGVzXG4gICAgICBBcnJheS5mcm9tKGJvZHkuYXR0cmlidXRlcykuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICBpZiAoYXR0ci5uYW1lICE9PSAnY2xhc3MnKSB7XG4gICAgICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQ/LnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIENoZWNrIGlmIGFzc2V0IGZpbGUgZXhpc3RzIChhc3luYyBjaGVjaylcbiAgICAgIGNvbnN0IGNoZWNrQXNzZXRFeGlzdHMgPSBhc3luYyAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChwYXRoLCB7IG1ldGhvZDogJ0hFQUQnIH0pXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpeCBBTEwgYXNzZXQgVVJMcyBpbiBib2R5IEJFRk9SRSBzZXR0aW5nIGlubmVySFRNTFxuICAgICAgLy8gSU1QT1JUQU5UOiBBc3NldCBmaWxlcyBhcmUgbmFtZWQgd2l0aCBhbGx1cmVkaWdpdGFsLm5ldCwgc28gYWx3YXlzIGNvbnZlcnQgcmltYWx3ZWIubmV0IGZpcnN0XG4gICAgICBjb25zdCBmaXhBc3NldFVybCA9ICh1cmw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICAgIGlmICghdXJsIHx8IHVybC5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHVybC5zdGFydHNXaXRoKCcvYXNzZXRzLycpKSByZXR1cm4gdXJsXG4gICAgICAgIFxuICAgICAgICAvLyBBTFdBWVMgY29udmVydCByaW1hbHdlYi5uZXQgKGFueSBjYXNlIHZhcmlhdGlvbikgdG8gYWxsdXJlZGlnaXRhbC5uZXQgRklSU1QgZm9yIGFzc2V0IGZpbGVuYW1lIGxvb2t1cFxuICAgICAgICBsZXQgdXJsVG9Qcm9jZXNzID0gdXJsXG4gICAgICAgIGlmICgvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KHVybCkpIHtcbiAgICAgICAgICB1cmxUb1Byb2Nlc3MgPSB1cmwucmVwbGFjZSgvcmltYWx3ZWJcXC5uZXQvZ2ksICdhbGx1cmVkaWdpdGFsLm5ldCcpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE5vdyBwcm9jZXNzIHdpdGggYWxsdXJlZGlnaXRhbC5uZXQgVVJMXG4gICAgICAgIGlmICh1cmxUb1Byb2Nlc3MuaW5jbHVkZXMoJ2FsbHVyZWRpZ2l0YWwubmV0JykgfHwgdXJsVG9Qcm9jZXNzLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2V0QXNzZXRGaWxlbmFtZSh1cmxUb1Byb2Nlc3MpXG4gICAgICAgICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAvLyBXb3JkUHJlc3MgYWRkcyBzaXplIHN1ZmZpeGVzIGxpa2UgLTIwNDh4OTAzLCAtMzAweDIwMCwgZXRjLiB0byBpbWFnZSBVUkxzXG4gICAgICAgICAgICAvLyBidXQgdGhlIGFjdHVhbCBmaWxlcyBkb24ndCBoYXZlIHRoZXNlIHN1ZmZpeGVzLiBTdHJpcCB0aGVtIGZyb20gZmlsZW5hbWUuXG4gICAgICAgICAgICBjb25zdCBmaWxlbmFtZVdpdGhvdXRTaXplID0gZmlsZW5hbWUucmVwbGFjZSgvLVxcZCt4XFxkKyhcXC5bYS16XSspJC9pLCAnJDEnKVxuICAgICAgICAgICAgcmV0dXJuIGAvYXNzZXRzLyR7ZmlsZW5hbWVXaXRob3V0U2l6ZX1gXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG5cbiAgICAgIC8vIEZpeCBpbWFnZXMgYW5kIHJlcGxhY2UgbG9nbyBpbWFnZXMgd2l0aCBjdXN0b20gU1ZHIGxvZ29cbiAgICAgIGJvZHkucXVlcnlTZWxlY3RvckFsbCgnaW1nW3NyY10nKS5mb3JFYWNoKChpbWcpID0+IHtcbiAgICAgICAgY29uc3Qgc3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIGNvbnN0IGZpeGVkU3JjID0gZml4QXNzZXRVcmwoc3JjKVxuICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGZpeGVkU3JjKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGltYWdlIGlzIGluIFwiV2VsY29tZSB0byBSaW1hbHdlYlwiIHNlY3Rpb25cbiAgICAgICAgICBjb25zdCB3ZWxjb21lU2VjdGlvbiA9IGltZy5jbG9zZXN0KCdzZWN0aW9uLCBkaXYnKT8ucXVlcnlTZWxlY3RvcignaDIsIGgxLCAuZWxlbWVudG9yLWhlYWRpbmctdGl0bGUnKVxuICAgICAgICAgIGNvbnN0IGlzV2VsY29tZVNlY3Rpb24gPSB3ZWxjb21lU2VjdGlvbiAmJiAoXG4gICAgICAgICAgICB3ZWxjb21lU2VjdGlvbi50ZXh0Q29udGVudD8uaW5jbHVkZXMoJ1dlbGNvbWUgdG8nKSB8fFxuICAgICAgICAgICAgd2VsY29tZVNlY3Rpb24udGV4dENvbnRlbnQ/LmluY2x1ZGVzKCdCcmVha2luZyBUaHJvdWdoJykgfHxcbiAgICAgICAgICAgIHdlbGNvbWVTZWN0aW9uLnRleHRDb250ZW50Py5pbmNsdWRlcygnRGlnaXRhbCBJbXBhc3NlJylcbiAgICAgICAgICApXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBpbWFnZXMgc21hbGxlciBpbiBXZWxjb21lIHNlY3Rpb25cbiAgICAgICAgICBpZiAoaXNXZWxjb21lU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgaW1nRWxlbWVudCA9IGltZyBhcyBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gcGFyc2VJbnQoaW1nLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAoaW1nRWxlbWVudC5vZmZzZXRXaWR0aCA/IGltZ0VsZW1lbnQub2Zmc2V0V2lkdGgudG9TdHJpbmcoKSA6ICcyMDAnKSlcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VJbnQoaW1nLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgKGltZ0VsZW1lbnQub2Zmc2V0SGVpZ2h0ID8gaW1nRWxlbWVudC5vZmZzZXRIZWlnaHQudG9TdHJpbmcoKSA6ICc1MCcpKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWR1Y2Ugc2l6ZSBieSAzMCUgZm9yIFdlbGNvbWUgc2VjdGlvbiBpbWFnZXNcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZChvcmlnaW5hbFdpZHRoICogMC43KVxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChvcmlnaW5hbEhlaWdodCAqIDAuNylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlID0gaW1nLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJ1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aC50b1N0cmluZygpKVxuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0LnRvU3RyaW5nKCkpXG4gICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdzdHlsZScsIGB3aWR0aDogJHt3aWR0aH1weDsgaGVpZ2h0OiAke2hlaWdodH1weDsgbWF4LXdpZHRoOiAke3dpZHRofXB4OyBvYmplY3QtZml0OiBjb250YWluOyAke2N1cnJlbnRTdHlsZX1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaXggbG9nbyBjYXJvdXNlbCBzbGlkZXIgaW1hZ2VzIC0gbWFrZSB0aGVtIHNtYWxsZXJcbiAgICAgICAgICBjb25zdCBpc0luTG9nb0Nhcm91c2VsID0gaW1nLmNsb3Nlc3QoJy5iZHQtbG9nby1jYXJvdXNlbC13cmFwcGVyJykgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLmNsb3Nlc3QoJy5iZHQtbG9nby1jYXJvdXNlbC1pdGVtJykgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLmNsYXNzTGlzdC5jb250YWlucygnYmR0LWxvZ28tY2Fyb3VzZWwtaW1nJylcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXNJbkxvZ29DYXJvdXNlbCkge1xuICAgICAgICAgICAgY29uc3QgaW1nRWxlbWVudCA9IGltZyBhcyBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSBpbWcuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnXG4gICAgICAgICAgICBpbWdFbGVtZW50LnN0eWxlLm1heFdpZHRoID0gJzIwMHB4J1xuICAgICAgICAgICAgaW1nRWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSAnMTAwcHgnXG4gICAgICAgICAgICBpbWdFbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICBpbWdFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgaW1nRWxlbWVudC5zdHlsZS5vYmplY3RGaXQgPSAnY29udGFpbidcbiAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYG1heC13aWR0aDogMjAwcHg7IG1heC1oZWlnaHQ6IDEwMHB4OyB3aWR0aDogYXV0bzsgaGVpZ2h0OiBhdXRvOyBvYmplY3QtZml0OiBjb250YWluOyAke2N1cnJlbnRTdHlsZX1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXBsYWNlIGxvZ28gaW1hZ2VzIGluIGhlYWRlci9mb290ZXIgd2l0aCBjdXN0b20gU1ZHIGxvZ29cbiAgICAgICAgICBjb25zdCBzcmNMb3dlciA9IHNyYy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgY29uc3QgaXNMb2dvSW1hZ2UgPSBzcmNMb3dlci5pbmNsdWRlcygnYWxsdXJlJykgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNyY0xvd2VyLmluY2x1ZGVzKCdsb2dvJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY0xvd2VyLmluY2x1ZGVzKCdhc3NldC0xJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjTG93ZXIuaW5jbHVkZXMoJ3N5bWJvbCcpKVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGlzSW5IZWFkZXIgPSBpbWcuY2xvc2VzdCgnaGVhZGVyJykgIT09IG51bGwgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuY2xvc2VzdCgnW2RhdGEtZWxlbWVudG9yLXR5cGU9XCJoZWFkZXJcIl0nKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLmNsb3Nlc3QoJ1tjbGFzcyo9XCJlbGVtZW50b3ItbG9jYXRpb24taGVhZGVyXCIgaV0nKSAhPT0gbnVsbFxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGlzSW5Gb290ZXIgPSBpbWcuY2xvc2VzdCgnZm9vdGVyJykgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZy5jbG9zZXN0KCdbY2xhc3MqPVwiZm9vdGVyXCIgaV0nKSAhPT0gbnVsbFxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGhhc0xvZ29DbGFzcyA9IGltZy5jbG9zZXN0KCdbY2xhc3MqPVwibG9nb1wiIGldJykgIT09IG51bGwgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuY2xvc2VzdCgnW2NsYXNzKj1cImJyYW5kXCIgaV0nKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLmNsb3Nlc3QoJ1tjbGFzcyo9XCJzaXRlLWxvZ29cIiBpXScpICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuY2xvc2VzdCgnW2NsYXNzKj1cImVsZW1lbnRvci13aWRnZXQtaW1hZ2VcIiBpXScpICE9PSBudWxsXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVwbGFjZSBsb2dvIGltYWdlcyB3aXRoIHNtYWxsIGxvZ28gZnJvbSBwdWJsaWMgZm9sZGVyICgxLnBuZylcbiAgICAgICAgICBpZiAoaXNMb2dvSW1hZ2UgJiYgKGlzSW5IZWFkZXIgfHwgaXNJbkZvb3RlciB8fCBoYXNMb2dvQ2xhc3MpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBpbWcucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICBjb25zdCBpbWdFbGVtZW50ID0gaW1nIGFzIEhUTUxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHBhcnNlSW50KGltZy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgKGltZ0VsZW1lbnQub2Zmc2V0V2lkdGggPyBpbWdFbGVtZW50Lm9mZnNldFdpZHRoLnRvU3RyaW5nKCkgOiAnMjAwJykpXG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VJbnQoaW1nLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgKGltZ0VsZW1lbnQub2Zmc2V0SGVpZ2h0ID8gaW1nRWxlbWVudC5vZmZzZXRIZWlnaHQudG9TdHJpbmcoKSA6ICc1MCcpKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVkdWNlIHNpemUgc2lnbmlmaWNhbnRseSBmb3IgbmF2YmFyIHRvIG1haW50YWluIG9yaWdpbmFsIGhlaWdodFxuICAgICAgICAgICAgICAvLyBGb3IgaGVhZGVyL25hdmJhciwgdXNlIG11Y2ggc21hbGxlciBzaXplICgzMCUpOyBmb3IgZm9vdGVyLCB1c2UgZXZlbiBzbWFsbGVyXG4gICAgICAgICAgICAgIGNvbnN0IHNpemVNdWx0aXBsaWVyID0gaXNJbkhlYWRlciA/IDAuMyA6IChpc0luRm9vdGVyID8gMC4yNSA6IDAuMylcbiAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKG9yaWdpbmFsV2lkdGggKiBzaXplTXVsdGlwbGllcilcbiAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChvcmlnaW5hbEhlaWdodCAqIHNpemVNdWx0aXBsaWVyKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGltZy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJydcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBpbWcuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnXG4gICAgICAgICAgICAgIGNvbnN0IGFsdCA9IGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8ICdSaW1hbHdlYidcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgaW1hZ2UgZWxlbWVudCB3aXRoIHNtYWxsIGxvZ28gKDEucG5nKSB0byBrZWVwIG5hdmJhciBoZWlnaHQgc21hbGxcbiAgICAgICAgICAgICAgY29uc3QgbmV3TG9nbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgICAgICAgICAgIG5ld0xvZ28uc3JjID0gJy8xLnBuZydcbiAgICAgICAgICAgICAgbmV3TG9nby5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgbmV3TG9nby5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodC50b1N0cmluZygpKVxuICAgICAgICAgICAgICBuZXdMb2dvLnNldEF0dHJpYnV0ZSgnYWx0JywgYWx0KVxuICAgICAgICAgICAgICBuZXdMb2dvLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc2VzKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gTWFrZSBmb290ZXIgbG9nbyB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICBjb25zdCBvcGFjaXR5U3R5bGUgPSBpc0luRm9vdGVyID8gJ29wYWNpdHk6IDAuNTsgJyA6ICcnXG4gICAgICAgICAgICAgIC8vIEtlZXAgaGVhZGVyIGxvZ28gYWxpZ25lZCBwcm9wZXJseSB3aXRob3V0IGV4dHJhIG1hcmdpbnNcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVyUG9zaXRpb25TdHlsZSA9IGlzSW5IZWFkZXIgPyAndmVydGljYWwtYWxpZ246IG1pZGRsZTsgJyA6ICcnXG4gICAgICAgICAgICAgIC8vIEFkZCBzdHlsZSB3aXRoIHNtYWxsZXIgc2l6ZSB0byBtYWludGFpbiBuYXZiYXIgb3JpZ2luYWwgaGVpZ2h0XG4gICAgICAgICAgICAgIG5ld0xvZ28uc2V0QXR0cmlidXRlKCdzdHlsZScsIGB3aWR0aDogJHt3aWR0aH1weDsgaGVpZ2h0OiAke2hlaWdodH1weDsgbWF4LXdpZHRoOiAke3dpZHRofXB4OyBtYXgtaGVpZ2h0OiAke2hlaWdodH1weDsgb2JqZWN0LWZpdDogY29udGFpbjsgJHtvcGFjaXR5U3R5bGV9JHtoZWFkZXJQb3NpdGlvblN0eWxlfSR7c3R5bGV9YClcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByZXNlcnZlIHBhcmVudCBsaW5rIGlmIGV4aXN0c1xuICAgICAgICAgICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBwYXJlbnQuY2xvbmVOb2RlKGZhbHNlKSBhcyBIVE1MQW5jaG9yRWxlbWVudFxuICAgICAgICAgICAgICAgIEFycmF5LmZyb20ocGFyZW50LmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBsaW5rLmFwcGVuZENoaWxkKG5ld0xvZ28pXG4gICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudEVsZW1lbnQ/LnJlcGxhY2VDaGlsZChsaW5rLCBwYXJlbnQpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdMb2dvLCBpbWcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIEZpeCBDU1MgbGlua3MgaW4gYm9keVxuICAgICAgYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2hyZWZdJykuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgZml4QXNzZXRVcmwoaHJlZikpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIEZpeCBiYWNrZ3JvdW5kIGltYWdlcyBpbiBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgICBib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tzdHlsZSo9XCJiYWNrZ3JvdW5kXCJdJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJydcbiAgICAgICAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS5yZXBsYWNlKC91cmxcXChbJ1wiXT8oW14nXCIpXSspWydcIl0/XFwpL2csIChtYXRjaCwgdXJsKSA9PiB7XG4gICAgICAgICAgY29uc3QgZml4ZWQgPSBmaXhBc3NldFVybCh1cmwpXG4gICAgICAgICAgcmV0dXJuIGB1cmwoJyR7Zml4ZWR9JylgXG4gICAgICAgIH0pXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBuZXdTdHlsZSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIEZpeCBpbnRlcm5hbCBsaW5rcyBhbmQgcmVwbGFjZSBjb250YWN0IGxpbmtzIHdpdGggZHVtbXkgZGF0YVxuICAgICAgYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZdJykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBjb25zdCBocmVmID0gYS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIEdvb2dsZSBNYXBzIGxpbmtzIGFuZCBsb2NhdGlvbiBsaW5rc1xuICAgICAgICBpZiAoaHJlZiAmJiAoXG4gICAgICAgICAgaHJlZi5pbmNsdWRlcygnbWFwcy5nb29nbGUuY29tJykgfHxcbiAgICAgICAgICBocmVmLmluY2x1ZGVzKCdtYXBzLmdvb2dsZWFwaXMuY29tJykgfHxcbiAgICAgICAgICBocmVmLmluY2x1ZGVzKCdnb29nbGUuY29tL21hcHMnKSB8fFxuICAgICAgICAgIGhyZWYuaW5jbHVkZXMoJ2dvby5nbC9tYXBzJykgfHxcbiAgICAgICAgICBocmVmLmluY2x1ZGVzKCdtYXBzLmFwcC5nb28uZ2wnKSB8fFxuICAgICAgICAgIGhyZWYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZmluZCB1cyBvbiBnb29nbGUgbWFwJykgfHxcbiAgICAgICAgICBocmVmLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2ZpbmQgdXMgb24gbWFwJykgfHxcbiAgICAgICAgICBocmVmLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ291ciBsb2NhdGlvbicpIHx8XG4gICAgICAgICAgaHJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdnZXQgZGlyZWN0aW9ucycpIHx8XG4gICAgICAgICAgKGhyZWYuaW5jbHVkZXMoJ3E9JykgJiYgKGhyZWYuaW5jbHVkZXMoJ0Jyb29rbHluJykgfHwgaHJlZi5pbmNsdWRlcygnNTMwMCcpIHx8IGhyZWYuaW5jbHVkZXMoJ0tpbmdzIEhpZ2h3YXknKSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxpbmsgYnV0IGtlZXAgdGhlIHRleHRcbiAgICAgICAgICBhLnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpXG4gICAgICAgICAgY29uc3QgbGlua0VsID0gYSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgIGxpbmtFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnXG4gICAgICAgICAgbGlua0VsLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0J1xuICAgICAgICAgIGxpbmtFbC5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICdub25lJ1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIHRlbDogYW5kIG1haWx0bzogbGlua3Mgd2l0aCBkdW1teSBkYXRhXG4gICAgICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aCgndGVsOicpKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlQaG9uZSA9ICcrMSAoNTU1KSAxMjMtNDU2NydcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIGB0ZWw6JHtkdW1teVBob25lLnJlcGxhY2UoL1xccy9nLCAnJykucmVwbGFjZSgvWygpXS9nLCAnJykucmVwbGFjZSgvLS9nLCAnJyl9YClcbiAgICAgICAgfSBlbHNlIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aCgnbWFpbHRvOicpKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlFbWFpbCA9ICdpbmZvQHJpbWFsd2ViLmNvbSdcbiAgICAgICAgICAvLyBSZXBsYWNlIG9sZCBlbWFpbCB3aXRoIGR1bW15IGVtYWlsXG4gICAgICAgICAgaWYgKGhyZWYuaW5jbHVkZXMoJ2FsbHVyZWRpZ2l0YWwubmV0JykpIHtcbiAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdocmVmJywgYG1haWx0bzoke2R1bW15RW1haWx9YClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gS2VlcCBleGlzdGluZyBlbWFpbCBpZiBpdCdzIG5vdCBhbGx1cmVkaWdpdGFsLm5ldFxuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmLnJlcGxhY2UoL21haWx0bzpbXkBdK0BhbGx1cmVkaWdpdGFsXFwubmV0L2dpLCBgbWFpbHRvOiR7ZHVtbXlFbWFpbH1gKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaHJlZiAmJiBocmVmLmluY2x1ZGVzKCdhbGx1cmVkaWdpdGFsLm5ldCcpKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBhbGx1cmVkaWdpdGFsLm5ldCBVUkxzIHRvIGxvY2FsIE5leHQuanMgcm91dGVzXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZilcbiAgICAgICAgICAgIGxldCBwYXRoID0gdXJsLnBhdGhuYW1lXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnZlcnQgY29tbW9uIFdvcmRQcmVzcyBwYXRocyB0byBOZXh0LmpzIHJvdXRlc1xuICAgICAgICAgICAgY29uc3Qgcm91dGVNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAgICcvc29jaWFsLW1lZGlhLW1hbmFnZW1lbnQnOiAnL3NvY2lhbC1tZWRpYS1tYW5hZ2VtZW50JyxcbiAgICAgICAgICAgICAgJy9zb2NpYWwtbWVkaWEtbWFya2V0aW5nJzogJy9zb2NpYWwtbWVkaWEtbWFuYWdlbWVudCcsIC8vIE1hcCB0byBleGlzdGluZyBwYWdlXG4gICAgICAgICAgICAgICcvYXBwaWFuLWRldmVsb3BtZW50JzogJy9hcHBpYW4tZGV2ZWxvcG1lbnQnLFxuICAgICAgICAgICAgICAnL3NvZnR3YXJlLWRldmVsb3BtZW50JzogJy9hcHBpYW4tZGV2ZWxvcG1lbnQnLCAvLyBNYXAgdG8gYXBwaWFuLWRldmVsb3BtZW50IHBhZ2VcbiAgICAgICAgICAgICAgJy9sb2NhbC1zZW8nOiAnL2xvY2FsLXNlbycsXG4gICAgICAgICAgICAgICcvcHBjLWFkdmVydGlzaW5nJzogJy9nb29nbGUtYWRzLW1hbmFnZW1lbnQnLCAvLyBNYXAgUFBDIHRvIEdvb2dsZSBBZHMgTWFuYWdlbWVudFxuICAgICAgICAgICAgICAnL2dvb2dsZS1hZHMtbWFuYWdlbWVudCc6ICcvZ29vZ2xlLWFkcy1tYW5hZ2VtZW50JywgLy8gTWFwIHRvIEdvb2dsZSBBZHMgTWFuYWdlbWVudCBwYWdlXG4gICAgICAgICAgICAgICcvd29yZHByZXNzLWRldmVsb3BtZW50JzogJy93b3JkcHJlc3MtZGV2ZWxvcG1lbnQnLFxuICAgICAgICAgICAgICAnL3Nob3BpZnktZGV2ZWxvcG1lbnQnOiAnL3Nob3BpZnktZGV2ZWxvcG1lbnQnLFxuICAgICAgICAgICAgICAnL2JyaWNrcy1idWlsZGVyLWRldmVsb3BtZW50JzogJy9icmlja3MtYnVpbGRlci1kZXZlbG9wbWVudCcsXG4gICAgICAgICAgICAgICcvY3JtLWRldmVsb3BtZW50JzogJy9jcm0tZGV2ZWxvcG1lbnQnLFxuICAgICAgICAgICAgICAnL2dvb2dsZS1tYXAtb3B0aW1pemF0aW9uJzogJy9nb29nbGUtbWFwLW9wdGltaXphdGlvbicsXG4gICAgICAgICAgICAgICcvc21hbGwtYnVzaW5lc3Mtc2VvLXNlcnZpY2UnOiAnL3NtYWxsLWJ1c2luZXNzLXNlby1zZXJ2aWNlJyxcbiAgICAgICAgICAgICAgJy9sb2NhbC1idXNpbmVzcy1jaXRhdGlvbnMtYnVpbGRpbmcnOiAnL2xvY2FsLWJ1c2luZXNzLWNpdGF0aW9ucy1idWlsZGluZycsXG4gICAgICAgICAgICAgICcvbGFuZGluZy1wYWdlLW9wdGltaXphdGlvbic6ICcvbGFuZGluZy1wYWdlLW9wdGltaXphdGlvbicsXG4gICAgICAgICAgICAgICcvdGVjaG5pY2FsLXNlby1zZXJ2aWNlJzogJy90ZWNobmljYWwtc2VvLXNlcnZpY2UnLFxuICAgICAgICAgICAgICAnL2NvbnRhY3QtdXMnOiAnL2NvbnRhY3QtdXMnLFxuICAgICAgICAgICAgICAnL3doby13ZS1hcmUnOiAnL3doby13ZS1hcmUnLFxuICAgICAgICAgICAgICAnL3BvcnRmb2xpbyc6ICcvcG9ydGZvbGlvJyxcbiAgICAgICAgICAgICAgJy93b3JrJzogJy93b3JrJyxcbiAgICAgICAgICAgICAgJy9ibG9nJzogJy9ibG9nJyxcbiAgICAgICAgICAgICAgJy9jYXJlZXJzJzogJy9jYXJlZXJzJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwYXRoIGV4aXN0cyBpbiByb3V0ZSBtYXBcbiAgICAgICAgICAgIGlmIChyb3V0ZU1hcFtwYXRoXSkge1xuICAgICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIHJvdXRlTWFwW3BhdGhdKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy9ibG9nLycpKSB7XG4gICAgICAgICAgICAgIC8vIEJsb2cgcG9zdHMgLSBrZWVwIHRoZSBwYXRoIGFzIGlzXG4gICAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdocmVmJywgcGF0aClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJy8nIHx8IHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdocmVmJywgJy8nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRm9yIHVua25vd24gcm91dGVzLCB0cnkgdG8gdXNlIHRoZSBwYXRoIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBwYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIFVSTCBwYXJzaW5nIGZhaWxzLCB0cnkgdG8gZXh0cmFjdCBwYXRoIG1hbnVhbGx5XG4gICAgICAgICAgICBjb25zdCBwYXRoTWF0Y2ggPSBocmVmLm1hdGNoKC9hbGx1cmVkaWdpdGFsXFwubmV0KFtePyNdKikvKVxuICAgICAgICAgICAgaWYgKHBhdGhNYXRjaCAmJiBwYXRoTWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgbGV0IHBhdGggPSBwYXRoTWF0Y2hbMV1cbiAgICAgICAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIHBhdGggfHwgJy8nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gUmVwbGFjZSBicmFuZGluZyAtIEFsbHVyZSBEaWdpdGFsIHRvIFJpbWFsd2ViIChPTkxZIHZpc2libGUgdGV4dCwgTk9UIFVSTHMgb3IgYXNzZXRzKVxuICAgICAgY29uc3QgcmVwbGFjZUJyYW5kaW5nID0gKGh0bWw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICAgIC8vIFJlcGxhY2UgaW4gdGV4dCBjb250ZW50IHVzaW5nIERPTSBtYW5pcHVsYXRpb24gZm9yIHNhZmV0eVxuICAgICAgICBjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBodG1sXG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIGluIGFsbCB0ZXh0IG5vZGVzIChidXQgTk9UIGluIHNjcmlwdCwgc3R5bGUsIHNyYywgaHJlZiwgb3IgVVJMcylcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgICB0ZW1wRGl2LFxuICAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19URVhULFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgICBcbiAgICAgICAgbGV0IG5vZGVcbiAgICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudFxuICAgICAgICAgIGlmICghcGFyZW50KSBjb250aW51ZVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNraXAgc2NyaXB0LCBzdHlsZSwgYW5kIGVsZW1lbnRzIHdpdGggc3JjL2hyZWYgKGltYWdlcywgbGlua3MsIGV0Yy4pXG4gICAgICAgICAgLy8gQlVUIGFsbG93IHRleHQgaW5zaWRlIGxpbmtzIChsaWtlIGJyZWFkY3J1bWJzKSB0byBiZSByZXBsYWNlZFxuICAgICAgICAgIGlmIChwYXJlbnQudGFnTmFtZSA9PT0gJ1NDUklQVCcgfHwgXG4gICAgICAgICAgICAgIHBhcmVudC50YWdOYW1lID09PSAnU1RZTEUnIHx8XG4gICAgICAgICAgICAgIHBhcmVudC50YWdOYW1lID09PSAnTk9TQ1JJUFQnIHx8XG4gICAgICAgICAgICAgIChwYXJlbnQuaGFzQXR0cmlidXRlKCdzcmMnKSAmJiBwYXJlbnQudGFnTmFtZSAhPT0gJ0EnKSB8fFxuICAgICAgICAgICAgICAocGFyZW50LmNsb3Nlc3QoJ2ltZycpICYmICFwYXJlbnQuY2xvc2VzdCgnYVtocmVmXScpKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxsb3cgcmVwbGFjZW1lbnQgaW4gbGluayB0ZXh0IChicmVhZGNydW1icywgZXRjLikgYnV0IG5vdCBpbiBocmVmIGF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09ICdBJyAmJiBwYXJlbnQuaGFzQXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGluayB0ZXh0LCB3ZSBjYW4gcmVwbGFjZSBpdCAtIGNvbnRpbnVlIHRvIHByb2Nlc3NcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSAmJiBwYXJlbnQudGFnTmFtZSAhPT0gJ0EnKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobm9kZS50ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBub2RlLnRleHRDb250ZW50XG4gICAgICAgICAgICAvLyBEb24ndCB0cmltIC0gcHJlc2VydmUgd2hpdGVzcGFjZSBmb3IgcHJvcGVyIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9ubHkgcmVwbGFjZSBpZiBpdCdzIHBsYWluIHRleHQgKG5vdCBwYXJ0IG9mIFVSTCBvciBwYXRoKVxuICAgICAgICAgICAgaWYgKCF0ZXh0Lm1hdGNoKC9odHRwcz86XFwvXFwvL2kpICYmIFxuICAgICAgICAgICAgICAgICF0ZXh0Lm1hdGNoKC9cXC9hc3NldHNcXC8vKSAmJlxuICAgICAgICAgICAgICAgICF0ZXh0Lm1hdGNoKC9cXC4ocG5nfGpwZ3xqcGVnfGdpZnxzdmd8Y3NzfGpzKS9pKSAmJlxuICAgICAgICAgICAgICAgICF0ZXh0Lm1hdGNoKC9eXFwvW15cXC9dLykpIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFJlcGxhY2Ugb25seSB0aGUgY29tcGFueSBuYW1lIHRleHQgKGNhc2UgaW5zZW5zaXRpdmUsIHdvcmQgYm91bmRhcmllcylcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxiQWxsdXJlIERpZ2l0YWxcXGIvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcYkFsbHVyZURpZ2l0YWxcXGIvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcYmFsbHVyZSBkaWdpdGFsXFxiL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHRleHQgIT09IG9yaWdpbmFsVGV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJlcGxhY2UgaW4gdGl0bGUgdGFnICh2aXNpYmxlIGluIGJyb3dzZXIgdGFiKVxuICAgICAgICB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RpdGxlJykuZm9yRWFjaCgodGl0bGUpID0+IHtcbiAgICAgICAgICBpZiAodGl0bGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gdGl0bGUudGV4dENvbnRlbnRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZSBEaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlRGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIGluIGFsdCBhdHRyaWJ1dGVzIChmb3IgYWNjZXNzaWJpbGl0eSlcbiAgICAgICAgdGVtcERpdi5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbYWx0XScpLmZvckVhY2goKGltZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGFsdCA9IGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpXG4gICAgICAgICAgaWYgKGFsdCAmJiAoYWx0LmluY2x1ZGVzKCdBbGx1cmUnKSB8fCBhbHQuaW5jbHVkZXMoJ2FsbHVyZScpKSkge1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnYWx0JywgYWx0XG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9BbGx1cmUgRGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZURpZ2l0YWwvZ2ksICdSaW1hbHdlYicpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIFJlcGxhY2UgaW4gaGVhZGluZyBlbGVtZW50cyAoaDEsIGgyLCBoMywgZXRjLikgLSBpbXBvcnRhbnQgZm9yIGhlcm8gc2VjdGlvbnNcbiAgICAgICAgdGVtcERpdi5xdWVyeVNlbGVjdG9yQWxsKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCAuZWxlbWVudG9yLWhlYWRpbmctdGl0bGUsIC5iZHQtZXAtaG92ZXItYm94LXRpdGxlLCBbY2xhc3MqPVwiaGVhZGluZ1wiXScpLmZvckVhY2goKGhlYWRpbmcpID0+IHtcbiAgICAgICAgICBpZiAoaGVhZGluZy50ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0ID0gaGVhZGluZy50ZXh0Q29udGVudFxuICAgICAgICAgICAgbGV0IG5ld1RleHQgPSBvcmlnaW5hbFRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYkFsbHVyZSBEaWdpdGFsXFxiL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxiQWxsdXJlRGlnaXRhbFxcYi9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYmFsbHVyZSBkaWdpdGFsXFxiL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobmV3VGV4dCAhPT0gb3JpZ2luYWxUZXh0KSB7XG4gICAgICAgICAgICAgIGhlYWRpbmcudGV4dENvbnRlbnQgPSBuZXdUZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBpbiBzcGFuIGFuZCBkaXYgZWxlbWVudHMgdGhhdCBtaWdodCBjb250YWluIGNvbXBhbnkgbmFtZSAoZm9yIGhlcm8gc2VjdGlvbnMpXG4gICAgICAgIHRlbXBEaXYucXVlcnlTZWxlY3RvckFsbCgnc3BhbiwgZGl2LCBwLCBsaScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgLy8gU2tpcCBpZiBpdCdzIGluc2lkZSBhIGxpbmsgaHJlZiBvciBpbWFnZSBzcmMsIGJ1dCBhbGxvdyBsaW5rIHRleHRcbiAgICAgICAgICBpZiAoZWwuY2xvc2VzdCgnaW1nJykgJiYgIWVsLmNsb3Nlc3QoJ2FbaHJlZl0nKSkgcmV0dXJuXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJvY2VzcyBpZiBpdCBoYXMgdGV4dCBjb250ZW50XG4gICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSBlbC50ZXh0Q29udGVudFxuICAgICAgICAgICAgbGV0IG5ld1RleHQgPSBvcmlnaW5hbFRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYkFsbHVyZSBEaWdpdGFsXFxiL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxiQWxsdXJlRGlnaXRhbFxcYi9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYmFsbHVyZSBkaWdpdGFsXFxiL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobmV3VGV4dCAhPT0gb3JpZ2luYWxUZXh0KSB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcmVwbGFjZSBpZiBpdCdzIGEgbGVhZiBub2RlIG9yIGhhcyBtaW5pbWFsIGNoaWxkcmVuXG4gICAgICAgICAgICAgIGlmIChlbC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IG5ld1RleHRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWxlbWVudHMgd2l0aCBjaGlsZHJlbiwgcmVwbGFjZSBpbiBkaXJlY3QgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdFRleHROb2RlcyA9IEFycmF5LmZyb20oZWwuY2hpbGROb2RlcykuZmlsdGVyKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICAgICAgZGlyZWN0VGV4dE5vZGVzLmZvckVhY2godGV4dE5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHRleHROb2RlLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlZCA9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxiQWxsdXJlIERpZ2l0YWxcXGIvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYkFsbHVyZURpZ2l0YWxcXGIvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYmFsbHVyZSBkaWdpdGFsXFxiL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZWQgIT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS50ZXh0Q29udGVudCA9IHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBpbiBkYXRhIGF0dHJpYnV0ZXMgdGhhdCBtaWdodCBjb250YWluIHRleHRcbiAgICAgICAgdGVtcERpdi5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10aXRsZV0sIFtkYXRhLXRleHRdLCBbZGF0YS1jb250ZW50XSwgW2RhdGEtbmFtZV0sIFtkYXRhLWxhYmVsXScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgWydkYXRhLXRpdGxlJywgJ2RhdGEtdGV4dCcsICdkYXRhLWNvbnRlbnQnLCAnZGF0YS1uYW1lJywgJ2RhdGEtbGFiZWwnXS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKVxuICAgICAgICAgICAgaWYgKHZhbHVlICYmICh2YWx1ZS5pbmNsdWRlcygnQWxsdXJlJykgfHwgdmFsdWUuaW5jbHVkZXMoJ2FsbHVyZScpKSkge1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWVcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlIERpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZURpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL2FsbHVyZSBkaWdpdGFsL2dpLCAnUmltYWx3ZWInKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBpbiBhcmlhLWxhYmVscyBhbmQgb3RoZXIgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAgICAgIHRlbXBEaXYucXVlcnlTZWxlY3RvckFsbCgnW2FyaWEtbGFiZWxdLCBbdGl0bGVdLCBbcGxhY2Vob2xkZXJdJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBbJ2FyaWEtbGFiZWwnLCAndGl0bGUnLCAncGxhY2Vob2xkZXInXS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKVxuICAgICAgICAgICAgaWYgKHZhbHVlICYmICh2YWx1ZS5pbmNsdWRlcygnQWxsdXJlJykgfHwgdmFsdWUuaW5jbHVkZXMoJ2FsbHVyZScpKSkge1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWVcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlIERpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZURpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL2FsbHVyZSBkaWdpdGFsL2dpLCAnUmltYWx3ZWInKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBpbiBzY3JpcHQgdGFncyB0aGF0IGNvbnRhaW4gSlNPTi1MRCBvciBzY2hlbWEgZGF0YVxuICAgICAgICB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlPVwiYXBwbGljYXRpb24vbGQranNvblwiXScpLmZvckVhY2goKHNjcmlwdCkgPT4ge1xuICAgICAgICAgIGlmIChzY3JpcHQudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShzY3JpcHQudGV4dENvbnRlbnQpXG4gICAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShqc29uRGF0YSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChqc29uU3RyaW5nLmluY2x1ZGVzKCdBbGx1cmUnKSB8fCBqc29uU3RyaW5nLmluY2x1ZGVzKCdhbGx1cmUnKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgaW4gSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlSW5PYmplY3QgPSAob2JqOiBhbnkpOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlIERpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZURpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL2FsbHVyZSBkaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9hbGx1cmVkaWdpdGFsXFwubmV0L2dpLCAncmltYWx3ZWIuY29tJylcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubWFwKHJlcGxhY2VJbk9iamVjdClcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkOiBhbnkgPSB7fVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlZFtrZXldID0gcmVwbGFjZUluT2JqZWN0KG9ialtrZXldKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlZCA9IHJlcGxhY2VJbk9iamVjdChqc29uRGF0YSlcbiAgICAgICAgICAgICAgICBzY3JpcHQudGV4dENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShyZXBsYWNlZClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJZiBKU09OIHBhcnNpbmcgZmFpbHMsIGRvIHNpbXBsZSBzdHJpbmcgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgaWYgKHNjcmlwdC50ZXh0Q29udGVudC5pbmNsdWRlcygnQWxsdXJlJykgfHwgc2NyaXB0LnRleHRDb250ZW50LmluY2x1ZGVzKCdhbGx1cmUnKSkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC50ZXh0Q29udGVudCA9IHNjcmlwdC50ZXh0Q29udGVudFxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZSBEaWdpdGFsL2dpLCAnUmltYWx3ZWInKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL0FsbHVyZURpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvYWxsdXJlIGRpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgJ3JpbWFsd2ViLmNvbScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIGluIGFsbCBvdGhlciBhdHRyaWJ1dGVzIChjYXRjaC1hbGwpXG4gICAgICAgIHRlbXBEaXYucXVlcnlTZWxlY3RvckFsbCgnKicpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgQXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICAvLyBTa2lwIHNyYywgaHJlZiwgYW5kIG90aGVyIFVSTCBhdHRyaWJ1dGVzIChhbHJlYWR5IGhhbmRsZWQpXG4gICAgICAgICAgICBpZiAoWydzcmMnLCAnaHJlZicsICdzcmNzZXQnLCAnZGF0YS1zcmMnLCAnZGF0YS1zcmNzZXQnXS5pbmNsdWRlcyhhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHIudmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAodmFsdWUuaW5jbHVkZXMoJ0FsbHVyZScpIHx8IHZhbHVlLmluY2x1ZGVzKCdhbGx1cmUnKSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZWQgPSB2YWx1ZVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9BbGx1cmUgRGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvQWxsdXJlRGlnaXRhbC9naSwgJ1JpbWFsd2ViJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvYWxsdXJlIGRpZ2l0YWwvZ2ksICdSaW1hbHdlYicpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocmVwbGFjZWQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgcmVwbGFjZWQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRlbXBEaXYuaW5uZXJIVE1MXG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgY29udGFjdCBpbmZvIChwaG9uZSwgZW1haWwsIGFkZHJlc3MpIHdpdGggZHVtbXkgZGF0YVxuICAgICAgY29uc3QgcmVwbGFjZUNvbnRhY3RJbmZvID0gKGh0bWw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICAgIC8vIER1bW15IGNvbnRhY3QgZGF0YVxuICAgICAgICBjb25zdCBkdW1teVBob25lID0gJysxICg1NTUpIDEyMy00NTY3J1xuICAgICAgICBjb25zdCBkdW1teUVtYWlsID0gJ2luZm9AcmltYWx3ZWIuY29tJ1xuICAgICAgICBjb25zdCBkdW1teUFkZHJlc3MgPSAnMTIzIEJ1c2luZXNzIFN0cmVldCwgU3VpdGUgMTAwLCBOZXcgWW9yaywgTlkgMTAwMDEnXG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIHBob25lIG51bWJlcnMgKGFsbCBmb3JtYXRzKSB3aXRoIGR1bW15IHBob25lXG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcKDIxMlxcKVxccyozMDEtNzYxNS9naSwgZHVtbXlQaG9uZSlcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvMjEyLTMwMS03NjE1L2dpLCBkdW1teVBob25lKVxuICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9cXCgyMTJcXClcXHMqMzAxXFxzKjc2MTUvZ2ksIGR1bW15UGhvbmUpXG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLzIxMlxccyozMDFcXHMqNzYxNS9naSwgZHVtbXlQaG9uZSlcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvdGVsOltcXGRcXHNcXC1cXChcXCldKy9naSwgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgLy8gUmVwbGFjZSB0ZWw6IGxpbmtzIHdpdGggZHVtbXkgcGhvbmVcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucmVwbGFjZSgvW1xcZFxcc1xcLVxcKFxcKV0rL2csIGR1bW15UGhvbmUucmVwbGFjZSgvXFxzL2csICctJykucmVwbGFjZSgvWygpXS9nLCAnJykpXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIGVtYWlsIGFkZHJlc3NlcyB3aXRoIGR1bW15IGVtYWlsXG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL2luZm9AYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgZHVtbXlFbWFpbClcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvW2EtekEtWjAtOS5fJSstXStAYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgZHVtbXlFbWFpbClcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvbWFpbHRvOihbYS16QS1aMC05Ll8lKy1dK0BhbGx1cmVkaWdpdGFsXFwubmV0KS9naSwgYG1haWx0bzoke2R1bW15RW1haWx9YClcbiAgICAgICAgXG4gICAgICAgIC8vIFJlcGxhY2UgYWRkcmVzc2VzIHdpdGggZHVtbXkgYWRkcmVzc1xuICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC81MzAwXFxzKktpbmdzXFxzKkhpZ2h3YXlcXHMqQnJvb2tseW5bXjxdKi9naSwgZHVtbXlBZGRyZXNzKVxuICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9Ccm9va2x5bixcXHMqTllcXHMqMTEyMzQvZ2ksICdOZXcgWW9yaywgTlkgMTAwMDEnKVxuICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC8xMDAwXFxzKkJyb2Fkd2F5LFxccypCcm9va2x5bixcXHMqTllcXHMqMTEyMTEvZ2ksIGR1bW15QWRkcmVzcylcbiAgICAgICAgXG4gICAgICAgIC8vIFJlcGxhY2UgY29udGFjdCBpbmZvIGluIHRleHQgY29udGVudFxuICAgICAgICBjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBodG1sXG4gICAgICAgIHRlbXBEaXYucXVlcnlTZWxlY3RvckFsbCgnKicpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGVsLnRleHRDb250ZW50XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSB0ZXh0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgcGhvbmUgbnVtYmVyc1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFwoMjEyXFwpXFxzKjMwMS03NjE1L2dpLCBkdW1teVBob25lKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvMjEyLTMwMS03NjE1L2dpLCBkdW1teVBob25lKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFwoMjEyXFwpXFxzKjMwMVxccyo3NjE1L2dpLCBkdW1teVBob25lKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvMjEyXFxzKjMwMVxccyo3NjE1L2dpLCBkdW1teVBob25lKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGVtYWlsc1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvaW5mb0BhbGx1cmVkaWdpdGFsXFwubmV0L2dpLCBkdW1teUVtYWlsKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvW2EtekEtWjAtOS5fJSstXStAYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgZHVtbXlFbWFpbClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVwbGFjZSBhZGRyZXNzZXNcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLzUzMDBcXHMqS2luZ3NcXHMqSGlnaHdheS9naSwgJzEyMyBCdXNpbmVzcyBTdHJlZXQsIFN1aXRlIDEwMCcpXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9Ccm9va2x5bixcXHMqTllcXHMqMTEyMzQvZ2ksICdOZXcgWW9yaywgTlkgMTAwMDEnKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvMTAwMFxccypCcm9hZHdheSxcXHMqQnJvb2tseW4sXFxzKk5ZXFxzKjExMjExL2dpLCBkdW1teUFkZHJlc3MpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSBvcmlnaW5hbFRleHQgJiYgZWwuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgZWwuY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHRleHQudHJpbSgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09IG9yaWdpbmFsVGV4dCkge1xuICAgICAgICAgICAgICAvLyBGb3IgZWxlbWVudHMgd2l0aCBjaGlsZHJlbiwgcmVwbGFjZSBpbiBkaXJlY3QgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICBjb25zdCBkaXJlY3RUZXh0Tm9kZXMgPSBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpLmZpbHRlcihub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKVxuICAgICAgICAgICAgICBkaXJlY3RUZXh0Tm9kZXMuZm9yRWFjaCh0ZXh0Tm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHROb2RlLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbm9kZVRleHQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlVGV4dCA9IG5vZGVUZXh0XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIG5vZGVUZXh0ID0gbm9kZVRleHQucmVwbGFjZSgvXFwoMjEyXFwpXFxzKjMwMS03NjE1L2dpLCBkdW1teVBob25lKVxuICAgICAgICAgICAgICAgICAgbm9kZVRleHQgPSBub2RlVGV4dC5yZXBsYWNlKC8yMTItMzAxLTc2MTUvZ2ksIGR1bW15UGhvbmUpXG4gICAgICAgICAgICAgICAgICBub2RlVGV4dCA9IG5vZGVUZXh0LnJlcGxhY2UoL2luZm9AYWxsdXJlZGlnaXRhbFxcLm5ldC9naSwgZHVtbXlFbWFpbClcbiAgICAgICAgICAgICAgICAgIG5vZGVUZXh0ID0gbm9kZVRleHQucmVwbGFjZSgvNTMwMFxccypLaW5nc1xccypIaWdod2F5L2dpLCAnMTIzIEJ1c2luZXNzIFN0cmVldCwgU3VpdGUgMTAwJylcbiAgICAgICAgICAgICAgICAgIG5vZGVUZXh0ID0gbm9kZVRleHQucmVwbGFjZSgvQnJvb2tseW4sXFxzKk5ZXFxzKjExMjM0L2dpLCAnTmV3IFlvcmssIE5ZIDEwMDAxJylcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUZXh0ICE9PSBvcmlnaW5hbE5vZGVUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnRleHRDb250ZW50ID0gbm9kZVRleHRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyByZXBsYWNlIGluIGhyZWYgYXR0cmlidXRlcyAodGVsOiBhbmQgbWFpbHRvOiBsaW5rcykgYW5kIHJlbW92ZSBHb29nbGUgTWFwcyBsaW5rc1xuICAgICAgICB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ2FbaHJlZl0nKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgY29uc3QgaHJlZiA9IGEuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJydcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgR29vZ2xlIE1hcHMgbGlua3NcbiAgICAgICAgICBpZiAoaHJlZiAmJiAoXG4gICAgICAgICAgICBocmVmLmluY2x1ZGVzKCdtYXBzLmdvb2dsZS5jb20nKSB8fFxuICAgICAgICAgICAgaHJlZi5pbmNsdWRlcygnbWFwcy5nb29nbGVhcGlzLmNvbScpIHx8XG4gICAgICAgICAgICBocmVmLmluY2x1ZGVzKCdnb29nbGUuY29tL21hcHMnKSB8fFxuICAgICAgICAgICAgaHJlZi5pbmNsdWRlcygnZ29vLmdsL21hcHMnKSB8fFxuICAgICAgICAgICAgaHJlZi5pbmNsdWRlcygnbWFwcy5hcHAuZ29vLmdsJykgfHxcbiAgICAgICAgICAgIGhyZWYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZmluZCB1cyBvbiBnb29nbGUgbWFwJykgfHxcbiAgICAgICAgICAgIGhyZWYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZmluZCB1cyBvbiBtYXAnKSB8fFxuICAgICAgICAgICAgaHJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdvdXIgbG9jYXRpb24nKSB8fFxuICAgICAgICAgICAgaHJlZi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdnZXQgZGlyZWN0aW9ucycpIHx8XG4gICAgICAgICAgICAoaHJlZi5pbmNsdWRlcygncT0nKSAmJiAoaHJlZi5pbmNsdWRlcygnQnJvb2tseW4nKSB8fCBocmVmLmluY2x1ZGVzKCc1MzAwJykgfHwgaHJlZi5pbmNsdWRlcygnS2luZ3MgSGlnaHdheScpKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICBhLnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpXG4gICAgICAgICAgICBjb25zdCBodG1sRWwgPSBhIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICBodG1sRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJ1xuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0J1xuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnRleHREZWNvcmF0aW9uID0gJ25vbmUnXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aCgndGVsOicpKSB7XG4gICAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIGB0ZWw6JHtkdW1teVBob25lLnJlcGxhY2UoL1xccy9nLCAnJykucmVwbGFjZSgvWygpXS9nLCAnJykucmVwbGFjZSgvLS9nLCAnJyl9YClcbiAgICAgICAgICB9IGVsc2UgaWYgKGhyZWYuc3RhcnRzV2l0aCgnbWFpbHRvOicpICYmIGhyZWYuaW5jbHVkZXMoJ2FsbHVyZWRpZ2l0YWwubmV0JykpIHtcbiAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdocmVmJywgYG1haWx0bzoke2R1bW15RW1haWx9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGVtcERpdi5pbm5lckhUTUxcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGJvZHkgY29udGVudCAtIGZpeCBhc3NldCBVUkxzIGZpcnN0LCB0aGVuIHJlcGxhY2UgYnJhbmRpbmcsIHRoZW4gcmVtb3ZlIGNvbnRhY3QgaW5mb1xuICAgICAgLy8gRmlyc3QsIGZpeCBhbGwgYXNzZXQgVVJMcyBpbiB0aGUgYm9keSBIVE1MIHN0cmluZyAoQkVGT1JFIGFueSB0ZXh0IHJlcGxhY2VtZW50KVxuICAgICAgbGV0IGJvZHlIdG1sID0gYm9keS5pbm5lckhUTUxcbiAgICAgIFxuICAgICAgLy8gRml4IFVSTHMgaW4gZGF0YS1zZXR0aW5ncyBhdHRyaWJ1dGVzIChKU09OIHN0cmluZ3MpIC0gQ1JJVElDQUw6IE11c3QgYmUgZG9uZSBmaXJzdFxuICAgICAgYm9keUh0bWwgPSBib2R5SHRtbC5yZXBsYWNlKC9kYXRhLXNldHRpbmdzPVwiKFteXCJdKilcIi9naSwgKG1hdGNoLCBqc29uU3RyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gRGVjb2RlIEhUTUwgZW50aXRpZXMgcHJvcGVybHlcbiAgICAgICAgICBjb25zdCBkZWNvZGVkID0ganNvblN0clxuICAgICAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJykgIC8vIE11c3QgZGVjb2RlICZhbXA7IGZpcnN0XG4gICAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJiMzOTsvZywgXCInXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJiN4Mjc7L2csIFwiJ1wiKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBKU09OIHRvIHZhbGlkYXRlIHN0cnVjdHVyZVxuICAgICAgICAgIGxldCBwYXJzZWQ6IGFueSA9IG51bGxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIEpTT04gaXMgaW52YWxpZCwganVzdCBmaXggVVJMcyBpbiB0aGUgcmF3IHN0cmluZyB3aXRob3V0IHBhcnNpbmdcbiAgICAgICAgICAgIGxldCBmaXhlZCA9IGpzb25TdHIucmVwbGFjZSgvaHR0cHM/OlxcL1xcLyhbXlwiXFwvXStcXC4pPyhhbGx1cmVkaWdpdGFsfHJpbWFsd2ViKVxcLm5ldChbXlwiXSopL2dpLCAodXJsTWF0Y2gsIHN1YmRvbWFpbiwgZG9tYWluLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIENhc2UtaW5zZW5zaXRpdmUgY2hlY2sgZm9yIHJpbWFsd2ViIGRvbWFpblxuICAgICAgICAgICAgICBjb25zdCB1cmxUb0ZpeCA9IC9yaW1hbHdlYi9pLnRlc3QoZG9tYWluIHx8IHVybE1hdGNoKVxuICAgICAgICAgICAgICAgID8gdXJsTWF0Y2gucmVwbGFjZSgvcmltYWx3ZWJcXC5uZXQvZ2ksICdhbGx1cmVkaWdpdGFsLm5ldCcpXG4gICAgICAgICAgICAgICAgOiB1cmxNYXRjaFxuICAgICAgICAgICAgICBjb25zdCBmaXhlZFVybCA9IGZpeEFzc2V0VXJsKHVybFRvRml4KVxuICAgICAgICAgICAgICAvLyBFc2NhcGUgdGhlIGZpeGVkIFVSTCBwcm9wZXJseSBmb3IgSlNPTlxuICAgICAgICAgICAgICByZXR1cm4gZml4ZWRVcmwucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gYGRhdGEtc2V0dGluZ3M9XCIke2ZpeGVkfVwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJZiBKU09OIGlzIHZhbGlkLCByZWN1cnNpdmVseSBmaXggVVJMcyBpbiBhbGwgc3RyaW5nIHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGZpeFVybHNJbk9iamVjdCA9IChvYmo6IGFueSk6IGFueSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gRml4IFVSTHMgaW4gc3RyaW5nIHZhbHVlcyAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai5yZXBsYWNlKC9odHRwcz86XFwvXFwvKFteXCJcXC9dK1xcLik/KGFsbHVyZWRpZ2l0YWx8cmltYWx3ZWIpXFwubmV0KFteXCJdKikvZ2ksICh1cmxNYXRjaCwgc3ViZG9tYWluLCBkb21haW4sIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXNlLWluc2Vuc2l0aXZlIGNoZWNrIGZvciByaW1hbHdlYiBkb21haW5cbiAgICAgICAgICAgICAgICBjb25zdCB1cmxUb0ZpeCA9IC9yaW1hbHdlYi9pLnRlc3QoZG9tYWluIHx8IHVybE1hdGNoKVxuICAgICAgICAgICAgICAgICAgPyB1cmxNYXRjaC5yZXBsYWNlKC9yaW1hbHdlYlxcLm5ldC9naSwgJ2FsbHVyZWRpZ2l0YWwubmV0JylcbiAgICAgICAgICAgICAgICAgIDogdXJsTWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4QXNzZXRVcmwodXJsVG9GaXgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLm1hcChmaXhVcmxzSW5PYmplY3QpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBjb25zdCBmaXhlZDogYW55ID0ge31cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRba2V5XSA9IGZpeFVybHNJbk9iamVjdChvYmpba2V5XSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZml4ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gS2VlcCBvcmlnaW5hbCBzbGlkZXNob3cgLSBkb24ndCByZXBsYWNlIHdpdGggYWJvdXQtYmFubmVyXG4gICAgICAgICAgLy8gUmVtb3ZlZCBjb2RlIHRoYXQgd2FzIHJlcGxhY2luZyBzbGlkZXNob3cgd2l0aCBhYm91dC1iYW5uZXIgaW1hZ2VcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBbHNvIGZpeCBjbGFzc2ljIGJhY2tncm91bmQgaW1hZ2VzXG4gICAgICAgICAgaWYgKHBhcnNlZC5iYWNrZ3JvdW5kX2JhY2tncm91bmQgPT09ICdjbGFzc2ljJyAmJiBwYXJzZWQuYmFja2dyb3VuZF9pbWFnZSAmJiBwYXJzZWQuYmFja2dyb3VuZF9pbWFnZS51cmwpIHtcbiAgICAgICAgICAgIHBhcnNlZC5iYWNrZ3JvdW5kX2ltYWdlLnVybCA9IGZpeFVybHNJbk9iamVjdChwYXJzZWQuYmFja2dyb3VuZF9pbWFnZS51cmwpXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGZpeGVkT2JqID0gZml4VXJsc0luT2JqZWN0KHBhcnNlZClcbiAgICAgICAgICBjb25zdCBmaXhlZEpzb24gPSBKU09OLnN0cmluZ2lmeShmaXhlZE9iailcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZS1lbmNvZGUgZm9yIEhUTUwgYXR0cmlidXRlIChwcm9wZXJseSBlc2NhcGUpXG4gICAgICAgICAgY29uc3QgcmVFbmNvZGVkID0gZml4ZWRKc29uXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKSAgLy8gTXVzdCBlbmNvZGUgJiBmaXJzdFxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYGRhdGEtc2V0dGluZ3M9XCIke3JlRW5jb2RlZH1cImBcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGFueXRoaW5nIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgdG8gcHJldmVudCBicmVha2luZyB0aGUgcGFnZVxuICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHByb2Nlc3MgZGF0YS1zZXR0aW5ncyBhdHRyaWJ1dGU6JywgZSlcbiAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gRml4IFVSTHMgaW4gc3JjIGF0dHJpYnV0ZXMgKHByZXNlcnZlIGV4YWN0IFVSTCBmb3JtYXQpXG4gICAgICBib2R5SHRtbCA9IGJvZHlIdG1sLnJlcGxhY2UoL3NyYz1cIihbXlwiXSphbGx1cmVkaWdpdGFsXFwubmV0W15cIl0qKVwiL2dpLCAobWF0Y2gsIHVybCkgPT4ge1xuICAgICAgICBjb25zdCBmaXhlZCA9IGZpeEFzc2V0VXJsKHVybClcbiAgICAgICAgcmV0dXJuIGBzcmM9XCIke2ZpeGVkfVwiYFxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gRml4IFVSTHMgaW4gc3Jjc2V0IGF0dHJpYnV0ZXNcbiAgICAgIGJvZHlIdG1sID0gYm9keUh0bWwucmVwbGFjZSgvc3Jjc2V0PVwiKFteXCJdKilcIi9naSwgKG1hdGNoLCBzcmNzZXQpID0+IHtcbiAgICAgICAgY29uc3QgZml4ZWRTcmNzZXQgPSBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBzcmMudHJpbSgpLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICBpZiAocGFydHNbMF0gJiYgKC9hbGx1cmVkaWdpdGFsXFwubmV0L2kudGVzdChwYXJ0c1swXSkgfHwgL3JpbWFsd2ViXFwubmV0L2kudGVzdChwYXJ0c1swXSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBhbHJlYWR5IGhhcyByaW1hbHdlYi5uZXQgKGFueSBjYXNlKSwgY29udmVydCBiYWNrIHRvIGFsbHVyZWRpZ2l0YWwubmV0IGZvciBmaWxlbmFtZVxuICAgICAgICAgICAgbGV0IHVybFRvRml4ID0gcGFydHNbMF1cbiAgICAgICAgICAgIGlmICgvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KHBhcnRzWzBdKSkge1xuICAgICAgICAgICAgICB1cmxUb0ZpeCA9IHBhcnRzWzBdLnJlcGxhY2UoL3JpbWFsd2ViXFwubmV0L2dpLCAnYWxsdXJlZGlnaXRhbC5uZXQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeEFzc2V0VXJsKHVybFRvRml4KSArIChwYXJ0c1sxXSA/ICcgJyArIHBhcnRzWzFdIDogJycpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzcmMudHJpbSgpXG4gICAgICAgIH0pLmpvaW4oJywgJylcbiAgICAgICAgcmV0dXJuIGBzcmNzZXQ9XCIke2ZpeGVkU3Jjc2V0fVwiYFxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gRml4IFVSTHMgaW4gc3R5bGUgYmFja2dyb3VuZCBpbWFnZXMgKGluY2x1ZGluZyBpbmxpbmUgc3R5bGVzIGluIEhUTUwpXG4gICAgICAvLyBJTVBPUlRBTlQ6IEFsd2F5cyBjb252ZXJ0IHJpbWFsd2ViLm5ldCAoYW55IGNhc2UpIHRvIGFsbHVyZWRpZ2l0YWwubmV0IGZvciBhc3NldCBmaWxlbmFtZSBsb29rdXBcbiAgICAgIGJvZHlIdG1sID0gYm9keUh0bWwucmVwbGFjZSgvdXJsXFwoWydcIl0/KFteJ1wiKV0qKD86YWxsdXJlZGlnaXRhbHxyaW1hbHdlYilcXC5uZXRbXidcIildKilbJ1wiXT9cXCkvZ2ksIChtYXRjaCwgdXJsKSA9PiB7XG4gICAgICAgIC8vIENvbnZlcnQgcmltYWx3ZWIubmV0IChhbnkgY2FzZSB2YXJpYXRpb24pIGJhY2sgdG8gYWxsdXJlZGlnaXRhbC5uZXQgZm9yIGZpbGVuYW1lIGxvb2t1cFxuICAgICAgICBsZXQgdXJsVG9GaXggPSB1cmxcbiAgICAgICAgaWYgKC9yaW1hbHdlYlxcLm5ldC9naS50ZXN0KHVybCkpIHtcbiAgICAgICAgICB1cmxUb0ZpeCA9IHVybC5yZXBsYWNlKC9yaW1hbHdlYlxcLm5ldC9naSwgJ2FsbHVyZWRpZ2l0YWwubmV0JylcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZCA9IGZpeEFzc2V0VXJsKHVybFRvRml4KVxuICAgICAgICByZXR1cm4gYHVybCgnJHtmaXhlZH0nKWBcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIEFsc28gZml4IGJhY2tncm91bmQtaW1hZ2UgaW4gc3R5bGUgYXR0cmlidXRlcyBkaXJlY3RseVxuICAgICAgLy8gSU1QT1JUQU5UOiBBbHdheXMgY29udmVydCByaW1hbHdlYi5uZXQgdG8gYWxsdXJlZGlnaXRhbC5uZXQgZm9yIGFzc2V0IGZpbGVuYW1lIGxvb2t1cFxuICAgICAgYm9keUh0bWwgPSBib2R5SHRtbC5yZXBsYWNlKC9iYWNrZ3JvdW5kLWltYWdlOlxccyp1cmxcXChbJ1wiXT8oW14nXCIpXSooPzphbGx1cmVkaWdpdGFsfHJpbWFsd2ViKVxcLm5ldFteJ1wiKV0qKVsnXCJdP1xcKS9naSwgKG1hdGNoLCB1cmwpID0+IHtcbiAgICAgICAgLy8gQUxXQVlTIGNvbnZlcnQgcmltYWx3ZWIubmV0IChhbnkgY2FzZSkgdG8gYWxsdXJlZGlnaXRhbC5uZXQgZm9yIGFzc2V0IGZpbGVuYW1lIGxvb2t1cFxuICAgICAgICAvLyBBc3NldCBmaWxlcyBhcmUgbmFtZWQgd2l0aCBhbGx1cmVkaWdpdGFsLm5ldCwgbm90IHJpbWFsd2ViLm5ldFxuICAgICAgICBsZXQgdXJsVG9GaXggPSB1cmxcbiAgICAgICAgaWYgKC9yaW1hbHdlYlxcLm5ldC9naS50ZXN0KHVybCkpIHtcbiAgICAgICAgICB1cmxUb0ZpeCA9IHVybC5yZXBsYWNlKC9yaW1hbHdlYlxcLm5ldC9naSwgJ2FsbHVyZWRpZ2l0YWwubmV0JylcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZCA9IGZpeEFzc2V0VXJsKHVybFRvRml4KVxuICAgICAgICByZXR1cm4gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgnJHtmaXhlZH0nKWBcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIEFsc28gZml4IGFueSByaW1hbHdlYi5uZXQgVVJMcyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiByZXBsYWNlZCBpbiBIVE1MIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgICAgYm9keUh0bWwgPSBib2R5SHRtbC5yZXBsYWNlKC9zcmM9XCIoW15cIl0qcmltYWx3ZWJcXC5uZXRbXlwiXSopXCIvZ2ksIChtYXRjaCwgdXJsKSA9PiB7XG4gICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBhbGx1cmVkaWdpdGFsLm5ldCBmb3IgZmlsZW5hbWUgKGhhbmRsZXMgYWxsIGNhc2UgdmFyaWF0aW9ucylcbiAgICAgICAgY29uc3QgdXJsVG9GaXggPSB1cmwucmVwbGFjZSgvcmltYWx3ZWJcXC5uZXQvZ2ksICdhbGx1cmVkaWdpdGFsLm5ldCcpXG4gICAgICAgIGNvbnN0IGZpeGVkID0gZml4QXNzZXRVcmwodXJsVG9GaXgpXG4gICAgICAgIHJldHVybiBgc3JjPVwiJHtmaXhlZH1cImBcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIEZpeCBocmVmIGF0dHJpYnV0ZXMgd2l0aCByaW1hbHdlYi5uZXQgVVJMcyAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgIGJvZHlIdG1sID0gYm9keUh0bWwucmVwbGFjZSgvaHJlZj1cIihbXlwiXSpyaW1hbHdlYlxcLm5ldFteXCJdKilcIi9naSwgKG1hdGNoLCB1cmwpID0+IHtcbiAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIGFsbHVyZWRpZ2l0YWwubmV0IGZvciBmaWxlbmFtZSAoaGFuZGxlcyBhbGwgY2FzZSB2YXJpYXRpb25zKVxuICAgICAgICBjb25zdCB1cmxUb0ZpeCA9IHVybC5yZXBsYWNlKC9yaW1hbHdlYlxcLm5ldC9naSwgJ2FsbHVyZWRpZ2l0YWwubmV0JylcbiAgICAgICAgY29uc3QgZml4ZWQgPSBmaXhBc3NldFVybCh1cmxUb0ZpeClcbiAgICAgICAgcmV0dXJuIGBocmVmPVwiJHtmaXhlZH1cImBcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENSSVRJQ0FMOiBGaW5hbCBjbGVhbnVwIC0gY2F0Y2ggYW55IC9hc3NldHMvUmltYWx3ZWIubmV0IFVSTHMgdGhhdCBzbGlwcGVkIHRocm91Z2hcbiAgICAgIC8vIFRoaXMgaGFuZGxlcyBVUkxzIHRoYXQgYXJlIGFscmVhZHkgaW4gL2Fzc2V0cy8gZm9ybWF0IGJ1dCBzdGlsbCBoYXZlIFJpbWFsd2ViLm5ldFxuICAgICAgLy8gRGlyZWN0IHJlcGxhY2VtZW50IG9mIC9hc3NldHMvUmltYWx3ZWIubmV0XyB0byAvYXNzZXRzL2FsbHVyZWRpZ2l0YWwubmV0XyAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgIGJvZHlIdG1sID0gYm9keUh0bWwucmVwbGFjZSgvXFwvYXNzZXRzXFwvW1JyXWltYWx3ZWJcXC5uZXRfL2dpLCAnL2Fzc2V0cy9hbGx1cmVkaWdpdGFsLm5ldF8nKVxuICAgICAgYm9keUh0bWwgPSBib2R5SHRtbC5yZXBsYWNlKC9cXC9hc3NldHNcXC9bUnJdaW1hbFtXd11lYlxcLm5ldF8vZ2ksICcvYXNzZXRzL2FsbHVyZWRpZ2l0YWwubmV0XycpXG4gICAgICBcbiAgICAgIC8vIEFsc28gY2F0Y2ggVVJMcyBpbiBhdHRyaWJ1dGUgdmFsdWVzIChzcmMsIGhyZWYsIHN0eWxlLCBldGMuKSB0aGF0IGFscmVhZHkgaGF2ZSAvYXNzZXRzL1JpbWFsd2ViLm5ldFxuICAgICAgYm9keUh0bWwgPSBib2R5SHRtbC5yZXBsYWNlKC8oKD86c3JjfGhyZWZ8c3Jjc2V0fHN0eWxlfGRhdGEtW149XSopPVsnXCJdKFteJ1wiXSopKVxcL2Fzc2V0c1xcL1tScl1pbWFsd2ViXFwubmV0KFteJ1wiXSopL2dpLCAobWF0Y2gsIHByZWZpeCwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJy9hc3NldHMvYWxsdXJlZGlnaXRhbC5uZXQnICsgYWZ0ZXJcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENhdGNoIGluIHVybCgpIENTUyBmdW5jdGlvbnNcbiAgICAgIGJvZHlIdG1sID0gYm9keUh0bWwucmVwbGFjZSgvdXJsXFwoWydcIl0/KFteJ1wiXSopXFwvYXNzZXRzXFwvW1JyXWltYWx3ZWJcXC5uZXQoW14nXCJdKilbJ1wiXT9cXCkvZ2ksIChtYXRjaCwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgICByZXR1cm4gYHVybCgnJHtiZWZvcmV9L2Fzc2V0cy9hbGx1cmVkaWdpdGFsLm5ldCR7YWZ0ZXJ9JylgXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBOb3cgcmVwbGFjZSBicmFuZGluZyAodGhpcyB3b24ndCBhZmZlY3QgYWxyZWFkeS1maXhlZCBVUkxzKVxuICAgICAgbGV0IGNsZWFuZWRIdG1sID0gcmVwbGFjZUJyYW5kaW5nKGJvZHlIdG1sKVxuICAgICAgY2xlYW5lZEh0bWwgPSByZXBsYWNlQ29udGFjdEluZm8oY2xlYW5lZEh0bWwpXG4gICAgICBcbiAgICAgIC8vIE1vZGlmeSBob21lcGFnZSBoZWFkaW5ncyB0byBhdm9pZCBjb3B5cmlnaHQgKHNpbWlsYXIgYnV0IGRpZmZlcmVudCB3b3JkaW5nKVxuICAgICAgY29uc3QgbW9kaWZ5SG9tZXBhZ2VIZWFkaW5ncyA9IChodG1sOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICBjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBodG1sXG4gICAgICAgIFxuICAgICAgICAvLyBIZWFkaW5nIHJlcGxhY2VtZW50cyAoc2ltaWxhciBtZWFuaW5nLCBkaWZmZXJlbnQgd29yZGluZylcbiAgICAgICAgY29uc3QgaGVhZGluZ1JlcGxhY2VtZW50czogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAgICAgICAnTGV0IFVzIEhlbHAgWW91JzogJ1dlXFwncmUgSGVyZSB0byBBc3Npc3QgWW91JyxcbiAgICAgICAgICAnR2V0IGEgVGFpbG9yZWQgQXBwcm9hY2ggd2l0aCBvdXIgRGlnaXRhbCBNYXJrZXRpbmcgQWdlbmN5IGluIEJyb29rbHluJzogJ0V4cGVyaWVuY2UgQ3VzdG9taXplZCBTb2x1dGlvbnMgd2l0aCBvdXIgRGlnaXRhbCBNYXJrZXRpbmcgQWdlbmN5IGluIE5ldyBZb3JrJyxcbiAgICAgICAgICAnR2V0IGEgVGFpbG9yZWQgQXBwcm9hY2ggd2l0aCBvdXIgRGlnaXRhbCBNYXJrZXRpbmcgQWdlbmN5IGluIEJyb29rbHluIE5ZJzogJ0V4cGVyaWVuY2UgQ3VzdG9taXplZCBTb2x1dGlvbnMgd2l0aCBvdXIgRGlnaXRhbCBNYXJrZXRpbmcgQWdlbmN5IGluIE5ldyBZb3JrJyxcbiAgICAgICAgICAnUHJvdmlkaW5nIElubm92YXRpdmUgRGlnaXRhbCBTb2x1dGlvbnMgZm9yIENsaWVudHMgc2luY2UgMjAxMCc6ICdEZWxpdmVyaW5nIEN1dHRpbmctRWRnZSBEaWdpdGFsIFNvbHV0aW9ucyBmb3IgQnVzaW5lc3NlcyBzaW5jZSAyMDE1JyxcbiAgICAgICAgICAnQSBHbGltcHNlIGludG8gdGhlIEJyYW5kcyBUaGF0IEJlY2FtZSBTdWNjZXNzZnVsIHdpdGggVXMnOiAnRGlzY292ZXIgdGhlIENvbXBhbmllcyBUaGF0IEFjaGlldmVkIFN1Y2Nlc3Mgd2l0aCBVcycsXG4gICAgICAgICAgJ091ciBXb3JraW5nIFBoaWxvc29waHknOiAnT3VyIEFwcHJvYWNoIHRvIFN1Y2Nlc3MnLFxuICAgICAgICAgICdTRU8gLSBUdXJuIFlvdXIgV2ViIFRyYWZmaWMgSW50byBQcm9maXRzIHdpdGggU0VPJzogJ1NFTyAtIFRyYW5zZm9ybSBZb3VyIFdlYnNpdGUgVmlzaXRvcnMgSW50byBSZXZlbnVlIHdpdGggU0VPJyxcbiAgICAgICAgICAnVW5sZWFzaCBZb3VyIEJ1c2luZXNzXFwncyBEaWdpdGFsIFBvdGVudGlhbCB3aXRoIE91ciBTZXJ2aWNlcyc6ICdVbmxvY2sgWW91ciBDb21wYW55XFwncyBEaWdpdGFsIEdyb3d0aCB3aXRoIE91ciBTZXJ2aWNlcycsXG4gICAgICAgICAgJ1dFIFNQRUNJQUxJWkUgSU4nOiAnT1VSIEVYUEVSVElTRSBJTkNMVURFUycsXG4gICAgICAgICAgJ0hvdyBPdXIgRGlnaXRhbCBNYXJrZXRpbmcgQ3JlYXRlcyBhIFN0cm9uZyBJbXBhY3QnOiAnSG93IE91ciBEaWdpdGFsIE1hcmtldGluZyBEcml2ZXMgUG93ZXJmdWwgUmVzdWx0cycsXG4gICAgICAgICAgJ1RoaW5rIEJpZ1xcblBsYW4gU21hcnRcXG5FeGVjdXRlIEZsYXdsZXNzbHknOiAnRHJlYW0gQmlnXFxuU3RyYXRlZ2l6ZSBXaXNlbHlcXG5EZWxpdmVyIEV4Y2VsbGVuY2UnXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJlcGxhY2UgaW4gYWxsIGhlYWRpbmcgZWxlbWVudHMgKGluY2x1ZGluZyBoYS1ncmFkaWVudC1oZWFkaW5nIGZvciBTRVJWSUNFUyBzZWN0aW9uKVxuICAgICAgICB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIC5lbGVtZW50b3ItaGVhZGluZy10aXRsZSwgLmhhLWdyYWRpZW50LWhlYWRpbmcsIC5lcC1oZWFkaW5nJykuZm9yRWFjaCgoaGVhZGluZykgPT4ge1xuICAgICAgICAgIGlmIChoZWFkaW5nLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGhlYWRpbmcudGV4dENvbnRlbnQudHJpbSgpXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSB0ZXh0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aS1saW5lIHRleHQgKGxpa2UgXCJVbmxlYXNoIFlvdXIgQnVzaW5lc3MncyBEaWdpdGFsIFBvdGVudGlhbCB3aXRoIE91ciBTZXJ2aWNlc1xcblwiKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuXFxzKi9nLCAnICcpLnRyaW0oKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZXhhY3QgbWF0Y2hlcyBmaXJzdFxuICAgICAgICAgICAgaWYgKGhlYWRpbmdSZXBsYWNlbWVudHNbdGV4dF0pIHtcbiAgICAgICAgICAgICAgaGVhZGluZy50ZXh0Q29udGVudCA9IGhlYWRpbmdSZXBsYWNlbWVudHNbdGV4dF1cbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBwYXJ0aWFsIG1hdGNoZXMgYW5kIHJlcGxhY2VcbiAgICAgICAgICAgIGZvciAoY29uc3QgW29yaWdpbmFsLCByZXBsYWNlbWVudF0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGluZ1JlcGxhY2VtZW50cykpIHtcbiAgICAgICAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShvcmlnaW5hbCwgcmVwbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgaWYgKHRleHQgIT09IG9yaWdpbmFsVGV4dCkge1xuICAgICAgICAgICAgICAgICAgaGVhZGluZy50ZXh0Q29udGVudCA9IHRleHRcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBbHNvIGNoZWNrIHRyaW1tZWQgb3JpZ2luYWwgdGV4dFxuICAgICAgICAgICAgY29uc3QgdHJpbW1lZE9yaWdpbmFsID0gb3JpZ2luYWxUZXh0LnJlcGxhY2UoL1xcblxccyovZywgJyAnKS50cmltKClcbiAgICAgICAgICAgIGlmIChoZWFkaW5nUmVwbGFjZW1lbnRzW3RyaW1tZWRPcmlnaW5hbF0pIHtcbiAgICAgICAgICAgICAgaGVhZGluZy50ZXh0Q29udGVudCA9IGhlYWRpbmdSZXBsYWNlbWVudHNbdHJpbW1lZE9yaWdpbmFsXVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHJlcGxhY2UgaW4gZGF0YSBhdHRyaWJ1dGVzIHRoYXQgbWlnaHQgY29udGFpbiBoZWFkaW5nIHRleHQgKGxpa2UgYW5pbWF0ZWQgaGVhZGxpbmVzKVxuICAgICAgICB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNldHRpbmdzXScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2V0dGluZ3MnKVxuICAgICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5pbmNsdWRlcygncm90YXRpbmdfdGV4dCcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mIzM5Oy9nLCBcIidcIilcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGVjb2RlZClcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZC5yb3RhdGluZ190ZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvdGF0aW5nVGV4dCA9IHBhcnNlZC5yb3RhdGluZ190ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW5nVGV4dC5pbmNsdWRlcygnVGhpbmsgQmlnJykpIHtcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW5nVGV4dCA9IHJvdGF0aW5nVGV4dC5yZXBsYWNlKC9UaGluayBCaWdbXFxzXFxuXSpQbGFuIFNtYXJ0W1xcc1xcbl0qRXhlY3V0ZSBGbGF3bGVzc2x5L2dpLCAnRHJlYW0gQmlnXFxuU3RyYXRlZ2l6ZSBXaXNlbHlcXG5EZWxpdmVyIEV4Y2VsbGVuY2UnKVxuICAgICAgICAgICAgICAgICAgcGFyc2VkLnJvdGF0aW5nX3RleHQgPSByb3RhdGluZ1RleHRcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgY29uc3QgZml4ZWRKc29uID0gSlNPTi5zdHJpbmdpZnkocGFyc2VkKVxuICAgICAgICAgICAgICAgICAgY29uc3QgcmVFbmNvZGVkID0gZml4ZWRKc29uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7JylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zZXR0aW5ncycsIHJlRW5jb2RlZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gU2lsZW50bHkgY29udGludWUgaWYgSlNPTiBwYXJzaW5nIGZhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRlbXBEaXYuaW5uZXJIVE1MXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGhvbWVwYWdlIChieSBjaGVja2luZyBVUkwgb3Igc3BlY2lmaWMgaG9tZXBhZ2UgY29udGVudClcbiAgICAgIGNvbnN0IGlzSG9tZXBhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9PT0gJy8nIHx8IFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPT09ICcnIHx8XG4gICAgICAgIGJvZHlIdG1sLmluY2x1ZGVzKCdHZXQgYSBUYWlsb3JlZCBBcHByb2FjaCcpIHx8XG4gICAgICAgIGJvZHlIdG1sLmluY2x1ZGVzKCdXZWxjb21lIHRvJykgJiYgYm9keUh0bWwuaW5jbHVkZXMoJ0JyZWFraW5nIFRocm91Z2gnKVxuICAgICAgKVxuICAgICAgXG4gICAgICAvLyBPbmx5IG1vZGlmeSBoZWFkaW5ncyBvbiBob21lcGFnZVxuICAgICAgaWYgKGlzSG9tZXBhZ2UpIHtcbiAgICAgICAgY2xlYW5lZEh0bWwgPSBtb2RpZnlIb21lcGFnZUhlYWRpbmdzKGNsZWFuZWRIdG1sKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGSU5BTCBTQUZFVFkgQ0hFQ0s6IE9uZSBtb3JlIHBhc3MgdG8gY2F0Y2ggYW55IHJlbWFpbmluZyAvYXNzZXRzL1JpbWFsd2ViLm5ldCBVUkxzXG4gICAgICAvLyBUaGlzIGlzIGNyaXRpY2FsIGFzIHNvbWUgVVJMcyBtaWdodCBoYXZlIGJlZW4gbWlzc2VkIGluIHByZXZpb3VzIHN0ZXBzXG4gICAgICBjbGVhbmVkSHRtbCA9IGNsZWFuZWRIdG1sLnJlcGxhY2UoL1xcL2Fzc2V0c1xcL1tScl1pbWFsW1d3XT9lYlxcLm5ldF8vZ2ksICcvYXNzZXRzL2FsbHVyZWRpZ2l0YWwubmV0XycpXG4gICAgICBcbiAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LmlubmVySFRNTCA9IGNsZWFuZWRIdG1sXG4gICAgICBcbiAgICAgIC8vIEZpeCBsb2dvIGNhcm91c2VsIHNsaWRlciBpbWFnZXMgLSBtYWtlIHRoZW0gc21hbGxlclxuICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5iZHQtbG9nby1jYXJvdXNlbC13cmFwcGVyIGltZywgLmJkdC1sb2dvLWNhcm91c2VsLWl0ZW0gaW1nLCAuYmR0LWxvZ28tY2Fyb3VzZWwtaW1nJykuZm9yRWFjaCgoaW1nKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW1nRWwgPSBpbWcgYXMgSFRNTEltYWdlRWxlbWVudFxuICAgICAgICAgIGltZ0VsLnN0eWxlLm1heFdpZHRoID0gJzIwMHB4J1xuICAgICAgICAgIGltZ0VsLnN0eWxlLm1heEhlaWdodCA9ICcxMDBweCdcbiAgICAgICAgICBpbWdFbC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgIGltZ0VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgIGltZ0VsLnN0eWxlLm9iamVjdEZpdCA9ICdjb250YWluJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaXggaG92ZXIgYm94IGltYWdlcyAtIGVuc3VyZSB0aGV5IHdvcmsgb24gaG92ZXJcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBob3ZlckJveGVzID0gY29udGFpbmVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvckFsbCgnLmJkdC1lcC1ob3Zlci1ib3gnKVxuICAgICAgICBob3ZlckJveGVzLmZvckVhY2goKGhvdmVyQm94KSA9PiB7XG4gICAgICAgICAgY29uc3QgaG92ZXJCb3hFbCA9IGhvdmVyQm94IGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgY29uc3QgaG92ZXJJdGVtcyA9IGhvdmVyQm94RWwucXVlcnlTZWxlY3RvckFsbCgnLmJkdC1lcC1ob3Zlci1ib3gtaXRlbScpXG4gICAgICAgICAgY29uc3QgaG92ZXJDb250ZW50cyA9IGhvdmVyQm94RWwucXVlcnlTZWxlY3RvckFsbCgnLmJkdC1lcC1ob3Zlci1ib3gtY29udGVudCcpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSAtIHNob3cgZmlyc3QgY29udGVudCBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKGhvdmVyQ29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaG92ZXJDb250ZW50cy5mb3JFYWNoKChjb250ZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50RWwgPSBjb250ZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5jbGFzc0xpc3QuYWRkKCdiZHQtYWN0aXZlJylcbiAgICAgICAgICAgICAgICBjb250ZW50RWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLnpJbmRleCA9ICcxMCdcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgZmlyc3QgaW1hZ2UgaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCcuYmR0LWVwLWhvdmVyLWJveC1pbWcnKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgaW1nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInXG4gICAgICAgICAgICAgICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2JkdC1hY3RpdmUnKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLnpJbmRleCA9ICcxJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2hvdyBob3ZlciBjb250ZW50IGJ5IGRhdGEtaWRcbiAgICAgICAgICBjb25zdCBzaG93SG92ZXJDb250ZW50ID0gKGRhdGFJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBIaWRlIGFsbCBjb250ZW50cyBmaXJzdFxuICAgICAgICAgICAgaG92ZXJDb250ZW50cy5mb3JFYWNoKChjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGNvbnRlbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2JkdC1hY3RpdmUnKVxuICAgICAgICAgICAgICBjb250ZW50RWwuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgICAgICAgICBjb250ZW50RWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS56SW5kZXggPSAnMSdcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEhpZGUgaW1hZ2VzIGluc2lkZVxuICAgICAgICAgICAgICBjb25zdCBpbWcgPSBjb250ZW50RWwucXVlcnlTZWxlY3RvcignLmJkdC1lcC1ob3Zlci1ib3gtaW1nJykgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgICAgIGltZy5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIGltZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3cgY29ycmVzcG9uZGluZyBjb250ZW50XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRDb250ZW50ID0gaG92ZXJCb3hFbC5xdWVyeVNlbGVjdG9yKGAjJHtkYXRhSWR9YCkgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIGlmICh0YXJnZXRDb250ZW50KSB7XG4gICAgICAgICAgICAgIHRhcmdldENvbnRlbnQuY2xhc3NMaXN0LmFkZCgnYmR0LWFjdGl2ZScpXG4gICAgICAgICAgICAgIHRhcmdldENvbnRlbnQuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICB0YXJnZXRDb250ZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgdGFyZ2V0Q29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICB0YXJnZXRDb250ZW50LnN0eWxlLnpJbmRleCA9ICcxMCdcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgaW1hZ2UgaW5zaWRlIGlzIHZpc2libGUgYW5kIGxvYWRlZFxuICAgICAgICAgICAgICBjb25zdCBpbWcgPSB0YXJnZXRDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJy5iZHQtZXAtaG92ZXItYm94LWltZycpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYmFja2dyb3VuZCBpbWFnZSBVUkwgZnJvbSBzdHlsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZUF0dHIgPSBpbWcuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnXG4gICAgICAgICAgICAgICAgY29uc3QgYmdNYXRjaCA9IHN0eWxlQXR0ci5tYXRjaCgvYmFja2dyb3VuZC1pbWFnZTpcXHMqdXJsXFwoWydcIl0/KFteJ1wiKV0rKVsnXCJdP1xcKS9pKVxuICAgICAgICAgICAgICAgIGxldCBpbWdVcmwgPSBiZ01hdGNoID8gYmdNYXRjaFsxXSA6IG51bGxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBVUkwgaW4gc3R5bGUsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWdVcmwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcpXG4gICAgICAgICAgICAgICAgICBjb25zdCBiZ0ltYWdlID0gY29tcHV0ZWRTdHlsZS5iYWNrZ3JvdW5kSW1hZ2VcbiAgICAgICAgICAgICAgICAgIGlmIChiZ0ltYWdlICYmIGJnSW1hZ2UgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxNYXRjaCA9IGJnSW1hZ2UubWF0Y2goL3VybFxcKFsnXCJdPyhbXidcIildKylbJ1wiXT9cXCkvaSlcbiAgICAgICAgICAgICAgICAgICAgaW1nVXJsID0gdXJsTWF0Y2ggPyB1cmxNYXRjaFsxXSA6IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU2V0IGltYWdlIHN0eWxlc1xuICAgICAgICAgICAgICAgIGltZy5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInXG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICdjZW50ZXInXG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBVUkwsIGVuc3VyZSBpdCdzIGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpbWdVcmwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZpeCBVUkwgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IEFsd2F5cyBjb252ZXJ0IHJpbWFsd2ViLm5ldCB0byBhbGx1cmVkaWdpdGFsLm5ldCBmb3IgYXNzZXQgZmlsZW5hbWUgbG9va3VwXG4gICAgICAgICAgICAgICAgICBsZXQgZml4ZWRVcmwgPSBpbWdVcmxcbiAgICAgICAgICAgICAgICAgIGlmIChpbWdVcmwgJiYgKC9hbGx1cmVkaWdpdGFsXFwubmV0L2kudGVzdChpbWdVcmwpIHx8IC9yaW1hbHdlYlxcLm5ldC9pLnRlc3QoaW1nVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQUxXQVlTIGNvbnZlcnQgcmltYWx3ZWIubmV0IChhbnkgY2FzZSkgdG8gYWxsdXJlZGlnaXRhbC5uZXQgLSBhc3NldCBmaWxlcyB1c2UgYWxsdXJlZGlnaXRhbC5uZXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybFRvRml4ID0gaW1nVXJsXG4gICAgICAgICAgICAgICAgICAgIGlmICgvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KGltZ1VybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB1cmxUb0ZpeCA9IGltZ1VybC5yZXBsYWNlKC9yaW1hbHdlYlxcLm5ldC9naSwgJ2FsbHVyZWRpZ2l0YWwubmV0JylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXhlZFVybCA9IGZpeEFzc2V0VXJsKHVybFRvRml4KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBTZXQgYmFja2dyb3VuZCBpbWFnZVxuICAgICAgICAgICAgICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7Zml4ZWRVcmx9JylgXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFByZWxvYWQgdG8gZW5zdXJlIGl0J3MgbG9hZGVkXG4gICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgICAgIHRlc3RJbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2ZpeGVkVXJsfScpYFxuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGVzdEltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB3aXRob3V0IHNpemUgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsdFVybCA9IGZpeGVkVXJsLnJlcGxhY2UoLy1cXGQreFxcZCsoXFwuW2Etel0rKSQvaSwgJyQxJylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdFVybCAhPT0gZml4ZWRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHthbHRVcmx9JylgXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx0VGVzdEltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgICAgICAgICAgICAgYWx0VGVzdEltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2FsdFVybH0nKWBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYWx0VGVzdEltZy5zcmMgPSBhbHRVcmxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGVzdEltZy5zcmMgPSBmaXhlZFVybFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgaG92ZXIgZXZlbnQgbGlzdGVuZXJzIHRvIEFMTCBpdGVtcyAoYWxsIDUgc2VydmljZXMpXG4gICAgICAgICAgLy8gU2VydmljZXM6IGJkdC1ib3gtMTBlODU4NTcsIGJkdC1ib3gtMjBlODU4NTcsIGJkdC1ib3gtMzBlODU4NTcsIGJkdC1ib3gtNDBlODU4NTcsIGJkdC1ib3gtNTBlODU4NTdcbiAgICAgICAgICBob3Zlckl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRWwgPSBpdGVtIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICBjb25zdCBkYXRhSWQgPSBpdGVtRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRhdGFJZCkge1xuICAgICAgICAgICAgICAvLyBDcmVhdGUgaG92ZXIgaGFuZGxlciBmdW5jdGlvbiBmb3IgdGhpcyBzcGVjaWZpYyBpdGVtXG4gICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUhvdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNob3dIb3ZlckNvbnRlbnQoZGF0YUlkKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBZGQgaG92ZXIgdG8gaXRlbSBpdHNlbGZcbiAgICAgICAgICAgICAgaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBoYW5kbGVIb3ZlcilcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGl0ZW1FbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgaG92ZXJlZCBjb250ZW50IHZpc2libGUgd2hlbiBtb3VzZSBsZWF2ZXMgaXRlbVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQWRkIGhvdmVyIHRvIEFMTCB0aXRsZSBsaW5rcyBpbnNpZGUgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGxpbmtzIHdvcms6IC5iZHQtZXAtaG92ZXItYm94LXRpdGxlLWxpbmssIC5iZHQtZXAtaG92ZXItYm94LXRpdGxlLCBhLCBoMlxuICAgICAgICAgICAgICBjb25zdCB0aXRsZUxpbmtzID0gaXRlbUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5iZHQtZXAtaG92ZXItYm94LXRpdGxlLWxpbmssIC5iZHQtZXAtaG92ZXItYm94LXRpdGxlLCBhLCBoMiwgLmVwLXRpdGxlJylcbiAgICAgICAgICAgICAgdGl0bGVMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua0VsID0gbGluayBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIEFkZCBtdWx0aXBsZSBldmVudCB0eXBlcyB0byBlbnN1cmUgaG92ZXIgd29ya3Mgb24gYWxsIGxpbmtzXG4gICAgICAgICAgICAgICAgbGlua0VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICAgICAgaGFuZGxlSG92ZXIoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgbGlua0VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgICBoYW5kbGVIb3ZlcigpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBsaW5rRWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICAgICAgaGFuZGxlSG92ZXIoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVc2UgZXZlbnQgZGVsZWdhdGlvbiBvbiBpdGVtIC0gY2FwdHVyZSBwaGFzZSB0byBjYXRjaCBhbGwgY2hpbGQgZXZlbnRzXG4gICAgICAgICAgICAgIGl0ZW1FbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIb3ZlcigpXG4gICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpdGVtRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIb3ZlcigpXG4gICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBZGQgaG92ZXIgdG8gcGFyZW50IHdyYXBwZXIgaWYgZXhpc3RzXG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW1XcmFwID0gaXRlbUVsLmNsb3Nlc3QoJy5iZHQtZXAtaG92ZXItYm94LWl0ZW0td3JhcCcpXG4gICAgICAgICAgICAgIGlmIChpdGVtV3JhcCAmJiBpdGVtV3JhcCAhPT0gaXRlbUVsKSB7XG4gICAgICAgICAgICAgICAgaXRlbVdyYXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGhhbmRsZUhvdmVyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBbHNvIGhhbmRsZSBkaXJlY3QgaG92ZXIgb24gYW55IGNoaWxkIGVsZW1lbnRcbiAgICAgICAgICAgICAgaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBoYW5kbGVIb3ZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gaGFuZGxlIGhvdmVyIGJveCBjb250YWluZXIgbW91c2UgbGVhdmVcbiAgICAgICAgICBob3ZlckJveEVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZXNldCB0byBmaXJzdCBjb250ZW50IHdoZW4gbW91c2UgbGVhdmVzIHRoZSBlbnRpcmUgaG92ZXIgYm94XG4gICAgICAgICAgICBpZiAoaG92ZXJDb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGhvdmVyQ29udGVudHMuZm9yRWFjaCgoY29udGVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50RWwgPSBjb250ZW50IGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50RWwuY2xhc3NMaXN0LmFkZCgnYmR0LWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICBjb250ZW50RWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLnpJbmRleCA9ICcxMCdcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGZpcnN0IGltYWdlIGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCcuYmR0LWVwLWhvdmVyLWJveC1pbWcnKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2JkdC1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJlbG9hZCBBTEwgaG92ZXIgYm94IGltYWdlcyB0byBlbnN1cmUgdGhleSdyZSByZWFkeVxuICAgICAgICAgIGhvdmVyQ29udGVudHMuZm9yRWFjaCgoY29udGVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEVsID0gY29udGVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgY29uc3QgaW1nID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoJy5iZHQtZXAtaG92ZXItYm94LWltZycpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICBpZiAoaW1nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gaW1nLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJ1xuICAgICAgICAgICAgICBjb25zdCBiZ01hdGNoID0gc3R5bGUubWF0Y2goL2JhY2tncm91bmQtaW1hZ2U6XFxzKnVybFxcKFsnXCJdPyhbXidcIildKylbJ1wiXT9cXCkvaSlcbiAgICAgICAgICAgICAgaWYgKGJnTWF0Y2ggJiYgYmdNYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGxldCBpbWdVcmwgPSBiZ01hdGNoWzFdXG4gICAgICAgICAgICAgICAgLy8gRml4IFVSTCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IEFsd2F5cyBjb252ZXJ0IHJpbWFsd2ViLm5ldCAoYW55IGNhc2UpIHRvIGFsbHVyZWRpZ2l0YWwubmV0IGZvciBhc3NldCBmaWxlbmFtZSBsb29rdXBcbiAgICAgICAgICAgICAgICBpZiAoaW1nVXJsICYmICgvYWxsdXJlZGlnaXRhbFxcLm5ldC9pLnRlc3QoaW1nVXJsKSB8fCAvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KGltZ1VybCkpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBTFdBWVMgY29udmVydCByaW1hbHdlYi5uZXQgKGFueSBjYXNlKSB0byBhbGx1cmVkaWdpdGFsLm5ldCAtIGFzc2V0IGZpbGVzIHVzZSBhbGx1cmVkaWdpdGFsLm5ldFxuICAgICAgICAgICAgICAgICAgbGV0IHVybFRvRml4ID0gaW1nVXJsXG4gICAgICAgICAgICAgICAgICBpZiAoL3JpbWFsd2ViXFwubmV0L2kudGVzdChpbWdVcmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybFRvRml4ID0gaW1nVXJsLnJlcGxhY2UoL3JpbWFsd2ViXFwubmV0L2dpLCAnYWxsdXJlZGlnaXRhbC5uZXQnKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW1nVXJsID0gZml4QXNzZXRVcmwodXJsVG9GaXgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFByZWxvYWQgaW1hZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkSW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgICBwcmVsb2FkSW1nLnNyYyA9IGltZ1VybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRml4IGhlYWRlciBhbmQgbmF2YmFyIHdpZHRoIGlzc3VlcyAtIGVuc3VyZSBmdWxsIHdpZHRoXG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gRml4IHN0aWNreSBoZWFkZXIgc2VjdGlvbnMgLSBtYWtlIHRoZW0gZnVsbCB3aWR0aFxuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLXN0aWNreSwgLmVsZW1lbnRvci1zdGlja3ktLWFjdGl2ZSwgLmVsZW1lbnRvci1zdGlja3lfX3NwYWNlcicpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgaHRtbEVsID0gZWwgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAvLyBSZW1vdmUgZml4ZWQgd2lkdGggYW5kIHNldCB0byAxMDAlXG4gICAgICAgICAgaHRtbEVsLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgaHRtbEVsLnN0eWxlLm1heFdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgaHRtbEVsLnN0eWxlLmxlZnQgPSAnMCdcbiAgICAgICAgICBodG1sRWwuc3R5bGUucmlnaHQgPSAnMCdcbiAgICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHBvc2l0aW9uaW5nXG4gICAgICAgICAgaWYgKGh0bWxFbC5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBodG1sRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdlbGVtZW50b3Itc3RpY2t5LS1hY3RpdmUnKSkge1xuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnRvcCA9ICcwJ1xuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnpJbmRleCA9ICc5OTk5J1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEZpeCBoZWFkZXIgY29udGFpbmVyIHdpZHRoXG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2hlYWRlcltkYXRhLWVsZW1lbnRvci10eXBlPVwiaGVhZGVyXCJdJykuZm9yRWFjaCgoaGVhZGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgaGVhZGVyRWwgPSBoZWFkZXIgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICBoZWFkZXJFbC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgIGhlYWRlckVsLnN0eWxlLm1heFdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgaGVhZGVyRWwuc3R5bGUubGVmdCA9ICcwJ1xuICAgICAgICAgIGhlYWRlckVsLnN0eWxlLnJpZ2h0ID0gJzAnXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBGaXggdG9wIGJhbm5lciBzZWN0aW9uIChibGFjayBzZWN0aW9uKSAtIGVuc3VyZSBmdWxsIHdpZHRoXG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5lbGVtZW50b3ItZWxlbWVudC1hNmRlNmEyLCBbZGF0YS1pZD1cImE2ZGU2YTJcIl0nKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGh0bWxFbCA9IGVsIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgaHRtbEVsLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgaHRtbEVsLnN0eWxlLm1heFdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgaHRtbEVsLnN0eWxlLmxlZnQgPSAnMCdcbiAgICAgICAgICBodG1sRWwuc3R5bGUucmlnaHQgPSAnMCdcbiAgICAgICAgICAvLyBGaXggY29udGFpbmVyIGluc2lkZVxuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGh0bWxFbC5xdWVyeVNlbGVjdG9yKCcuZWxlbWVudG9yLWNvbnRhaW5lcicpXG4gICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSBjb250YWluZXIgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLnN0eWxlLm1heFdpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBjb250YWluZXJFbC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEZpeCBuYXZiYXIgc2VjdGlvbnMgLSBlbnN1cmUgZnVsbCB3aWR0aFxuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCdoZWFkZXIgLmVsZW1lbnRvci1zZWN0aW9uLCBoZWFkZXIgc2VjdGlvbicpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgaHRtbEVsID0gZWwgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAvLyBPbmx5IGZpeCBpZiBpdCdzIGEgc3RpY2t5IG9yIGhlYWRlciBzZWN0aW9uXG4gICAgICAgICAgaWYgKGh0bWxFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2VsZW1lbnRvci1zdGlja3knKSB8fCBcbiAgICAgICAgICAgICAgaHRtbEVsLmNsb3Nlc3QoJ2hlYWRlcicpICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgIGh0bWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZWxlbWVudG9yLXR5cGUnKSA9PT0gJ3NlY3Rpb24nKSB7XG4gICAgICAgICAgICBodG1sRWwuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5tYXhXaWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLmxlZnQgPSAnMCdcbiAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5yaWdodCA9ICcwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBnbG9iYWwgQ1NTIHRvIGVuc3VyZSBoZWFkZXIgc2VjdGlvbnMgYXJlIGZ1bGwgd2lkdGhcbiAgICAgICAgY29uc3Qgc3R5bGVJZCA9ICdoZWFkZXItd2lkdGgtZml4J1xuICAgICAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlSWQpKSB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgICAgICAgc3R5bGUuaWQgPSBzdHlsZUlkXG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICAgICAgICAvKiBGaXggaGVhZGVyIGFuZCBuYXZiYXIgd2lkdGggaXNzdWVzICovXG4gICAgICAgICAgICBoZWFkZXJbZGF0YS1lbGVtZW50b3ItdHlwZT1cImhlYWRlclwiXSxcbiAgICAgICAgICAgIGhlYWRlciAuZWxlbWVudG9yLXN0aWNreSxcbiAgICAgICAgICAgIGhlYWRlciAuZWxlbWVudG9yLXN0aWNreS0tYWN0aXZlLFxuICAgICAgICAgICAgaGVhZGVyIC5lbGVtZW50b3Itc3RpY2t5X19zcGFjZXIsXG4gICAgICAgICAgICAuZWxlbWVudG9yLWVsZW1lbnQtYTZkZTZhMixcbiAgICAgICAgICAgIFtkYXRhLWlkPVwiYTZkZTZhMlwiXSB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIG1heC13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBsZWZ0OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHJpZ2h0OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEZpeCBzdGlja3kgaGVhZGVyIHBvc2l0aW9uaW5nICovXG4gICAgICAgICAgICAuZWxlbWVudG9yLXN0aWNreS0tYWN0aXZlIHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB6LWluZGV4OiA5OTk5ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIG1heC13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBGaXggaGVhZGVyIGNvbnRhaW5lciAqL1xuICAgICAgICAgICAgaGVhZGVyW2RhdGEtZWxlbWVudG9yLXR5cGU9XCJoZWFkZXJcIl0gLmVsZW1lbnRvci1jb250YWluZXIge1xuICAgICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogRW5zdXJlIGJvZHkgZG9lc24ndCBoYXZlIG92ZXJmbG93IGlzc3VlcyAqL1xuICAgICAgICAgICAgYm9keSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBGaXggbmF2YmFyIHdoZW4gc2Nyb2xsaW5nICovXG4gICAgICAgICAgICAuZWxlbWVudG9yLXN0aWNreS0tZWZmZWN0cyB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIG1heC13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBGaXggYWxsIGhlYWRlciBzZWN0aW9ucyB0byBiZSBmdWxsIHdpZHRoICovXG4gICAgICAgICAgICBoZWFkZXIgLmVsZW1lbnRvci1zZWN0aW9uIHtcbiAgICAgICAgICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbWF4LXdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEtlZXAgbmF2YmFyIGxvZ28gdmVyeSBzbWFsbCB0byBtYWludGFpbiBuYXZiYXIgaGVpZ2h0ICovXG4gICAgICAgICAgICBoZWFkZXIgaW1nW3NyYyo9XCIxLnBuZ1wiXSxcbiAgICAgICAgICAgIGhlYWRlciBpbWdbc3JjKj1cIi8xLnBuZ1wiXSxcbiAgICAgICAgICAgIGhlYWRlciAuZWxlbWVudG9yLXdpZGdldC1pbWFnZSBpbWcsXG4gICAgICAgICAgICBoZWFkZXIgW2NsYXNzKj1cImxvZ29cIl0gaW1nIHtcbiAgICAgICAgICAgICAgbWF4LWhlaWdodDogNDBweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBtYXgtd2lkdGg6IDE1MHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEVuc3VyZSBuYXZiYXIgZG9lc24ndCBleHBhbmQgZHVlIHRvIGxvZ28gKi9cbiAgICAgICAgICAgIGhlYWRlciAuZWxlbWVudG9yLXdpZGdldC1pbWFnZSB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXggIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlciAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBGaXggb2ZmY2FudmFzIG1lbnUgdG8gc2hvdyBwcm9wZXJseSBmcm9tIHJpZ2h0IHNpZGUgKi9cbiAgICAgICAgICAgIC5iZHQtb2ZmY2FudmFzIHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICByaWdodDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogNDAwcHggIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbWF4LXdpZHRoOiA5MHZ3ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogMTAwdmggIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB6LWluZGV4OiAxMDAwMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTAwJSkgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3MgZWFzZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvdmVyZmxvdy15OiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IC0ycHggMCAxMHB4IHJnYmEoMCwwLDAsMC4xKSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5iZHQtb2ZmY2FudmFzLmJkdC1vcGVuLFxuICAgICAgICAgICAgLmJkdC1vZmZjYW52YXNbYXJpYS1oaWRkZW49XCJmYWxzZVwiXSxcbiAgICAgICAgICAgIC5iZHQtb2ZmY2FudmFzW3N0eWxlKj1cImRpc3BsYXk6IGJsb2NrXCJdIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBIaWRlIG9mZmNhbnZhcyBieSBkZWZhdWx0IC0gb25seSBzaG93IHdoZW4gb3BlbmVkICovXG4gICAgICAgICAgICAuYmR0LW9mZmNhbnZhczpub3QoLmJkdC1vcGVuKTpub3QoW2FyaWEtaGlkZGVuPVwiZmFsc2VcIl0pIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmJkdC1vZmZjYW52YXMtYmFyIHtcbiAgICAgICAgICAgICAgcGFkZGluZzogMzBweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogT2ZmY2FudmFzIG92ZXJsYXkgKi9cbiAgICAgICAgICAgIC5iZHQtb2ZmY2FudmFzLXBhZ2U6OmJlZm9yZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6ICcnICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB0b3A6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbGVmdDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjUpICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHotaW5kZXg6IDk5OTkgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogT2ZmY2FudmFzIGJ1dHRvbiBzdHlsaW5nICovXG4gICAgICAgICAgICAuYmR0LW9mZmNhbnZhcy1idXR0b24ge1xuICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXggIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlciAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBFbnN1cmUgb2ZmY2FudmFzIGNvbnRlbnQgaXMgdmlzaWJsZSAqL1xuICAgICAgICAgICAgLmJkdC1vZmZjYW52YXMgLmVsZW1lbnRvci1zZWN0aW9uLFxuICAgICAgICAgICAgLmJkdC1vZmZjYW52YXMgLmVsZW1lbnRvci13aWRnZXQge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogRml4IGxvZ28gY2Fyb3VzZWwgc2xpZGVyIGltYWdlcyAtIG1ha2UgdGhlbSBzbWFsbGVyICovXG4gICAgICAgICAgICAuYmR0LWxvZ28tY2Fyb3VzZWwtd3JhcHBlciAuYmR0LWxvZ28tY2Fyb3VzZWwtaW1nLFxuICAgICAgICAgICAgLmJkdC1sb2dvLWNhcm91c2VsLWl0ZW0gaW1nLFxuICAgICAgICAgICAgLmJkdC1sb2dvLWNhcm91c2VsLWZpZ3VyZSBpbWcge1xuICAgICAgICAgICAgICBtYXgtd2lkdGg6IDIwMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIG1heC1oZWlnaHQ6IDEwMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5iZHQtbG9nby1jYXJvdXNlbC1pdGVtIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5iZHQtbG9nby1jYXJvdXNlbC1maWd1cmUge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEZpeCBob3ZlciBib3ggaW1hZ2VzIC0gZW5zdXJlIHRoZXkgYXJlIHZpc2libGUgb24gaG92ZXIgKi9cbiAgICAgICAgICAgIC5iZHQtZXAtaG92ZXItYm94IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5iZHQtZXAtaG92ZXItYm94LWltZyB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBFbnN1cmUgaG92ZXIgYm94IGltYWdlcyBkb24ndCBnZXQgcHVycGxlIGdyYWRpZW50IC0gb3ZlcnJpZGUgYW55IGdyYWRpZW50ICovXG4gICAgICAgICAgICAuYmR0LWVwLWhvdmVyLWJveC1pbWdbc3R5bGUqPVwibGluZWFyLWdyYWRpZW50XCJdIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmJkdC1lcC1ob3Zlci1ib3gtY29udGVudCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlLCB2aXNpYmlsaXR5IDAuM3MgZWFzZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgdG9wOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGxlZnQ6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHotaW5kZXg6IDEgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmJkdC1lcC1ob3Zlci1ib3gtY29udGVudC5iZHQtYWN0aXZlIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHotaW5kZXg6IDEwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5iZHQtZXAtaG92ZXItYm94LWNvbnRlbnQuYmR0LWFjdGl2ZSAuYmR0LWVwLWhvdmVyLWJveC1pbWcge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlciAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogRW5zdXJlIGhvdmVyIHdvcmtzIG9uIGFsbCBwYXJ0cyBvZiB0aGUgc2VydmljZSBpdGVtICovXG4gICAgICAgICAgICAuYmR0LWVwLWhvdmVyLWJveC1pdGVtLFxuICAgICAgICAgICAgLmJkdC1lcC1ob3Zlci1ib3gtaXRlbSAqLFxuICAgICAgICAgICAgLmJkdC1lcC1ob3Zlci1ib3gtdGl0bGUsXG4gICAgICAgICAgICAuYmR0LWVwLWhvdmVyLWJveC10aXRsZS1saW5rIHtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5iZHQtZXAtaG92ZXItYm94LWl0ZW06aG92ZXIsXG4gICAgICAgICAgICAuYmR0LWVwLWhvdmVyLWJveC10aXRsZTpob3ZlcixcbiAgICAgICAgICAgIC5iZHQtZXAtaG92ZXItYm94LXRpdGxlLWxpbms6aG92ZXIge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIE1ha2Ugc3VyZSBob3ZlciBpdGVtcyB0cmlnZ2VyIGltYWdlIGNoYW5nZSAqL1xuICAgICAgICAgICAgLmJkdC1lcC1ob3Zlci1ib3gtaXRlbS13cmFwIHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHotaW5kZXg6IDEwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEhlcm8gU2VjdGlvbiBBbmltYXRpb25zIC0gRW5zdXJlIGFuaW1hdGlvbnMgd29yayBwcm9wZXJseSAqL1xuICAgICAgICAgICAgLmFuaW1hdGVkLWZhc3QsXG4gICAgICAgICAgICAuYW5pbWF0ZWQtc2xvdyxcbiAgICAgICAgICAgIC5hbmltYXRlZCxcbiAgICAgICAgICAgIC5lbGVtZW50b3ItaW52aXNpYmxlIHtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBTbGlkZUluVXAgQW5pbWF0aW9uICovXG4gICAgICAgICAgICBAa2V5ZnJhbWVzIHNsaWRlSW5VcCB7XG4gICAgICAgICAgICAgIGZyb20ge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCA0MHB4LCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0byB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5hbmltYXRlZC1zbGlkZUluVXAsXG4gICAgICAgICAgICAuYW5pbWF0ZWQtZmFzdC5hbmltYXRlZC5zbGlkZUluVXAsXG4gICAgICAgICAgICAuYW5pbWF0ZWQtc2xvdy5hbmltYXRlZC5mYWRlSW5MZWZ0IHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmFuaW1hdGVkLWZhc3Qge1xuICAgICAgICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IDAuNnMgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmFuaW1hdGVkLXNsb3cge1xuICAgICAgICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IDFzICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5lbGVtZW50b3Itd2lkZ2V0W2RhdGEtc2V0dGluZ3MqPVwiX2FuaW1hdGlvblwiXTpub3QoLmVsZW1lbnRvci1pbnZpc2libGUpLFxuICAgICAgICAgICAgLmVsZW1lbnRvci13aWRnZXQuYW5pbWF0ZWQtZmFzdDpub3QoLmVsZW1lbnRvci1pbnZpc2libGUpLFxuICAgICAgICAgICAgLmVsZW1lbnRvci13aWRnZXQuYW5pbWF0ZWQtc2xvdzpub3QoLmVsZW1lbnRvci1pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEZhZGVJbkxlZnQgQW5pbWF0aW9uICovXG4gICAgICAgICAgICBAa2V5ZnJhbWVzIGZhZGVJbkxlZnQge1xuICAgICAgICAgICAgICBmcm9tIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTQwcHgsIDAsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogRmFkZUluVXAgQW5pbWF0aW9uICovXG4gICAgICAgICAgICBAa2V5ZnJhbWVzIGZhZGVJblVwIHtcbiAgICAgICAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDQwcHgsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmFuaW1hdGVkLWZhZGVJbkxlZnQge1xuICAgICAgICAgICAgICBhbmltYXRpb24tbmFtZTogZmFkZUluTGVmdDtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmFuaW1hdGVkLWZhZGVJblVwIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGZhZGVJblVwO1xuICAgICAgICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBBbmltYXRlZCBIZWFkbGluZSAtIFJvdGF0aW5nIFRleHQgKi9cbiAgICAgICAgICAgIC5lbGVtZW50b3ItaGVhZGxpbmUge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgICAgIG1hcmdpbi10b3A6IDE1cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgcGFkZGluZy10b3A6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAuZWxlbWVudG9yLWhlYWRsaW5lLXRleHQtd3JhcHBlciB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBtaW4td2lkdGg6IGZpdC1jb250ZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXAgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLmVsZW1lbnRvci1oZWFkbGluZS1keW5hbWljLXRleHQge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAuZWxlbWVudG9yLWhlYWRsaW5lLXRleHQtYWN0aXZlIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5lbGVtZW50b3ItaGVhZGxpbmUtZHluYW1pYy13cmFwcGVyIHtcbiAgICAgICAgICAgICAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbWluLXdpZHRoOiBmaXQtY29udGVudCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEFkZCBzcGFjaW5nIHRvIGFuaW1hdGVkIGhlYWRsaW5lIHdpZGdldCBjb250YWluZXIgKi9cbiAgICAgICAgICAgIC5lbGVtZW50b3Itd2lkZ2V0LWFuaW1hdGVkLWhlYWRsaW5lIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogMTVweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAuZWxlbWVudG9yLXdpZGdldC1hbmltYXRlZC1oZWFkbGluZSAuZWxlbWVudG9yLXdpZGdldC1jb250YWluZXIge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAxNXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEhlcm8gU2VjdGlvbiBGb250cyAqL1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC5lbGVtZW50b3ItaGVhZGluZy10aXRsZSxcbiAgICAgICAgICAgIC5lbGVtZW50b3Itd2lkZ2V0LWhlYWRpbmcgLmVsZW1lbnRvci1oZWFkaW5nLXRpdGxlLFxuICAgICAgICAgICAgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiB7XG4gICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAnTW9udHNlcnJhdCcsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBzYW5zLXNlcmlmICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5lbGVtZW50b3ItaGVhZGxpbmUsXG4gICAgICAgICAgICAuZWxlbWVudG9yLWhlYWRsaW5lLWR5bmFtaWMtdGV4dCB7XG4gICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAnTW9udHNlcnJhdCcsIHNhbnMtc2VyaWYgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogRW5zdXJlIFBvcHBpbnMgaXMgdXNlZCB3aGVyZSBzcGVjaWZpZWQgKi9cbiAgICAgICAgICAgIFtzdHlsZSo9XCJmb250LWZhbWlseTogUG9wcGluc1wiXSxcbiAgICAgICAgICAgIFtzdHlsZSo9XCJmb250LWZhbWlseTogJ1BvcHBpbnMnXCJdLFxuICAgICAgICAgICAgW3N0eWxlKj1cIlBvcHBpbnMtQm9sZFwiXSxcbiAgICAgICAgICAgIFtzdHlsZSo9XCJQb3BwaW5zLVNlbWlCb2xkXCJdIHtcbiAgICAgICAgICAgICAgZm9udC1mYW1pbHk6ICdQb3BwaW5zJywgc2Fucy1zZXJpZiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBIZXJvIFNlY3Rpb24gU2xpZGVzaG93IC0gRW5zdXJlIG9ubHkgb25lIHNsaWRlIGlzIHZpc2libGUgYXQgYSB0aW1lICovXG4gICAgICAgICAgICAuZWxlbWVudG9yLWJhY2tncm91bmQtc2xpZGVzaG93IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBsZWZ0OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB6LWluZGV4OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC5lbGVtZW50b3ItYmFja2dyb3VuZC1zbGlkZXNob3cgLnN3aXBlci13cmFwcGVyIHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAuZWxlbWVudG9yLWJhY2tncm91bmQtc2xpZGVzaG93X19zbGlkZSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB0b3A6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbGVmdDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDEuOHMgZWFzZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBPbmx5IGFjdGl2ZS92aXNpYmxlIHNsaWRlcyBzaG91bGQgYmUgdmlzaWJsZSAqL1xuICAgICAgICAgICAgLmVsZW1lbnRvci1iYWNrZ3JvdW5kLXNsaWRlc2hvd19fc2xpZGUuc3dpcGVyLXNsaWRlLWFjdGl2ZSxcbiAgICAgICAgICAgIC5lbGVtZW50b3ItYmFja2dyb3VuZC1zbGlkZXNob3dfX3NsaWRlLnN3aXBlci1zbGlkZS12aXNpYmxlIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB6LWluZGV4OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEhpZGUgZHVwbGljYXRlIHNsaWRlcyBidXQga2VlcCB0aGVtIGZvciBsb29wICovXG4gICAgICAgICAgICAuZWxlbWVudG9yLWJhY2tncm91bmQtc2xpZGVzaG93X19zbGlkZS5zd2lwZXItc2xpZGUtZHVwbGljYXRlIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDsgLyogS2VlcCBkaXNwbGF5IGZvciBsb29wICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEVuc3VyZSBzbGlkZSBpbWFnZXMgZmlsbCBwcm9wZXJseSAqL1xuICAgICAgICAgICAgLmVsZW1lbnRvci1iYWNrZ3JvdW5kLXNsaWRlc2hvd19fc2xpZGVfX2ltYWdlIHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBsZWZ0OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIEhpZGUgcGhvbmUgYW5kIGVtYWlsIGluIGhlcm8gc2VjdGlvbiAqL1xuICAgICAgICAgICAgW2RhdGEtaWQ9XCI4MjEwNWE0XCJdIC5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW0sXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjE1MzcxZTVcIl0gLmVsZW1lbnRvci1pY29uLWxpc3QtaXRlbSB7XG4gICAgICAgICAgICAgIC8qIEhpZGUgaXRlbXMgY29udGFpbmluZyBwaG9uZSBvciBlbWFpbCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjgyMTA1YTRcIl0gLmVsZW1lbnRvci1pY29uLWxpc3QtaXRlbTpoYXMoYVtocmVmKj1cInRlbDpcIl0pLFxuICAgICAgICAgICAgW2RhdGEtaWQ9XCIxNTM3MWU1XCJdIC5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW06aGFzKGFbaHJlZio9XCJ0ZWw6XCJdKSxcbiAgICAgICAgICAgIFtkYXRhLWlkPVwiODIxMDVhNFwiXSAuZWxlbWVudG9yLWljb24tbGlzdC1pdGVtOmhhcyhhW2hyZWYqPVwibWFpbHRvOlwiXSksXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjE1MzcxZTVcIl0gLmVsZW1lbnRvci1pY29uLWxpc3QtaXRlbTpoYXMoYVtocmVmKj1cIm1haWx0bzpcIl0pIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBoZWlnaHQ6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBIaWRlIGljb24gbGlzdCB3aWRnZXRzIHRoYXQgY29udGFpbiBvbmx5IHBob25lL2VtYWlsICovXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjgyMTA1YTRcIl0gLmVsZW1lbnRvci1pY29uLWxpc3Q6aGFzKC5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW06b25seS1jaGlsZCBhW2hyZWYqPVwidGVsOlwiXSksXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjE1MzcxZTVcIl0gLmVsZW1lbnRvci1pY29uLWxpc3Q6aGFzKC5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW06b25seS1jaGlsZCBhW2hyZWYqPVwidGVsOlwiXSksXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjgyMTA1YTRcIl0gLmVsZW1lbnRvci1pY29uLWxpc3Q6aGFzKC5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW06b25seS1jaGlsZCBhW2hyZWYqPVwibWFpbHRvOlwiXSksXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjE1MzcxZTVcIl0gLmVsZW1lbnRvci1pY29uLWxpc3Q6aGFzKC5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW06b25seS1jaGlsZCBhW2hyZWYqPVwibWFpbHRvOlwiXSkge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIGhlaWdodDogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvKiBIaWRlIHNwZWNpZmljIHdpZGdldCBJRHMgdGhhdCBtaWdodCBjb250YWluIHBob25lL2VtYWlsICovXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjgyMTA1YTRcIl0gW2RhdGEtaWQ9XCIwZDVlMzA0XCJdLFxuICAgICAgICAgICAgW2RhdGEtaWQ9XCI4MjEwNWE0XCJdIFtkYXRhLWlkPVwiYzA2ZjljNFwiXSxcbiAgICAgICAgICAgIFtkYXRhLWlkPVwiMTUzNzFlNVwiXSBbZGF0YS1pZD1cIjBkNWUzMDRcIl0sXG4gICAgICAgICAgICBbZGF0YS1pZD1cIjE1MzcxZTVcIl0gW2RhdGEtaWQ9XCJjMDZmOWM0XCJdIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICBoZWlnaHQ6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgXG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHNjcm9sbCBsaXN0ZW5lciB0byBjb250aW51b3VzbHkgZml4IHdpZHRoIG9uIHNjcm9sbFxuICAgICAgICBjb25zdCBmaXhIZWFkZXJXaWR0aCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaXggYWxsIHN0aWNreSBlbGVtZW50cyBvbiBzY3JvbGxcbiAgICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLXN0aWNreSwgLmVsZW1lbnRvci1zdGlja3ktLWFjdGl2ZSwgLmVsZW1lbnRvci1zdGlja3lfX3NwYWNlcicpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sRWwgPSBlbCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgaHRtbEVsLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICBodG1sRWwuc3R5bGUubWF4V2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgICAgICAgICBodG1sRWwuc3R5bGUucmlnaHQgPSAnMCdcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpeCBoZWFkZXIgc2VjdGlvbnNcbiAgICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCdoZWFkZXIgLmVsZW1lbnRvci1zZWN0aW9uJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWxFbCA9IGVsIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICBodG1sRWwuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5tYXhXaWR0aCA9ICcxMDAlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJ1biBvbiBzY3JvbGwgd2l0aCB0aHJvdHRsaW5nXG4gICAgICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudCkgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudClcbiAgICAgICAgICBzY3JvbGxUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZpeEhlYWRlcldpZHRoLCAxMClcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsSGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHJ1biBvbiByZXNpemVcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZpeEhlYWRlcldpZHRoLCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIGNsZWFudXAgZnVuY3Rpb24gaW4gcmVmXG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsSGFuZGxlcilcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZml4SGVhZGVyV2lkdGgpXG4gICAgICAgICAgaWYgKHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudClcbiAgICAgICAgICAgIHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgICAvLyBJbml0aWFsaXplIEhlcm8gU2VjdGlvbiBBbmltYXRpb25zXG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50b3ItaW52aXNpYmxlIGZyb20gaGVybyBzZWN0aW9uIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgaGVyb1NlY3Rpb25zID0gY29udGFpbmVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaWQ9XCI4MjEwNWE0XCJdLCBbZGF0YS1pZD1cIjE1MzcxZTVcIl0nKVxuICAgICAgICAgIGhlcm9TZWN0aW9ucy5mb3JFYWNoKChoZXJvU2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gSGlkZSBwaG9uZSBhbmQgZW1haWwgaWNvbiBsaXN0cyBpbiBoZXJvIHNlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHBob25lRW1haWxFbGVtZW50cyA9IGhlcm9TZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5lbGVtZW50b3ItaWNvbi1saXN0LWl0ZW0nKVxuICAgICAgICAgICAgcGhvbmVFbWFpbEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGh0bWxFbCA9IGVsIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBodG1sRWwudGV4dENvbnRlbnQgfHwgJydcbiAgICAgICAgICAgICAgLy8gSGlkZSBpZiBjb250YWlucyBwaG9uZSBudW1iZXIgb3IgZW1haWxcbiAgICAgICAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJygyMTIpJykgfHwgdGV4dC5pbmNsdWRlcygnMzAxLTc2MTUnKSB8fCB0ZXh0LmluY2x1ZGVzKCdAJykgfHwgdGV4dC5pbmNsdWRlcygndGVsOicpIHx8IHRleHQuaW5jbHVkZXMoJ21haWx0bzonKSkge1xuICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICAgICAgICAgICAgaHRtbEVsLnN0eWxlLmhlaWdodCA9ICcwJ1xuICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5tYXJnaW4gPSAnMCdcbiAgICAgICAgICAgICAgICBodG1sRWwuc3R5bGUucGFkZGluZyA9ICcwJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBbHNvIGhpZGUgcGFyZW50IGljb24tbGlzdCBjb250YWluZXJzIGlmIHRoZXkgb25seSBjb250YWluIHBob25lL2VtYWlsXG4gICAgICAgICAgICBjb25zdCBpY29uTGlzdHMgPSBoZXJvU2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLWljb24tbGlzdCcpXG4gICAgICAgICAgICBpY29uTGlzdHMuZm9yRWFjaCgoaWNvbkxpc3QpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGlzdEVsID0gaWNvbkxpc3QgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBsaXN0RWwucXVlcnlTZWxlY3RvckFsbCgnLmVsZW1lbnRvci1pY29uLWxpc3QtaXRlbScpXG4gICAgICAgICAgICAgIGxldCBhbGxIaWRkZW4gPSB0cnVlXG4gICAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtRWwgPSBpdGVtIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1FbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgIGFsbEhpZGRlbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBpZiAoYWxsSGlkZGVuICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaXN0RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgIGxpc3RFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICBsaXN0RWwuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgICAgICAgICAgIGxpc3RFbC5zdHlsZS5oZWlnaHQgPSAnMCdcbiAgICAgICAgICAgICAgICBsaXN0RWwuc3R5bGUubWFyZ2luID0gJzAnXG4gICAgICAgICAgICAgICAgbGlzdEVsLnN0eWxlLnBhZGRpbmcgPSAnMCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgICAgIGhlcm9TZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5lbGVtZW50b3ItaW52aXNpYmxlLCAuYW5pbWF0ZWQtZmFzdCwgLmFuaW1hdGVkLXNsb3csIC5hbmltYXRlZCcpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sRWwgPSBlbCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgaW52aXNpYmxlIGNsYXNzXG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdlbGVtZW50b3ItaW52aXNpYmxlJylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IGFuaW1hdGlvbiBzZXR0aW5nc1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBodG1sRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHRpbmdzJylcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRlY29kZWQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5fYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25UeXBlID0gcGFyc2VkLl9hbmltYXRpb25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5ID0gcGFyc2VkLl9hbmltYXRpb25fZGVsYXkgfHwgMFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBBcHBseSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBodG1sRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgICBodG1sRWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFuaW1hdGlvbiBjbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25UeXBlID09PSAnc2xpZGVJblVwJykge1xuICAgICAgICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5hbmltYXRpb24gPSBgc2xpZGVJblVwIDAuNnMgZWFzZS1vdXQgJHthbmltYXRpb25EZWxheX1tcyBib3RoYFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblR5cGUgPT09ICdmYWRlSW5MZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5hbmltYXRpb24gPSBgZmFkZUluTGVmdCAxcyBlYXNlLW91dCAke2FuaW1hdGlvbkRlbGF5fW1zIGJvdGhgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gJ2ZhZGVJblVwJykge1xuICAgICAgICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5hbmltYXRpb24gPSBgZmFkZUluVXAgMC42cyBlYXNlLW91dCAke2FuaW1hdGlvbkRlbGF5fW1zIGJvdGhgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIGFuaW1hdGlvbkRlbGF5KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBhbmltYXRpb24gZGVsYXksIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICBodG1sRWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIGp1c3QgbWFrZSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaHRtbEVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICBodG1sRWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBObyBzZXR0aW5ncywgbWFrZSB2aXNpYmxlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgIGh0bWxFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgQW5pbWF0ZWQgSGVhZGxpbmUgKHJvdGF0aW5nIHRleHQpIGZvciBoZXJvIHNlY3Rpb25cbiAgICAgICAgY29uc3QgYW5pbWF0ZWRIZWFkbGluZXMgPSBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLWhlYWRsaW5lJylcbiAgICAgICAgYW5pbWF0ZWRIZWFkbGluZXMuZm9yRWFjaCgoaGVhZGxpbmUpID0+IHtcbiAgICAgICAgICBjb25zdCBoZWFkbGluZUVsID0gaGVhZGxpbmUgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICBjb25zdCB3aWRnZXRFbCA9IGhlYWRsaW5lRWwuY2xvc2VzdCgnW2RhdGEtc2V0dGluZ3MqPVwicm90YXRpbmdfdGV4dFwiXScpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB3aWRnZXRFbD8uZ2V0QXR0cmlidXRlKCdkYXRhLXNldHRpbmdzJylcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc2V0dGluZ3MgJiYgd2lkZ2V0RWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50b3ItaW52aXNpYmxlIGNsYXNzIGZyb20gd2lkZ2V0IGFuZCBoZWFkbGluZVxuICAgICAgICAgICAgICB3aWRnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdlbGVtZW50b3ItaW52aXNpYmxlJylcbiAgICAgICAgICAgICAgaGVhZGxpbmVFbC5jbGFzc0xpc3QucmVtb3ZlKCdlbGVtZW50b3ItaW52aXNpYmxlJylcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mIzM5Oy9nLCBcIidcIilcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZC5yb3RhdGluZ190ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGhlYWRsaW5lIGlzIHZpc2libGUgYW5kIGFkZCBzcGFjaW5nXG4gICAgICAgICAgICAgICAgaGVhZGxpbmVFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgaGVhZGxpbmVFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgaGVhZGxpbmVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTVweCdcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aWRnZXRFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgd2lkZ2V0RWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIHdpZGdldEVsLnN0eWxlLm1hcmdpblRvcCA9ICcxNXB4J1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFsc28gYWRkIG1hcmdpbiB0byB3aWRnZXQgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGFpbmVyID0gd2lkZ2V0RWwucXVlcnlTZWxlY3RvcignLmVsZW1lbnRvci13aWRnZXQtY29udGFpbmVyJykgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAod2lkZ2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICB3aWRnZXRDb250YWluZXIuc3R5bGUubWFyZ2luVG9wID0gJzE1cHgnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgdGV4dCBzcGFuc1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTcGFucyA9IGhlYWRsaW5lRWwucXVlcnlTZWxlY3RvckFsbCgnLmVsZW1lbnRvci1oZWFkbGluZS1keW5hbWljLXRleHQnKSBhcyBOb2RlTGlzdE9mPEhUTUxFbGVtZW50PlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZpeCB0ZXh0IHdyYXBwZXIgd2lkdGggdG8gc2hvdyBmdWxsIHRleHRcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0V3JhcHBlciA9IGhlYWRsaW5lRWwucXVlcnlTZWxlY3RvcignLmVsZW1lbnRvci1oZWFkbGluZS10ZXh0LXdyYXBwZXInKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0V3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZpeGVkIHdpZHRoIHRvIGFsbG93IHRleHQgdG8gZXhwYW5kXG4gICAgICAgICAgICAgICAgICB0ZXh0V3JhcHBlci5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgdGV4dFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSAnZml0LWNvbnRlbnQnXG4gICAgICAgICAgICAgICAgICB0ZXh0V3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgdGV4dFdyYXBwZXIuc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZpeCBkeW5hbWljIHdyYXBwZXIgd2lkdGhcbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljV3JhcHBlciA9IGhlYWRsaW5lRWwucXVlcnlTZWxlY3RvcignLmVsZW1lbnRvci1oZWFkbGluZS1keW5hbWljLXdyYXBwZXInKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChkeW5hbWljV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgZHluYW1pY1dyYXBwZXIuc3R5bGUud2lkdGggPSAnYXV0bydcbiAgICAgICAgICAgICAgICAgIGR5bmFtaWNXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gJ2ZpdC1jb250ZW50J1xuICAgICAgICAgICAgICAgICAgZHluYW1pY1dyYXBwZXIuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgIGR5bmFtaWNXcmFwcGVyLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgaGVhZGxpbmUgaXRzZWxmIGRvZXNuJ3QgY2xpcFxuICAgICAgICAgICAgICAgIGhlYWRsaW5lRWwuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICBoZWFkbGluZUVsLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJ1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3BhbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgLy8gR2V0IHJvdGF0aW9uIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICBjb25zdCBsb29wID0gcGFyc2VkLmxvb3AgIT09ICdubydcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvbkRlbGF5ID0gcGFyc2VkLnJvdGF0ZV9pdGVyYXRpb25fZGVsYXkgfHwgMjUwMFxuICAgICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uVHlwZSA9IHBhcnNlZC5hbmltYXRpb25fdHlwZSB8fCAnY2xpcCdcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGludGVydmFsIGZvciB0aGlzIGhlYWRsaW5lXG4gICAgICAgICAgICAgICAgICBjb25zdCBoZWFkbGluZUlkID0gd2lkZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJykgfHwgJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgICBpZiAoKHdpbmRvdyBhcyBhbnkpW2BoZWFkbGluZUludGVydmFsXyR7aGVhZGxpbmVJZH1gXSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCh3aW5kb3cgYXMgYW55KVtgaGVhZGxpbmVJbnRlcnZhbF8ke2hlYWRsaW5lSWR9YF0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSAwXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgaW5pdGlhbCBhY3RpdmUgdGV4dCBhbmQgZW5zdXJlIGFsbCB0ZXh0IHNwYW5zIGFyZSBwcm9wZXJseSBzdHlsZWRcbiAgICAgICAgICAgICAgICAgIGxldCBtYXhXaWR0aCA9IDBcbiAgICAgICAgICAgICAgICAgIHRleHRTcGFucy5mb3JFYWNoKChzcGFuLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGVhY2ggdGV4dCBzcGFuIHRvIHNob3cgZnVsbCB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCdcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLnRleHRPdmVyZmxvdyA9ICdjbGlwJ1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBzcGFuLmNsYXNzTGlzdC5jb250YWlucygnZWxlbWVudG9yLWhlYWRsaW5lLXRleHQtYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2ZSB0ZXh0IHNob3VsZCBiZSB2aXNpYmxlIGFuZCByZWxhdGl2ZSBwb3NpdGlvbmVkXG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS56SW5kZXggPSAnMidcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpZHhcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbmFjdGl2ZSB0ZXh0cyBzaG91bGQgYmUgaGlkZGVuIGFuZCBhYnNvbHV0ZWx5IHBvc2l0aW9uZWRcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUuZGlzcGxheSA9ICdub25lJyAvLyBIaWRlIGNvbXBsZXRlbHkgdG8gYXZvaWQgZHVwbGljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUuekluZGV4ID0gJzAnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IG1ha2UgdmlzaWJsZSBvbmx5IHRvIG1lYXN1cmUgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxWaXNpYmlsaXR5ID0gc3Bhbi5zdHlsZS52aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGlzcGxheSA9IHNwYW4uc3R5bGUuZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFBvc2l0aW9uID0gc3Bhbi5zdHlsZS5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIHRleHQgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gc3Bhbi5vZmZzZXRXaWR0aCB8fCBzcGFuLnNjcm9sbFdpZHRoIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSB0ZXh0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0byBvcmlnaW5hbCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBvcmlnaW5hbFZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBTZXQgd3JhcHBlciB0byBmaXQgdGhlIGxvbmdlc3QgdGV4dFxuICAgICAgICAgICAgICAgICAgaWYgKHRleHRXcmFwcGVyICYmIG1heFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0V3JhcHBlci5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICB0ZXh0V3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IGAke21heFdpZHRofXB4YFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBpZiAoZHluYW1pY1dyYXBwZXIgJiYgbWF4V2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNXcmFwcGVyLnN0eWxlLndpZHRoID0gJ2F1dG8nXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gYCR7bWF4V2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIHRvIHJvdGF0ZSB0byBuZXh0IHRleHRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0ZVRleHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9vcCAmJiBjdXJyZW50SW5kZXggPj0gdGV4dFNwYW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLy8gU3RvcCBpZiBsb29wIGlzIGRpc2FibGVkIGFuZCByZWFjaGVkIGVuZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWN0aXZlIGNsYXNzIGZyb20gY3VycmVudCBhbmQgaGlkZSBpdFxuICAgICAgICAgICAgICAgICAgICB0ZXh0U3BhbnMuZm9yRWFjaCgoc3BhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LnJlbW92ZSgnZWxlbWVudG9yLWhlYWRsaW5lLXRleHQtYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ2VsZW1lbnRvci1oZWFkbGluZS10ZXh0LWluYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGluYWN0aXZlIHRleHQgY29tcGxldGVseSB0byBwcmV2ZW50IGR1cGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc3R5bGUuekluZGV4ID0gJzAnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgKHdpdGggbG9vcClcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgdGV4dFNwYW5zLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGl2ZSBjbGFzcyB0byBuZXcgdGV4dCBhbmQgc2hvdyBpdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3BhbiA9IHRleHRTcGFuc1tjdXJyZW50SW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3Bhbikge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRTcGFuLmNsYXNzTGlzdC5yZW1vdmUoJ2VsZW1lbnRvci1oZWFkbGluZS10ZXh0LWluYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0U3Bhbi5jbGFzc0xpc3QuYWRkKCdlbGVtZW50b3ItaGVhZGxpbmUtdGV4dC1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgb25seSB0aGUgYWN0aXZlIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0U3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFNwYW4uc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFNwYW4uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFNwYW4uc3R5bGUuekluZGV4ID0gJzInXG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdyYXBwZXIgZXhwYW5kcyB0byBmaXQgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd3JhcHBlciB3aWR0aCB0byBmaXQgdGhlIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IG5leHRTcGFuLm9mZnNldFdpZHRoIHx8IG5leHRTcGFuLnNjcm9sbFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V3JhcHBlci5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IGAke3RleHRXaWR0aH1weGBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgcm90YXRpb24gaWYgbG9vcCBpcyBlbmFibGVkIG9yIGlmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSB0ZXh0XG4gICAgICAgICAgICAgICAgICBpZiAobG9vcCB8fCB0ZXh0U3BhbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAod2luZG93IGFzIGFueSlbYGhlYWRsaW5lSW50ZXJ2YWxfJHtoZWFkbGluZUlkfWBdID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZVRleHQoKVxuICAgICAgICAgICAgICAgICAgICB9LCBpdGVyYXRpb25EZWxheSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhbmltYXRlZCBoZWFkbGluZTonLCBlKVxuICAgICAgICAgICAgICAvLyBTdGlsbCBlbnN1cmUgdmlzaWJpbGl0eSBldmVuIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgICAgICAgd2lkZ2V0RWw/LmNsYXNzTGlzdC5yZW1vdmUoJ2VsZW1lbnRvci1pbnZpc2libGUnKVxuICAgICAgICAgICAgICBoZWFkbGluZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ2VsZW1lbnRvci1pbnZpc2libGUnKVxuICAgICAgICAgICAgICBoZWFkbGluZUVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgaGVhZGxpbmVFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgZWxlbWVudG9yLWludmlzaWJsZSBjbGFzcyBmcm9tIGZvb3RlciBlbGVtZW50cyBzbyB0aGV5IHNob3cgaW1tZWRpYXRlbHlcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBmb290ZXIgPSBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKCdmb290ZXInKVxuICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGludmlzaWJsZSBjbGFzcyBmcm9tIGFsbCBmb290ZXIgZWxlbWVudHNcbiAgICAgICAgICBmb290ZXIucXVlcnlTZWxlY3RvckFsbCgnLmVsZW1lbnRvci1pbnZpc2libGUnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZWxlbWVudG9yLWludmlzaWJsZScpXG4gICAgICAgICAgICAvLyBBbHNvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICBjb25zdCBodG1sRWwgPSBlbCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgaWYgKGh0bWxFbC5zdHlsZSkge1xuICAgICAgICAgICAgICBodG1sRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICBodG1sRWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyByZW1vdmUgZnJvbSBmb290ZXIgc2VjdGlvbnNcbiAgICAgICAgICBmb290ZXIucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzKj1cImVsZW1lbnRvci1pbnZpc2libGVcIl0nKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZWxlbWVudG9yLWludmlzaWJsZScpXG4gICAgICAgICAgICBjb25zdCBodG1sRWwgPSBlbCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgaWYgKGh0bWxFbC5zdHlsZSkge1xuICAgICAgICAgICAgICBodG1sRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICBodG1sRWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG1pc3NpbmcgaW1hZ2VzIC0gYWRkIHBsYWNlaG9sZGVycyBmb3IgYWxsIG1pc3NpbmcgaW1hZ2VzXG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBGaXggaG92ZXIgYm94IGJhY2tncm91bmQgaW1hZ2VzIC0gZW5zdXJlIHRoZXkgbG9hZCBwcm9wZXJseVxuICAgICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5iZHQtZXAtaG92ZXItYm94LWltZycpLmZvckVhY2goKGltZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1nRWwgPSBpbWcgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gaW1nRWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnXG4gICAgICAgICAgICBjb25zdCBiZ01hdGNoID0gc3R5bGUubWF0Y2goL2JhY2tncm91bmQtaW1hZ2U6XFxzKnVybFxcKFsnXCJdPyhbXidcIildKylbJ1wiXT9cXCkvaSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGJnTWF0Y2ggJiYgYmdNYXRjaFsxXSkge1xuICAgICAgICAgICAgICBjb25zdCBiZ1VybCA9IGJnTWF0Y2hbMV1cbiAgICAgICAgICAgICAgLy8gRml4IFVSTCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBBbHdheXMgY29udmVydCByaW1hbHdlYi5uZXQgKGFueSBjYXNlKSB0byBhbGx1cmVkaWdpdGFsLm5ldCBmb3IgYXNzZXQgZmlsZW5hbWUgbG9va3VwXG4gICAgICAgICAgICAgIGxldCBmaXhlZFVybCA9IGJnVXJsXG4gICAgICAgICAgICAgIGlmIChiZ1VybCAmJiAoL2FsbHVyZWRpZ2l0YWxcXC5uZXQvaS50ZXN0KGJnVXJsKSB8fCAvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KGJnVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBTFdBWVMgY29udmVydCByaW1hbHdlYi5uZXQgKGFueSBjYXNlKSB0byBhbGx1cmVkaWdpdGFsLm5ldCAtIGFzc2V0IGZpbGVzIHVzZSBhbGx1cmVkaWdpdGFsLm5ldFxuICAgICAgICAgICAgICAgIGxldCB1cmxUb0ZpeCA9IGJnVXJsXG4gICAgICAgICAgICAgICAgaWYgKC9yaW1hbHdlYlxcLm5ldC9pLnRlc3QoYmdVcmwpKSB7XG4gICAgICAgICAgICAgICAgICB1cmxUb0ZpeCA9IGJnVXJsLnJlcGxhY2UoL3JpbWFsd2ViXFwubmV0L2dpLCAnYWxsdXJlZGlnaXRhbC5uZXQnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXhlZFVybCA9IGZpeEFzc2V0VXJsKHVybFRvRml4KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgc3R5bGUgd2l0aCBmaXhlZCBVUkwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgaWYgKGZpeGVkVXJsICE9PSBiZ1VybCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUucmVwbGFjZShiZ1VybCwgZml4ZWRVcmwpXG4gICAgICAgICAgICAgICAgaW1nRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIG5ld1N0eWxlKVxuICAgICAgICAgICAgICAgIGltZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7Zml4ZWRVcmx9JylgXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRXZlbiBpZiBVUkwgZG9lc24ndCBjaGFuZ2UsIGVuc3VyZSBiYWNrZ3JvdW5kIGltYWdlIGlzIHNldFxuICAgICAgICAgICAgICAgIGltZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7Zml4ZWRVcmx9JylgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgZ3JhZGllbnQgZmFsbGJhY2sgZmlyc3RcbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdHlsZSA9IGltZ0VsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJ1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlLmluY2x1ZGVzKCdsaW5lYXItZ3JhZGllbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBncmFkaWVudCBhbmQga2VlcCBvbmx5IGJhY2tncm91bmQtaW1hZ2VcbiAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGUucmVwbGFjZSgvYmFja2dyb3VuZDpcXHMqbGluZWFyLWdyYWRpZW50W147XSs7L2dpLCAnJylcbiAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGUucmVwbGFjZSgvYmFja2dyb3VuZC1jb2xvcjpcXHMqW147XSs7L2dpLCAnJylcbiAgICAgICAgICAgICAgICBpbWdFbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgY3VycmVudFN0eWxlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBFbnN1cmUgdmlzaWJpbGl0eSBhbmQgcHJvcGVyIHNpemluZ1xuICAgICAgICAgICAgICBpbWdFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgIGltZ0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgaW1nRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgaW1nRWwuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInXG4gICAgICAgICAgICAgIGltZ0VsLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICdjZW50ZXInXG4gICAgICAgICAgICAgIGltZ0VsLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgICBpbWdFbC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgICAgICAgICAgICBpbWdFbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICAgICAgICAgICAgaW1nRWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtmaXhlZFVybH0nKWBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEVuc3VyZSBwYXJlbnQgY29udGVudCBpcyB2aXNpYmxlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGltYWdlXG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbnRlbnQgPSBpbWdFbC5jbG9zZXN0KCcuYmR0LWVwLWhvdmVyLWJveC1jb250ZW50JykgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKHBhcmVudENvbnRlbnQgJiYgcGFyZW50Q29udGVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2JkdC1hY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnQuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICBwYXJlbnRDb250ZW50LnN0eWxlLnpJbmRleCA9ICcxMCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUHJlbG9hZCBpbWFnZSB0byBlbnN1cmUgaXQgbG9hZHMgKGRvbid0IHNldCBmYWxsYmFjayBncmFkaWVudClcbiAgICAgICAgICAgICAgY29uc3QgdGVzdEltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgICAgIHRlc3RJbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW1nRWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtmaXhlZFVybH0nKWBcbiAgICAgICAgICAgICAgICBpbWdFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgaW1nRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgIGltZ0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vIGdyYWRpZW50IGlzIGFwcGxpZWRcbiAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBpbWdFbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJydcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlLmluY2x1ZGVzKCdsaW5lYXItZ3JhZGllbnQnKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlLnJlcGxhY2UoL2JhY2tncm91bmQ6XFxzKmxpbmVhci1ncmFkaWVudFteO10rOy9naSwgJycpXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGUucmVwbGFjZSgvYmFja2dyb3VuZC1jb2xvcjpcXHMqW147XSs7L2dpLCAnJylcbiAgICAgICAgICAgICAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjdXJyZW50U3R5bGUpXG4gICAgICAgICAgICAgICAgICBpbWdFbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2ZpeGVkVXJsfScpYFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXN0SW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0hvdmVyIGJveCBpbWFnZSBmYWlsZWQgdG8gbG9hZDonLCBmaXhlZFVybClcbiAgICAgICAgICAgICAgICAvLyBUcnkgYWx0ZXJuYXRpdmUgcGF0aHMgKHdpdGhvdXQgc2l6ZSBzdWZmaXgpXG4gICAgICAgICAgICAgICAgY29uc3QgYWx0VXJsID0gZml4ZWRVcmwucmVwbGFjZSgvLVxcZCt4XFxkKyhcXC5bYS16XSspJC9pLCAnJDEnKVxuICAgICAgICAgICAgICAgIGlmIChhbHRVcmwgIT09IGZpeGVkVXJsKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbHRUZXN0SW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgICAgIGFsdFRlc3RJbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7YWx0VXJsfScpYFxuICAgICAgICAgICAgICAgICAgICBpbWdFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgICAgIGltZ0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFsdFRlc3RJbWcuc3JjID0gYWx0VXJsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRlc3RJbWcuc3JjID0gZml4ZWRVcmxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmljZSBwbGFjZWhvbGRlciBTVkdcbiAgICAgICAgY29uc3QgY3JlYXRlUGxhY2Vob2xkZXJTdmcgPSAod2lkdGg6IG51bWJlciB8IHN0cmluZywgaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCB3ID0gdHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHdpZHRoKSB8fCA0MDAgOiB3aWR0aCB8fCA0MDBcbiAgICAgICAgICBjb25zdCBoID0gdHlwZW9mIGhlaWdodCA9PT0gJ3N0cmluZycgPyBwYXJzZUludChoZWlnaHQpIHx8IDMwMCA6IGhlaWdodCB8fCAzMDBcbiAgICAgICAgICByZXR1cm4gYGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiJHt3fVwiIGhlaWdodD1cIiR7aH1cIiUzRSUzQ3JlY3Qgd2lkdGg9XCIxMDAlMjVcIiBoZWlnaHQ9XCIxMDAlMjVcIiBmaWxsPVwiJTIzZjVmNWY1XCIvJTNFJTNDcmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxMDAlMjVcIiBoZWlnaHQ9XCIxMDAlMjVcIiBmaWxsPVwidXJsKCUyM2dyYWRpZW50KVwiLyUzRSUzQ2RlZnMlM0UlM0NsaW5lYXJHcmFkaWVudCBpZD1cImdyYWRpZW50XCIgeDE9XCIwJTI1XCIgeTE9XCIwJTI1XCIgeDI9XCIxMDAlMjVcIiB5Mj1cIjEwMCUyNVwiJTNFJTNDc3RvcCBvZmZzZXQ9XCIwJTI1XCIgc3R5bGU9XCJzdG9wLWNvbG9yOiUyM2YwZjBmMDtzdG9wLW9wYWNpdHk6MVwiIC8lM0UlM0NzdG9wIG9mZnNldD1cIjEwMCUyNVwiIHN0eWxlPVwic3RvcC1jb2xvcjolMjNlMGUwZTA7c3RvcC1vcGFjaXR5OjFcIiAvJTNFJTNDL2xpbmVhckdyYWRpZW50JTNFJTNDL2RlZnMlM0UlM0N0ZXh0IHg9XCI1MCUyNVwiIHk9XCI1MCUyNVwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCIgZHk9XCIuM2VtXCIgZm9udC1mYW1pbHk9XCJBcmlhbCwgc2Fucy1zZXJpZlwiIGZvbnQtc2l6ZT1cIjE2XCIgZmlsbD1cIiUyMzk5OVwiJTNFSW1hZ2UlM0MvdGV4dCUzRSUzQy9zdmclM0VgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSBpbWcgdGFncyAtIGFkZCBlcnJvciBoYW5kbGVycyBmb3IgbWlzc2luZyBpbWFnZXNcbiAgICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvckFsbCgnaW1nW3NyY10nKS5mb3JFYWNoKChpbWcpID0+IHtcbiAgICAgICAgICBjb25zdCBpbWdFbGVtZW50ID0gaW1nIGFzIEhUTUxJbWFnZUVsZW1lbnRcbiAgICAgICAgICBsZXQgc3JjID0gaW1nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpIHx8ICcnXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICBpZiAoc3JjLmluY2x1ZGVzKCdkYXRhOmltYWdlL3N2Zyt4bWwnKSkgcmV0dXJuXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSU1QT1JUQU5UOiBGaXggVVJMIGlmIGl0IGNvbnRhaW5zIHJpbWFsd2ViLm5ldCAoYW55IGNhc2UpIC0gY29udmVydCB0byBhbGx1cmVkaWdpdGFsLm5ldCBmb3IgYXNzZXQgbG9va3VwXG4gICAgICAgICAgaWYgKC9yaW1hbHdlYlxcLm5ldC9pLnRlc3Qoc3JjKSkge1xuICAgICAgICAgICAgY29uc3QgZml4ZWRTcmMgPSBmaXhBc3NldFVybChzcmMpXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNyYyBhdHRyaWJ1dGUgaWYgaXQgd2FzIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChmaXhlZFNyYyAhPT0gc3JjKSB7XG4gICAgICAgICAgICAgIGltZ0VsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBmaXhlZFNyYylcbiAgICAgICAgICAgICAgc3JjID0gZml4ZWRTcmNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIGVycm9yIGhhbmRsZXIgZm9yIG1pc3NpbmcgaW1hZ2VzXG4gICAgICAgICAgaW1nRWxlbWVudC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlcGxhY2UgaWYgaXQncyBhIGxvY2FsIGFzc2V0IHRoYXQgZmFpbGVkXG4gICAgICAgICAgICBpZiAoKHNyYy5pbmNsdWRlcygnL2Fzc2V0cy8nKSB8fCBzcmMuaW5jbHVkZXMoJ2FsbHVyZWRpZ2l0YWwubmV0JykgfHwgL3JpbWFsd2ViXFwubmV0L2kudGVzdChzcmMpKSAmJiAhc3JjLmluY2x1ZGVzKCdkYXRhOicpKSB7XG4gICAgICAgICAgICAgIC8vIEdldCBvcmlnaW5hbCBkaW1lbnNpb25zXG4gICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgaW1nRWxlbWVudC5vZmZzZXRXaWR0aCB8fCA0MDBcbiAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IGltZ0VsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDMwMFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIFNWR1xuICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlclN2ZyA9IGNyZWF0ZVBsYWNlaG9sZGVyU3ZnKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgaW1nRWxlbWVudC5vbmVycm9yID0gbnVsbFxuICAgICAgICAgICAgICBpbWdFbGVtZW50LnNyYyA9IHBsYWNlaG9sZGVyU3ZnXG4gICAgICAgICAgICAgIGltZ0VsZW1lbnQuc3R5bGUub2JqZWN0Rml0ID0gJ2NvbnRhaW4nXG4gICAgICAgICAgICAgIGltZ0VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmNWY1ZjUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByZS1jaGVjayBpbWFnZSBleGlzdGVuY2UgZm9yIGxvY2FsIGFzc2V0c1xuICAgICAgICAgIGlmICgoc3JjLmluY2x1ZGVzKCcvYXNzZXRzLycpIHx8IHNyYy5pbmNsdWRlcygnYWxsdXJlZGlnaXRhbC5uZXQnKSB8fCAvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KHNyYykpICYmICFzcmMuaW5jbHVkZXMoJ2RhdGE6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RJbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgICAgdGVzdEltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgaW1nRWxlbWVudC5vZmZzZXRXaWR0aCB8fCA0MDBcbiAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IGltZ0VsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDMwMFxuICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlclN2ZyA9IGNyZWF0ZVBsYWNlaG9sZGVyU3ZnKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgICAgICAgIGltZ0VsZW1lbnQuc3JjID0gcGxhY2Vob2xkZXJTdmdcbiAgICAgICAgICAgICAgaW1nRWxlbWVudC5zdHlsZS5vYmplY3RGaXQgPSAnY29udGFpbidcbiAgICAgICAgICAgICAgaW1nRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2Y1ZjVmNSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlc3RJbWcuc3JjID0gc3JjXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIGJhY2tncm91bmQgaW1hZ2VzIC0gYWRkIGZhbGxiYWNrIGZvciBtaXNzaW5nIGJhY2tncm91bmQgaW1hZ2VzXG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tzdHlsZSo9XCJiYWNrZ3JvdW5kLWltYWdlXCJdLCAuYmR0LXNjcm9sbC1pbWFnZScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2VsY29tZSBzZWN0aW9uIC0gdXNlIG9yaWdpbmFsIHNjcmFwZWQgSFRNTCwgZG9uJ3QgbW9kaWZ5IGl0XG4gICAgICAgICAgY29uc3QgaXNXZWxjb21lU2VjdGlvbiA9IGVsZW1lbnQuY2xvc2VzdCgnc2VjdGlvbiwgZGl2Jyk/LnF1ZXJ5U2VsZWN0b3IoJ2gyLCBoMScpPy50ZXh0Q29udGVudD8uaW5jbHVkZXMoJ1dlbGNvbWUgdG8nKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbG9zZXN0KCdzZWN0aW9uLCBkaXYnKT8ucXVlcnlTZWxlY3RvcignaDIsIGgxJyk/LnRleHRDb250ZW50Py5pbmNsdWRlcygnQnJlYWtpbmcgVGhyb3VnaCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xvc2VzdCgnc2VjdGlvbiwgZGl2Jyk/LnF1ZXJ5U2VsZWN0b3IoJ2gyLCBoMScpPy50ZXh0Q29udGVudD8uaW5jbHVkZXMoJ0RpZ2l0YWwgSW1wYXNzZScpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2tpcCBtb2RpZnlpbmcgd2VsY29tZSBzZWN0aW9uIC0gdXNlIG9yaWdpbmFsIHNjcmFwZWQgSFRNTFxuICAgICAgICAgIGlmIChpc1dlbGNvbWVTZWN0aW9uICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdiZHQtc2Nyb2xsLWltYWdlJykpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgZml4IFVSTCBpZiBuZWVkZWQsIGJ1dCBkb24ndCByZXBsYWNlIHRoZSBpbWFnZVxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJ1xuICAgICAgICAgICAgY29uc3QgYmdNYXRjaCA9IHN0eWxlLm1hdGNoKC9iYWNrZ3JvdW5kLWltYWdlOlxccyp1cmxcXChbJ1wiXT8oW14nXCIpXSspWydcIl0/XFwpL2kpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChiZ01hdGNoICYmIGJnTWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgbGV0IGJnVXJsID0gYmdNYXRjaFsxXVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRml4IFVSTCBpZiBpdCBjb250YWlucyByaW1hbHdlYi5uZXQgKGFueSBjYXNlKSAtIGNvbnZlcnQgdG8gYWxsdXJlZGlnaXRhbC5uZXQgZm9yIGFzc2V0IGxvb2t1cFxuICAgICAgICAgICAgICBpZiAoL3JpbWFsd2ViXFwubmV0L2kudGVzdChiZ1VybCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXhlZEJnVXJsID0gZml4QXNzZXRVcmwoYmdVcmwpXG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkQmdVcmwgIT09IGJnVXJsKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7Zml4ZWRCZ1VybH0nKWBcbiAgICAgICAgICAgICAgICAgIGJnVXJsID0gZml4ZWRCZ1VybFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUHJlbG9hZCBpbWFnZSB0byBlbnN1cmUgaXQgbG9hZHNcbiAgICAgICAgICAgICAgaWYgKChiZ1VybC5pbmNsdWRlcygnL2Fzc2V0cy8nKSB8fCBiZ1VybC5pbmNsdWRlcygnYWxsdXJlZGlnaXRhbC5uZXQnKSB8fCAvcmltYWx3ZWJcXC5uZXQvaS50ZXN0KGJnVXJsKSkgJiYgIWJnVXJsLmluY2x1ZGVzKCdkYXRhOicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdEltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgICAgICAgdGVzdEltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtiZ1VybH0nKWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVzdEltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcnkgd2l0aG91dCBzaXplIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgY29uc3QgYWx0VXJsID0gYmdVcmwucmVwbGFjZSgvLVxcZCt4XFxkKy8sICcnKVxuICAgICAgICAgICAgICAgICAgaWYgKGFsdFVybCAhPT0gYmdVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2FsdFVybH0nKWBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVzdEltZy5zcmMgPSBiZ1VybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLy8gU2tpcCB0aGUgcmVzdCBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBvdGhlciBiYWNrZ3JvdW5kIGltYWdlcywgY2hlY2sgaWYgdGhleSBleGlzdFxuICAgICAgICAgIC8vIFNraXAgaG92ZXIgYm94IGltYWdlcyAtIHRoZXkgYXJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgICAgICAgIGNvbnN0IGlzSG92ZXJCb3hJbWFnZSA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdiZHQtZXAtaG92ZXItYm94LWltZycpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbG9zZXN0KCcuYmR0LWVwLWhvdmVyLWJveCcpICE9PSBudWxsXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGlzSG92ZXJCb3hJbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIC8vIFNraXAgZmFsbGJhY2sgZm9yIGhvdmVyIGJveCBpbWFnZXMgLSB0aGV5IGFyZSBoYW5kbGVkIGFib3ZlXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJydcbiAgICAgICAgICBjb25zdCBiZ01hdGNoID0gc3R5bGUubWF0Y2goL2JhY2tncm91bmQtaW1hZ2U6XFxzKnVybFxcKFsnXCJdPyhbXidcIildKylbJ1wiXT9cXCkvaSlcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoYmdNYXRjaCAmJiBiZ01hdGNoWzFdKSB7XG4gICAgICAgICAgICBsZXQgYmdVcmwgPSBiZ01hdGNoWzFdXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogRml4IFVSTCBpZiBpdCBjb250YWlucyByaW1hbHdlYi5uZXQgKGFueSBjYXNlKSAtIGNvbnZlcnQgdG8gYWxsdXJlZGlnaXRhbC5uZXQgZm9yIGFzc2V0IGxvb2t1cFxuICAgICAgICAgICAgaWYgKC9yaW1hbHdlYlxcLm5ldC9pLnRlc3QoYmdVcmwpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpeGVkQmdVcmwgPSBmaXhBc3NldFVybChiZ1VybClcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdHlsZSBhdHRyaWJ1dGUgaWYgVVJMIHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgIGlmIChmaXhlZEJnVXJsICE9PSBiZ1VybCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTdHlsZSA9IHN0eWxlLnJlcGxhY2UoL2JhY2tncm91bmQtaW1hZ2U6XFxzKnVybFxcKFsnXCJdP1teJ1wiKV0rWydcIl0/XFwpL2ksIGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJyR7Zml4ZWRCZ1VybH0nKWApXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdXBkYXRlZFN0eWxlKVxuICAgICAgICAgICAgICAgIGJnVXJsID0gZml4ZWRCZ1VybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFByZWxvYWQgYmFja2dyb3VuZCBpbWFnZSB0byBjaGVjayBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGlmICgoYmdVcmwuaW5jbHVkZXMoJy9hc3NldHMvJykgfHwgYmdVcmwuaW5jbHVkZXMoJ2FsbHVyZWRpZ2l0YWwubmV0JykgfHwgL3JpbWFsd2ViXFwubmV0L2kudGVzdChiZ1VybCkpICYmICFiZ1VybC5pbmNsdWRlcygnZGF0YTonKSkge1xuICAgICAgICAgICAgICBjb25zdCB0ZXN0SW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgdGVzdEltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgc2V0IGEgZmFsbGJhY2sgZ3JhZGllbnQgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgIC8vIEJVVCBOT1QgZm9yIGhvdmVyIGJveCBpbWFnZXNcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJ1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrU3R5bGUgPSBjdXJyZW50U3R5bGUucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgIC9iYWNrZ3JvdW5kLWltYWdlOlxccyp1cmxcXChbXildK1xcKS9naSxcbiAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjM2NmYxIDAlLCAjOGI1Y2Y2IDUwJSwgI2Y1ZjVmNSAxMDAlKTsgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNSdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgZmFsbGJhY2tTdHlsZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXN0SW1nLnNyYyA9IGJnVXJsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBoYW5kbGUgZGF0YS1zZXR0aW5ncyBiYWNrZ3JvdW5kIHNsaWRlc2hvdyBpbWFnZXMgLSBBTExPVyBPUklHSU5BTCBTTElERVNIT1dcbiAgICAgICAgLy8gRmluZCBob21lcGFnZSBoZXJvIHNlY3Rpb24gYW5kIGVuc3VyZSBzbGlkZXNob3cgaW1hZ2VzIGxvYWQgcHJvcGVybHlcbiAgICAgICAgY29uc3QgaG9tZXBhZ2VIZXJvU2VjdGlvbiA9IGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNldHRpbmdzKj1cImJhY2tncm91bmRfc2xpZGVzaG93X2dhbGxlcnlcIl0nKVxuICAgICAgICBpZiAoaG9tZXBhZ2VIZXJvU2VjdGlvbikge1xuICAgICAgICAgIGNvbnN0IGhlcm9FbCA9IGhvbWVwYWdlSGVyb1NlY3Rpb24gYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAvLyBFbnN1cmUgc2xpZGVzaG93IGlzIHZpc2libGUgYW5kIHdvcmtpbmdcbiAgICAgICAgICBjb25zdCBzbGlkZXNob3cgPSBoZXJvRWwucXVlcnlTZWxlY3RvcignLmVsZW1lbnRvci1iYWNrZ3JvdW5kLXNsaWRlc2hvdycpXG4gICAgICAgICAgaWYgKHNsaWRlc2hvdykge1xuICAgICAgICAgICAgLy8gS2VlcCBzbGlkZXNob3cgdmlzaWJsZSAtIGRvbid0IHJlbW92ZSBpdFxuICAgICAgICAgICAgY29uc3Qgc2xpZGVzaG93RWwgPSBzbGlkZXNob3cgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIHNsaWRlc2hvd0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRyeSB0byBlbmFibGUgbG9vcCBvbiBleGlzdGluZyBTd2lwZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzd2lwZXJJbnN0YW5jZSA9IChzbGlkZXNob3dFbCBhcyBhbnkpPy5zd2lwZXJcbiAgICAgICAgICAgICAgaWYgKHN3aXBlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gQUxXQVlTIGVuYWJsZSBsb29wIGZvciBpbWFnZXMgKGZvcmNlIGxvb3ApIC0gZGVzdHJveSBhbmQgcmVjcmVhdGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFzd2lwZXJJbnN0YW5jZS5wYXJhbXMubG9vcCB8fCBzd2lwZXJJbnN0YW5jZS5wYXJhbXMubG9vcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgZXhpc3RpbmcgbG9vcCBpZiBhbnlcbiAgICAgICAgICAgICAgICAgIGlmIChzd2lwZXJJbnN0YW5jZS5sb29wRGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS5sb29wRGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGVuYWJsZSBsb29wXG4gICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS5wYXJhbXMubG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnBhcmFtcy5sb29wZWRTbGlkZXMgPSB1bmRlZmluZWQgLy8gTGV0IFN3aXBlciBjYWxjdWxhdGUgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UucGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzID0gMlxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbG9vcFxuICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlckluc3RhbmNlLmxvb3BDcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UubG9vcENyZWF0ZSgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0byBhcHBseSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UudXBkYXRlU2xpZGVzKClcbiAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIGxvb3AgaXMgYWxyZWFkeSBlbmFibGVkLCBlbnN1cmUgaXQncyB3b3JraW5nIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS5wYXJhbXMubG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGlmIChzd2lwZXJJbnN0YW5jZS5sb29wQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLmxvb3BDcmVhdGUoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UudXBkYXRlKClcbiAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnVwZGF0ZVNsaWRlcygpXG4gICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS51cGRhdGVTbGlkZXNDbGFzc2VzKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU2V0IHNwZWVkL3RyYW5zaXRpb24gdG8gMCBmb3IgaW5zdGFudCB0cmFuc2l0aW9uIChubyBnYXApXG4gICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UucGFyYW1zLnNwZWVkID0gMFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBhdXRvcGxheSBpcyBydW5uaW5nIHdpdGggc2VhbWxlc3MgbG9vcCAobm8gZ2FwKVxuICAgICAgICAgICAgICAgIGlmIChzd2lwZXJJbnN0YW5jZS5wYXJhbXMuYXV0b3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS5wYXJhbXMuYXV0b3BsYXkucGF1c2VPbk1vdXNlRW50ZXIgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UucGFyYW1zLmF1dG9wbGF5LndhaXRGb3JUcmFuc2l0aW9uID0gZmFsc2UgLy8gRG9uJ3Qgd2FpdCBmb3IgdHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc2xpZGVzaG93IGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIHNsaWRlc2hvd0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGF1dG9wbGF5IGlzIHJ1bm5pbmcgYW5kIHdpbGwgY29udGludWVcbiAgICAgICAgICAgICAgICBpZiAoIXN3aXBlckluc3RhbmNlLnBhcmFtcy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UucGFyYW1zLmF1dG9wbGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICBkZWxheTogNTUwMCxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXVzZU9uTW91c2VFbnRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdhaXRGb3JUcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcE9uTGFzdFNsaWRlOiBmYWxzZSwgLy8gRG9uJ3Qgc3RvcCBvbiBsYXN0IHNsaWRlXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VEaXJlY3Rpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS5wYXJhbXMuYXV0b3BsYXkucGF1c2VPbk1vdXNlRW50ZXIgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UucGFyYW1zLmF1dG9wbGF5LndhaXRGb3JUcmFuc2l0aW9uID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGUgPSBmYWxzZSAvLyBEb24ndCBzdG9wIG9uIGxhc3Qgc2xpZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFzd2lwZXJJbnN0YW5jZS5hdXRvcGxheSB8fCAhc3dpcGVySW5zdGFuY2UuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlckluc3RhbmNlLmF1dG9wbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLmF1dG9wbGF5LnN0YXJ0KClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gUmVzdGFydCBhdXRvcGxheSB0byBlbnN1cmUgc2VhbWxlc3MgbG9vcFxuICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UuYXV0b3BsYXkuc3RvcCgpXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UuYXV0b3BsYXkuc3RhcnQoKVxuICAgICAgICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSB1cGRhdGUgdG8gYXBwbHkgYWxsIGNoYW5nZXNcbiAgICAgICAgICAgICAgICBzd2lwZXJJbnN0YW5jZS51cGRhdGUoKVxuICAgICAgICAgICAgICAgIHN3aXBlckluc3RhbmNlLnVwZGF0ZVNsaWRlcygpXG4gICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UudXBkYXRlU2xpZGVzQ2xhc3NlcygpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTW9uaXRvciBhbmQgcmVzdGFydCBhdXRvcGxheSBpZiBpdCBzdG9wc1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrQXV0b3BsYXkgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3dpcGVySW5zdGFuY2UgJiYgc3dpcGVySW5zdGFuY2UuYXV0b3BsYXkgJiYgIXN3aXBlckluc3RhbmNlLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVySW5zdGFuY2UuYXV0b3BsYXkuc3RhcnQoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNsaWRlc2hvdyBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIH0sIDEwMDApXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaW50ZXJ2YWwgcmVmZXJlbmNlIGZvciBjbGVhbnVwXG4gICAgICAgICAgICAgICAgY29uc3QgaGVyb1NsaWRlc2hvd0lkID0gaGVyb0VsLmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpIHx8ICdoZXJvLWRlZmF1bHQnXG4gICAgICAgICAgICAgICAgOyh3aW5kb3cgYXMgYW55KVtgYXV0b3BsYXlNb25pdG9yXyR7aGVyb1NsaWRlc2hvd0lkfWBdID0gY2hlY2tBdXRvcGxheVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBFbnN1cmUgaGVybyBzZWN0aW9uIGhhcyBwcm9wZXIgaGVpZ2h0XG4gICAgICAgICAgaGVyb0VsLnN0eWxlLnNldFByb3BlcnR5KCdtaW4taGVpZ2h0JywgJzUwMHB4JywgJ2ltcG9ydGFudCcpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNldHRpbmdzXScpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2V0dGluZ3MnKVxuICAgICAgICAgIGlmIChzZXR0aW5ncyAmJiAoc2V0dGluZ3MuaW5jbHVkZXMoJ2JhY2tncm91bmRfc2xpZGVzaG93X2dhbGxlcnknKSB8fCBzZXR0aW5ncy5pbmNsdWRlcygnYmFja2dyb3VuZF9pbWFnZScpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRGVjb2RlIEhUTUwgZW50aXRpZXMgcHJvcGVybHlcbiAgICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJykgIC8vIE11c3QgZGVjb2RlICZhbXA7IGZpcnN0XG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYjMzk7L2csIFwiJ1wiKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGhlcm8gc2VjdGlvbiBiYWNrZ3JvdW5kIGltYWdlcyAtIGVuc3VyZSB0aGV5IGRpc3BsYXkgcHJvcGVybHlcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBIYW5kbGUgY2xhc3NpYyBiYWNrZ3JvdW5kIGltYWdlc1xuICAgICAgICAgICAgICBpZiAocGFyc2VkLmJhY2tncm91bmRfYmFja2dyb3VuZCA9PT0gJ2NsYXNzaWMnICYmIHBhcnNlZC5iYWNrZ3JvdW5kX2ltYWdlICYmIHBhcnNlZC5iYWNrZ3JvdW5kX2ltYWdlLnVybCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJnVXJsID0gZml4QXNzZXRVcmwocGFyc2VkLmJhY2tncm91bmRfaW1hZ2UudXJsKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGJhY2tncm91bmQgaW1hZ2UgdG8gZGlzcGxheSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtiZ1VybH0nKWBcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2NvdmVyJ1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlcidcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gJzUwMHB4JyAvLyBFbnN1cmUgc2VjdGlvbiBoYXMgaGVpZ2h0XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUHJlbG9hZCBhbmQgdmVyaWZ5IGltYWdlIGxvYWRzXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdEltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgICAgICAgdGVzdEltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtiZ1VybH0nKWBcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXN0SW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQmFja2dyb3VuZCBpbWFnZSBmYWlsZWQgdG8gbG9hZDonLCBiZ1VybClcbiAgICAgICAgICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBpbWFnZSBwYXRoc1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWx0VXJsID0gYmdVcmwucmVwbGFjZSgvLVxcZCt4XFxkKy8sICcnKSAvLyBSZW1vdmUgc2l6ZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgIGlmIChhbHRVcmwgIT09IGJnVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHthbHRVcmx9JylgXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlc3RJbWcuc3JjID0gYmdVcmxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIHNsaWRlc2hvdyBiYWNrZ3JvdW5kIGltYWdlcyAtIEFMTE9XIE9SSUdJTkFMIFNMSURFU0hPVyBUTyBXT1JLXG4gICAgICAgICAgICAgIGlmIChwYXJzZWQuYmFja2dyb3VuZF9iYWNrZ3JvdW5kID09PSAnc2xpZGVzaG93JyAmJiBwYXJzZWQuYmFja2dyb3VuZF9zbGlkZXNob3dfZ2FsbGVyeSAmJiBBcnJheS5pc0FycmF5KHBhcnNlZC5iYWNrZ3JvdW5kX3NsaWRlc2hvd19nYWxsZXJ5KSAmJiBwYXJzZWQuYmFja2dyb3VuZF9zbGlkZXNob3dfZ2FsbGVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNsaWRlc2hvdyBlbGVtZW50IGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICBjb25zdCBzbGlkZXNob3dFbCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmVsZW1lbnRvci1iYWNrZ3JvdW5kLXNsaWRlc2hvdycpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlc2hvd0VsKSB7XG4gICAgICAgICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc2VjdGlvbiBoYXMgcHJvcGVyIGhlaWdodFxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gJzUwMHB4J1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgb3IgcmVpbml0aWFsaXplIFN3aXBlciB3aXRoIGxvb3AgYW5kIGF1dG9wbGF5XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVEdXJhdGlvbiA9IHBhcnNlZC5iYWNrZ3JvdW5kX3NsaWRlc2hvd19zbGlkZV9kdXJhdGlvbiB8fCA1NTAwXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRyYW5zaXRpb24gZHVyYXRpb24gdG8gMCBmb3Igbm8gdGltZSBnYXAgYmV0d2VlbiBzbGlkZXNcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSAwXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVuYWJsZSBsb29wIGZvciBpbWFnZXNcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRMb29wID0gdHJ1ZVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVzZSBzZXRUaW1lb3V0IHRvIGVuc3VyZSBTd2lwZXIgaXMgaW5pdGlhbGl6ZWQgYWZ0ZXIgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBTd2lwZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZCBvbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN3aXBlckVsZW1lbnQgPSBzbGlkZXNob3dFbCBhcyBhbnlcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gSWYgU3dpcGVyIGV4aXN0cywgdXBkYXRlIGl0cyBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlckVsZW1lbnQgJiYgc3dpcGVyRWxlbWVudC5zd2lwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3dpcGVyID0gc3dpcGVyRWxlbWVudC5zd2lwZXJcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEFMV0FZUyBlbmFibGUgbG9vcCBmb3IgaW1hZ2VzIChmb3JjZSBsb29wKSAtIGRlc3Ryb3kgYW5kIHJlY3JlYXRlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCB8fCBzd2lwZXIucGFyYW1zLmxvb3AgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJveSBleGlzdGluZyBsb29wIGlmIGFueVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2lwZXIubG9vcERlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGVuYWJsZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnBhcmFtcy5sb29wID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci5wYXJhbXMubG9vcGVkU2xpZGVzID0gdW5kZWZpbmVkIC8vIExldCBTd2lwZXIgY2FsY3VsYXRlIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICBzd2lwZXIucGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzID0gMlxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlci5sb29wQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZXIubG9vcENyZWF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0byBhcHBseSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gaWYgbG9vcCBpcyBhbHJlYWR5IGVuYWJsZWQsIGVuc3VyZSBpdCdzIHdvcmtpbmcgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICBzd2lwZXIucGFyYW1zLmxvb3AgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN3aXBlci5sb29wQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZXIubG9vcENyZWF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKVxuICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHNwZWVkL3RyYW5zaXRpb24gdG8gMCBmb3IgaW5zdGFudCB0cmFuc2l0aW9uIChubyBnYXApXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlci5wYXJhbXMuc3BlZWQgPSAwXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlci5wYXJhbXMuc2xpZGVUb0NsaWNrZWRTbGlkZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc2xpZGVzaG93IGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlc2hvd0VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgICBzbGlkZXNob3dFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgYXV0b3BsYXkgd2l0aCBzZWFtbGVzcyBsb29wIChubyBnYXAgYmV0d2VlbiBjeWNsZXMpIC0gZW5zdXJlIGl0IG5ldmVyIHN0b3BzXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci5wYXJhbXMuYXV0b3BsYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogc2xpZGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlT25Nb3VzZUVudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRGb3JUcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BPbkxhc3RTbGlkZTogZmFsc2UsIC8vIERvbid0IHN0b3Agb24gbGFzdCBzbGlkZSAtIGNyaXRpY2FsIGZvciBjb250aW51b3VzIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VEaXJlY3Rpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhdXRvcGxheSBzZXR0aW5ncyAtIGVuc3VyZSBpdCBuZXZlciBzdG9wc1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGVsYXkgPSBzbGlkZUR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5wYXVzZU9uTW91c2VFbnRlciA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGUgPSBmYWxzZSAvLyBEb24ndCBzdG9wIG9uIGxhc3Qgc2xpZGUgLSBjcml0aWNhbCBmb3IgY29udGludW91cyBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGF1dG9wbGF5IGlmIG5vdCBydW5uaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RhcnQoKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RhcnQgYXV0b3BsYXkgdG8gYXBwbHkgbmV3IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKVxuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0YXJ0KClcbiAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHVwZGF0ZSB0byBhcHBseSBhbGwgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICBzd2lwZXIudXBkYXRlKClcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vbml0b3IgYW5kIHJlc3RhcnQgYXV0b3BsYXkgaWYgaXQgc3RvcHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tBdXRvcGxheSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dpcGVyICYmIHN3aXBlci5hdXRvcGxheSAmJiAhc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5zdGFydCgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBzbGlkZXNob3cgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZXNob3dFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzaG93RWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc2hvd0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc2hvd0VsLnN0eWxlLm9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBpbnRlcnZhbCByZWZlcmVuY2UgZm9yIGNsZWFudXBcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVzaG93SWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpIHx8ICdkZWZhdWx0J1xuICAgICAgICAgICAgICAgICAgICA7KHdpbmRvdyBhcyBhbnkpW2BhdXRvcGxheU1vbml0b3JfJHtzbGlkZXNob3dJZH1gXSA9IGNoZWNrQXV0b3BsYXlcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBzbGlkZXNob3cgcm90YXRpb24gaWYgU3dpcGVyIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLWJhY2tncm91bmQtc2xpZGVzaG93X19zbGlkZTpub3QoLnN3aXBlci1zbGlkZS1kdXBsaWNhdGUpJykgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBvbmx5IGFjdHVhbCBzbGlkZXMgKG5vdCBkdXBsaWNhdGVzKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxTbGlkZXM6IEhUTUxFbGVtZW50W10gPSBbXVxuICAgICAgICAgICAgICAgICAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNsaWRlLmNsYXNzTGlzdC5jb250YWlucygnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxTbGlkZXMucHVzaChzbGlkZSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsU2xpZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFNsaWRlSW5kZXggPSAwXG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvd1NsaWRlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdHVhbEluZGV4ID0gaW5kZXggJSBhY3R1YWxTbGlkZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxTbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSBhY3R1YWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHRyYW5zaXRpb24gZm9yIGluc3RhbnQgY2hhbmdlICgwbXMgZ2FwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwbXMgZWFzZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlLnN0eWxlLnpJbmRleCA9ICcyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gdHJhbnNpdGlvbiBmb3IgaW5zdGFudCBjaGFuZ2UgKDBtcyBnYXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDBtcyBlYXNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS56SW5kZXggPSAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGZpcnN0IHNsaWRlXG4gICAgICAgICAgICAgICAgICAgICAgc2hvd1NsaWRlKDApXG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVuYWJsZSBsb29wIGZvciBpbWFnZXMgLSBGSVhFRDogVXNlIHByb3BlciB0cmFuc2l0aW9uIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uQWN0dWFsID0gcGFyc2VkLmJhY2tncm91bmRfc2xpZGVzaG93X3RyYW5zaXRpb25fZHVyYXRpb24gfHwgMTgwMFxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzaG93U2xpZGUgZnVuY3Rpb24gdG8gdXNlIHByb3BlciB0cmFuc2l0aW9uIGZvciBzbW9vdGggZmFkZVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3dTbGlkZVdpdGhUcmFuc2l0aW9uID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdHVhbEluZGV4ID0gaW5kZXggJSBhY3R1YWxTbGlkZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxTbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSBhY3R1YWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlLnN0eWxlLnRyYW5zaXRpb24gPSBgb3BhY2l0eSAke3RyYW5zaXRpb25EdXJhdGlvbkFjdHVhbH1tcyBlYXNlYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlLnN0eWxlLm9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUuekluZGV4ID0gJzInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS50cmFuc2l0aW9uID0gYG9wYWNpdHkgJHt0cmFuc2l0aW9uRHVyYXRpb25BY3R1YWx9bXMgZWFzZWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZS5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUuekluZGV4ID0gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGludGVydmFsIGZvciB0aGlzIHNsaWRlc2hvd1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWRlc2hvd0lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKSB8fCAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHdpbmRvdyBhcyBhbnkpW2BzbGlkZXNob3dJbnRlcnZhbF8ke3NsaWRlc2hvd0lkfWBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCh3aW5kb3cgYXMgYW55KVtgc2xpZGVzaG93SW50ZXJ2YWxfJHtzbGlkZXNob3dJZH1gXSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgbmV3IGludGVydmFsIHdpdGggcHJvcGVyIGxvb3AgLSBlbnN1cmUgY29udGludW91cyByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBoZXJvIHNsaWRlc2hvdyBsb29wOiAke2FjdHVhbFNsaWRlcy5sZW5ndGh9IHNsaWRlcywgJHtzbGlkZUR1cmF0aW9ufW1zIGRlbGF5LCAke3RyYW5zaXRpb25EdXJhdGlvbkFjdHVhbH1tcyB0cmFuc2l0aW9uYClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpW2BzbGlkZXNob3dJbnRlcnZhbF8ke3NsaWRlc2hvd0lkfWBdID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNsaWRlSW5kZXggPSAoY3VycmVudFNsaWRlSW5kZXggKyAxKSAlIGFjdHVhbFNsaWRlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTbGlkZVdpdGhUcmFuc2l0aW9uKGN1cnJlbnRTbGlkZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgIH0sIHNsaWRlRHVyYXRpb24pIC8vIFVzZSBzbGlkZUR1cmF0aW9uIC0gbG9vcCB3aWxsIGNvbnRpbnVlIGluZGVmaW5pdGVseVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBIZXJvIHNsaWRlc2hvdyBtYW51YWwgcm90YXRpb24gQUNUSVZFIC0gd2lsbCBsb29wIGNvbnRpbnVvdXNseWApXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSGVybyBzbGlkZXNob3c6IE5vdCBlbm91Z2ggc2xpZGVzIGZvdW5kIGZvciBsb29wJywgYWN0dWFsU2xpZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDE1MDApIC8vIEluY3JlYXNlZCB0aW1lb3V0IHRvIGVuc3VyZSBET00gaXMgcmVhZHkgYW5kIFN3aXBlciBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUHJlbG9hZCBhbGwgc2xpZGVzaG93IGltYWdlcyB0byBlbnN1cmUgdGhleSBsb2FkIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuYmFja2dyb3VuZF9zbGlkZXNob3dfZ2FsbGVyeS5mb3JFYWNoKChpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IGZpeEFzc2V0VXJsKGl0ZW0udXJsKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlbG9hZCBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgIHRlc3RJbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSW1hZ2UgbG9hZGVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzbGlkZXNob3cgc2xpZGUgaW1hZ2VzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLWJhY2tncm91bmQtc2xpZGVzaG93X19zbGlkZV9faW1hZ2UnKVxuICAgICAgICAgICAgICAgICAgICAgIHNsaWRlcy5mb3JFYWNoKChzbGlkZSwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVFbCA9IHNsaWRlIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGlkZVN0eWxlID0gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgc2xpZGUgY29udGFpbnMgdGhpcyBpbWFnZSBVUkwsIGVuc3VyZSBpdCdzIGZpeGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVTdHlsZS5pbmNsdWRlcyhpbWFnZVVybCkgfHwgc2xpZGVTdHlsZS5pbmNsdWRlcyhpdGVtLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IFVSTCBpbiBzbGlkZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlU3R5bGUuaW5jbHVkZXMoaXRlbS51cmwpICYmICFzbGlkZVN0eWxlLmluY2x1ZGVzKGltYWdlVXJsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtpbWFnZVVybH0nKWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0SW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU2xpZGVzaG93IGltYWdlIGZhaWxlZCB0byBsb2FkOicsIGltYWdlVXJsKVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXRoIHdpdGhvdXQgc2l6ZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsdFVybCA9IGltYWdlVXJsLnJlcGxhY2UoLy1cXGQreFxcZCsvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRVcmwgIT09IGltYWdlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RJbWcuc3JjID0gYWx0VXJsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRlc3RJbWcuc3JjID0gaW1hZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBkYXRhLXNldHRpbmdzIGZvciBiYWNrZ3JvdW5kOicsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gRml4IHNsaWRlc2hvdyBzbGlkZSBpbWFnZXMgZGlyZWN0bHkgKHRoZXkgaGF2ZSBpbmxpbmUgc3R5bGVzKVxuICAgICAgICAvLyBEb24ndCBoaWRlIGR1cGxpY2F0ZSBzbGlkZXMgLSB0aGV5IGFyZSBuZWVkZWQgZm9yIGxvb3AgdG8gd29ya1xuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLWJhY2tncm91bmQtc2xpZGVzaG93X19zbGlkZSwgLnN3aXBlci1zbGlkZScpLmZvckVhY2goKHNsaWRlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVFbCA9IHNsaWRlIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gT25seSBzaG93IGFjdGl2ZS92aXNpYmxlIHNsaWRlcyAtIGhpZGUgYWxsIG90aGVyc1xuICAgICAgICAgIC8vIEtlZXAgZHVwbGljYXRlIHNsaWRlcyB2aXNpYmxlICh3aXRoIG9wYWNpdHkgMCkgZm9yIGxvb3AgdG8gd29ya1xuICAgICAgICAgIGlmIChzbGlkZUVsLmNsYXNzTGlzdC5jb250YWlucygnc3dpcGVyLXNsaWRlLWFjdGl2ZScpIHx8IHNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzd2lwZXItc2xpZGUtdmlzaWJsZScpKSB7XG4gICAgICAgICAgICBzbGlkZUVsLnN0eWxlLm9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgc2xpZGVFbC5zdHlsZS56SW5kZXggPSAnMSdcbiAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICB9IGVsc2UgaWYgKHNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzd2lwZXItc2xpZGUtZHVwbGljYXRlJykpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgZHVwbGljYXRlIHNsaWRlcyBidXQgaGlkZGVuIC0gbmVlZGVkIGZvciBzZWFtbGVzcyBsb29wXG4gICAgICAgICAgICBzbGlkZUVsLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICAgICAgICBzbGlkZUVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snIC8vIEtlZXAgZGlzcGxheTogYmxvY2sgZm9yIGxvb3BcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGlkZSBpbmFjdGl2ZSBzbGlkZXNcbiAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgICAgICAgc2xpZGVFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaycgLy8gS2VlcCBkaXNwbGF5OiBibG9ja1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaXggaW1hZ2UgVVJMIGluIHNsaWRlXG4gICAgICAgICAgY29uc3Qgc2xpZGVJbWFnZSA9IHNsaWRlRWwucXVlcnlTZWxlY3RvcignLmVsZW1lbnRvci1iYWNrZ3JvdW5kLXNsaWRlc2hvd19fc2xpZGVfX2ltYWdlJykgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICBpZiAoc2xpZGVJbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgYmdJbWFnZSA9IHNsaWRlSW1hZ2Uuc3R5bGUuYmFja2dyb3VuZEltYWdlIHx8IHNsaWRlSW1hZ2UuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJnSW1hZ2UgJiYgYmdJbWFnZS5pbmNsdWRlcygnYWxsdXJlZGlnaXRhbC5uZXQnKSkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBVUkwgZnJvbSBzdHlsZVxuICAgICAgICAgICAgY29uc3QgdXJsTWF0Y2ggPSBiZ0ltYWdlLm1hdGNoKC91cmxcXChbJ1wiXT8oW14nXCIpXSspWydcIl0/XFwpLylcbiAgICAgICAgICAgIGlmICh1cmxNYXRjaCAmJiB1cmxNYXRjaFsxXSkge1xuICAgICAgICAgICAgICBjb25zdCBmaXhlZFVybCA9IGZpeEFzc2V0VXJsKHVybE1hdGNoWzFdKVxuICAgICAgICAgICAgICAgIHNsaWRlSW1hZ2Uuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtmaXhlZFVybH0nKWBcbiAgICAgICAgICAgICAgICBzbGlkZUltYWdlLnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2NvdmVyJ1xuICAgICAgICAgICAgICAgIHNsaWRlSW1hZ2Uuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlcidcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByZWxvYWQgaW1hZ2VcbiAgICAgICAgICAgICAgY29uc3QgdGVzdEltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgICAgIHRlc3RJbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzbGlkZUltYWdlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7Zml4ZWRVcmx9JylgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVzdEltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHdpdGhvdXQgc2l6ZSBzdWZmaXhcbiAgICAgICAgICAgICAgICBjb25zdCBhbHRVcmwgPSBmaXhlZFVybC5yZXBsYWNlKC8tXFxkK3hcXGQrLywgJycpXG4gICAgICAgICAgICAgICAgaWYgKGFsdFVybCAhPT0gZml4ZWRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJbWFnZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2FsdFVybH0nKWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVzdEltZy5zcmMgPSBmaXhlZFVybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBjaGVjayBmb3IgaGVybyBzZWN0aW9uIGJ5IGNsYXNzL2lkIGFuZCBmb3JjZSBiYWNrZ3JvdW5kIGltYWdlc1xuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZWxlbWVudG9yLXNlY3Rpb24sIHNlY3Rpb24nKS5mb3JFYWNoKChzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VjdGlvbkVsID0gc2VjdGlvbiBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWN0aW9uRWwpXG4gICAgICAgICAgY29uc3QgYmdJbWFnZSA9IGNvbXB1dGVkU3R5bGUuYmFja2dyb3VuZEltYWdlXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgc2VjdGlvbiBoYXMgYSBiYWNrZ3JvdW5kIGltYWdlIFVSTCB0aGF0IG5lZWRzIGZpeGluZ1xuICAgICAgICAgIGlmIChiZ0ltYWdlICYmIGJnSW1hZ2UgIT09ICdub25lJyAmJiBiZ0ltYWdlLmluY2x1ZGVzKCdhbGx1cmVkaWdpdGFsLm5ldCcpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmxNYXRjaCA9IGJnSW1hZ2UubWF0Y2goL3VybFxcKFsnXCJdPyhbXidcIildKylbJ1wiXT9cXCkvKVxuICAgICAgICAgICAgaWYgKHVybE1hdGNoICYmIHVybE1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpeGVkVXJsID0gZml4QXNzZXRVcmwodXJsTWF0Y2hbMV0pXG4gICAgICAgICAgICAgIHNlY3Rpb25FbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2ZpeGVkVXJsfScpYFxuICAgICAgICAgICAgICBzZWN0aW9uRWwuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInXG4gICAgICAgICAgICAgIHNlY3Rpb25FbC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAnY2VudGVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGxvYWQgc2NyaXB0cyBBRlRFUiBib2R5IGlzIHNldCAocHJlc2VydmUgb3JkZXIpXG4gICAgICBjb25zdCBhbGxTY3JpcHRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpXG4gICAgICBjb25zdCBzY3JpcHRQcm9taXNlczogUHJvbWlzZTx2b2lkPltdID0gW11cblxuICAgICAgYWxsU2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpID0+IHtcbiAgICAgICAgaWYgKHNjcmlwdC5zcmMpIHtcbiAgICAgICAgICBjb25zdCBzcmMgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKSB8fCAnJ1xuICAgICAgICAgIGNvbnN0IHNjcmlwdElkID0gc3JjXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2tpcCBleHRlcm5hbCBBUElzIC0gb25seSBsb2FkIGxvY2FsIGFzc2V0c1xuICAgICAgICAgIGlmIChzcmMuaW5jbHVkZXMoJ21hcHMuZ29vZ2xlYXBpcy5jb20nKSB8fCBcbiAgICAgICAgICAgICAgc3JjLmluY2x1ZGVzKCdnb29nbGVhcGlzLmNvbScpIHx8IFxuICAgICAgICAgICAgICBzcmMuaW5jbHVkZXMoJ2dzdGF0aWMuY29tJykgfHxcbiAgICAgICAgICAgICAgc3JjLmluY2x1ZGVzKCdnb29nbGV0YWdtYW5hZ2VyLmNvbScpIHx8XG4gICAgICAgICAgICAgIHNyYy5pbmNsdWRlcygnZ29vZ2xlLWFuYWx5dGljcy5jb20nKSB8fFxuICAgICAgICAgICAgICBzcmMuaW5jbHVkZXMoJ2ZhY2Vib29rLm5ldCcpIHx8XG4gICAgICAgICAgICAgIHNyYy5pbmNsdWRlcygnY2xhcml0eS5tcycpIHx8XG4gICAgICAgICAgICAgIHNyYy5pbmNsdWRlcygnY2xlYW50YWxrLm9yZycpIHx8XG4gICAgICAgICAgICAgIHNyYy5pbmNsdWRlcygncGVhcmxkaXZlci5pbycpIHx8XG4gICAgICAgICAgICAgIHNyYy5pbmNsdWRlcygndXNicm93c2Vyc3BlZWQuY29tJykgfHxcbiAgICAgICAgICAgICAgc3JjLmluY2x1ZGVzKCdyZWNhcHRjaGEnKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBleHRlcm5hbCBBUElzXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFzY3JpcHRzTG9hZGVkUmVmLmN1cnJlbnQuaGFzKHNjcmlwdElkKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gT25seSBsb2FkIGxvY2FsIGFzc2V0c1xuICAgICAgICAgICAgaWYgKHNyYy5pbmNsdWRlcygnYWxsdXJlZGlnaXRhbC5uZXQnKSB8fCBzcmMuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2V0QXNzZXRGaWxlbmFtZShzcmMpXG4gICAgICAgICAgICAgIGlmIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5zcmMgPSBgL2Fzc2V0cy8ke2ZpbGVuYW1lfWBcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGlmIGNhbid0IGZpbmQgbG9jYWwgYXNzZXRcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U2NyaXB0LnNyYyA9IHNyY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb3B5IEFMTCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBBcnJheS5mcm9tKHNjcmlwdC5hdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgIT09ICdzcmMnKSB7XG4gICAgICAgICAgICAgICAgbmV3U2NyaXB0LnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhc3luYy9kZWZlclxuICAgICAgICAgICAgaWYgKHNjcmlwdC5oYXNBdHRyaWJ1dGUoJ2FzeW5jJykpIG5ld1NjcmlwdC5hc3luYyA9IHRydWVcbiAgICAgICAgICAgIGlmIChzY3JpcHQuaGFzQXR0cmlidXRlKCdkZWZlcicpKSBuZXdTY3JpcHQuZGVmZXIgPSB0cnVlXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGxvYWRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKVxuICAgICAgICAgICAgICBuZXdTY3JpcHQub25lcnJvciA9ICgpID0+IHJlc29sdmUoKSAvLyBDb250aW51ZSBldmVuIGlmIHNjcmlwdCBmYWlsc1xuICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG5ld1NjcmlwdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNjcmlwdFByb21pc2VzLnB1c2gobG9hZFByb21pc2UpXG4gICAgICAgICAgICBzY3JpcHRzTG9hZGVkUmVmLmN1cnJlbnQuYWRkKHNjcmlwdElkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzY3JpcHQudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAvLyBTa2lwIGlubGluZSBzY3JpcHRzIHRoYXQgcmVmZXJlbmNlIGV4dGVybmFsIEFQSXNcbiAgICAgICAgICBjb25zdCBzY3JpcHRUZXh0ID0gc2NyaXB0LnRleHRDb250ZW50XG4gICAgICAgICAgaWYgKHNjcmlwdFRleHQuaW5jbHVkZXMoJ2d0YWcnKSB8fCBcbiAgICAgICAgICAgICAgc2NyaXB0VGV4dC5pbmNsdWRlcygnZmJxJykgfHwgXG4gICAgICAgICAgICAgIHNjcmlwdFRleHQuaW5jbHVkZXMoJ2NsYXJpdHknKSB8fFxuICAgICAgICAgICAgICBzY3JpcHRUZXh0LmluY2x1ZGVzKCdkYXRhTGF5ZXInKSB8fFxuICAgICAgICAgICAgICBzY3JpcHRUZXh0LmluY2x1ZGVzKCdnb29nbGUnKSB8fFxuICAgICAgICAgICAgICBzY3JpcHRUZXh0LmluY2x1ZGVzKCdtYXBzJykgfHxcbiAgICAgICAgICAgICAgc2NyaXB0VGV4dC5pbmNsdWRlcygncmVjYXB0Y2hhJykpIHtcbiAgICAgICAgICAgIC8vIFNraXAgYW5hbHl0aWNzL3RyYWNraW5nIHNjcmlwdHNcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJbmxpbmUgc2NyaXB0cyAtIGV4ZWN1dGUgYWZ0ZXIgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgY29uc3Qgc2NyaXB0SWQgPSBzY3JpcHRUZXh0LnN1YnN0cmluZygwLCA1MClcbiAgICAgICAgICBpZiAoIXNjcmlwdHNMb2FkZWRSZWYuY3VycmVudC5oYXMoc2NyaXB0SWQpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgICAgICAgICAgbmV3U2NyaXB0LnRleHRDb250ZW50ID0gc2NyaXB0VGV4dFxuICAgICAgICAgICAgLy8gQ29weSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBBcnJheS5mcm9tKHNjcmlwdC5hdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICAgIG5ld1NjcmlwdC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobmV3U2NyaXB0KVxuICAgICAgICAgICAgc2NyaXB0c0xvYWRlZFJlZi5jdXJyZW50LmFkZChzY3JpcHRJZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIFdhaXQgZm9yIENTUyB0byBsb2FkIGZpcnN0IChjcml0aWNhbCksIHRoZW4gc2NyaXB0cywgdGhlbiBzaG93IGNvbnRlbnRcbiAgICAgIC8vIENTUyBtdXN0IGJlIGZ1bGx5IGxvYWRlZCBiZWZvcmUgc2hvd2luZyBjb250ZW50IHRvIHByZXZlbnQgYnJva2VuIGxheW91dFxuICAgICAgaWYgKHN0eWxlUHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBXYWl0IGZvciBBTEwgQ1NTIHRvIGxvYWQgZmlyc3RcbiAgICAgICAgUHJvbWlzZS5hbGwoc3R5bGVQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgLy8gRm9yY2UgYSByZWZsb3cgdG8gZW5zdXJlIENTUyBpcyBhcHBsaWVkXG4gICAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5vZmZzZXRIZWlnaHQgLy8gVHJpZ2dlciByZWZsb3dcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgQ1NTIHRvIGJlIGZ1bGx5IGFwcGxpZWQgdG8gRE9NXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE5vdyBsb2FkIHNjcmlwdHMgaW4gYmFja2dyb3VuZCAobm9uLWJsb2NraW5nKVxuICAgICAgICAgICAgICBpZiAoc2NyaXB0UHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHNjcmlwdFByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgRE9NQ29udGVudExvYWRlZCBmb3Igc2NyaXB0cyB0aGF0IGRlcGVuZCBvbiBpdFxuICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnRE9NQ29udGVudExvYWRlZCcpKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGpRdWVyeSByZWFkeSBpZiBqUXVlcnkgaXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyBhcyBhbnkpLmpRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAod2luZG93IGFzIGFueSkualF1ZXJ5KGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRWxlbWVudG9yIGFuZCBvdGhlciBzY3JpcHRzIHdpbGwgaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgQkRUIE9mZmNhbnZhcyBtZW51IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgIGlmICgod2luZG93IGFzIGFueSkuVUlraXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVJa2l0IGlzIGxvYWRlZCwgb2ZmY2FudmFzIHNob3VsZCB3b3JrIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBlbnN1cmUgaXQncyBwcm9wZXJseSBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZmNhbnZhc0J1dHRvbnMgPSBjb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1iZHQtdG9nZ2xlPVwidGFyZ2V0XCJdJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZjYW52YXNCdXR0b25zLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNsaWNrIGhhbmRsZXIgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmR0LXRvZ2dsZScpPy5yZXBsYWNlKCd0YXJnZXQ6ICcsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgKHdpbmRvdyBhcyBhbnkpLlVJa2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZjYW52YXMgPSAod2luZG93IGFzIGFueSkuVUlraXQub2ZmY2FudmFzKHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZjYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmY2FudmFzLnNob3coKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwMClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEFsc28gaW5pdGlhbGl6ZSBvZmZjYW52YXMgYWZ0ZXIgYSBkZWxheSB0byBlbnN1cmUgc2NyaXB0cyBhcmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSBvZmZjYW52YXMgbWVudSBieSBkZWZhdWx0IC0gb25seSBzaG93IHdoZW4gYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZjYW52YXNNZW51cyA9IGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5iZHQtb2ZmY2FudmFzJylcbiAgICAgICAgICAgICAgICAgICAgICBvZmZjYW52YXNNZW51cy5mb3JFYWNoKChtZW51KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51RWwgPSBtZW51IGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIG1lbnUgYnkgZGVmYXVsdCB0byBwcmV2ZW50IHdoaXRlIHNjcmVlblxuICAgICAgICAgICAgICAgICAgICAgICAgbWVudUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVFbC5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51RWwuY2xhc3NMaXN0LnJlbW92ZSgnYmR0LW9wZW4nKVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRml4IG9mZmNhbnZhcyBidXR0b24gY2xpY2sgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZjYW52YXNCdXR0b25zID0gY29udGFpbmVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvckFsbCgnLmJkdC1vZmZjYW52YXMtYnV0dG9uLCBbZGF0YS1iZHQtdG9nZ2xlKj1cIm9mZmNhbnZhc1wiXScpXG4gICAgICAgICAgICAgICAgICAgICAgb2ZmY2FudmFzQnV0dG9ucy5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWJkdC10b2dnbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0QXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0QXR0ci5yZXBsYWNlKCd0YXJnZXQ6ICcsICcnKS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSBvZmZjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgod2luZG93IGFzIGFueSkuVUlraXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2ZmY2FudmFzID0gKHdpbmRvdyBhcyBhbnkpLlVJa2l0Lm9mZmNhbnZhcyh0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZjYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZjYW52YXMudG9nZ2xlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IHRvZ2dsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc09wZW4gPSB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdiZHQtb3BlbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBtZW51XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2JkdC1vcGVuJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnYmR0LW9mZmNhbnZhcy1wYWdlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIG1lbnVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnYmR0LW9wZW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2JkdC1vZmZjYW52YXMtcGFnZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggb2ZmY2FudmFzIGNsb3NlIGJ1dHRvbiBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQnV0dG9ucyA9IGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5iZHQtb2ZmY2FudmFzLWNsb3NlLCBbZGF0YS1iZHQtY2xvc2VdJylcbiAgICAgICAgICAgICAgICAgICAgICBjbG9zZUJ1dHRvbnMuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZmNhbnZhcyA9IHRoaXMuY2xvc2VzdCgnLmJkdC1vZmZjYW52YXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZmY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUVsID0gb2ZmY2FudmFzIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVudUVsLmNsYXNzTGlzdC5yZW1vdmUoJ2JkdC1vcGVuJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51RWwuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnYmR0LW9mZmNhbnZhcy1wYWdlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIFNjcmlwdHMgZmFpbGVkIGJ1dCBjb250aW51ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFNob3cgY29udGVudCBhZnRlciBDU1MgaXMgbG9hZGVkIGFuZCBhcHBsaWVkXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgICAgICAgICAgfSwgMTUwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gRXZlbiBpZiBDU1MgZmFpbHMsIHdhaXQgYSBiaXQgdGhlbiBzaG93IGNvbnRlbnRcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgICAgICB9LCAzMDApXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHNjcmlwdFByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gTm8gQ1NTIGJ1dCBoYXMgc2NyaXB0c1xuICAgICAgICBQcm9taXNlLmFsbChzY3JpcHRQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICAgICAgfSwgMTAwKVxuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICAgICAgfSwgMjAwKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gYXNzZXRzIHRvIGxvYWQsIHdhaXQgYSBiaXQgZm9yIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgICAgfSwgMjAwKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciB1c2VFZmZlY3RcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNsZWFudXBSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQoKVxuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LCBbaHRtbF0pXG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2lzTG9hZGluZyAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIGJhY2tncm91bmQ6ICdsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpJyxcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgIHpJbmRleDogOTk5OSxcbiAgICAgICAgICBmb250RmFtaWx5OiAnc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJ1xuICAgICAgICB9fT5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgICB3aWR0aDogJzgwcHgnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnODBweCcsXG4gICAgICAgICAgICBib3JkZXI6ICc1cHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJyxcbiAgICAgICAgICAgIGJvcmRlclRvcDogJzVweCBzb2xpZCAjZmZmZmZmJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICAgICAgICBhbmltYXRpb246ICdzcGluIDFzIGxpbmVhciBpbmZpbml0ZScsXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206ICczMHB4JyxcbiAgICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDIwcHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgIH19IC8+XG4gICAgICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMjRweCcsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcxMHB4JyxcbiAgICAgICAgICAgIHRleHRTaGFkb3c6ICcwIDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4yKSdcbiAgICAgICAgICB9fT5cbiAgICAgICAgICAgIFJpbWFsd2ViXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMFxuICAgICAgICAgIH19PlxuICAgICAgICAgICAgTG9hZGluZy4uLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxzdHlsZT57YFxuICAgICAgICAgICAgQGtleWZyYW1lcyBzcGluIHtcbiAgICAgICAgICAgICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICAgICAgICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGB9PC9zdHlsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgPGRpdiBcbiAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9IFxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIG9wYWNpdHk6IGlzTG9hZGluZyA/IDAgOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuM3MgZWFzZS1pbi1vdXQnXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIDwvPlxuICApXG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImdldEFzc2V0RmlsZW5hbWUiLCJ1cmwiLCJ1cmxUb1Byb2Nlc3MiLCJpbmNsdWRlcyIsInJlcGxhY2UiLCJ1cmxPYmoiLCJVUkwiLCJwYXRoUGFydHMiLCJwYXRobmFtZSIsInNwbGl0IiwiZmlsdGVyIiwicCIsImxlbmd0aCIsImRvbWFpbiIsImhvc3RuYW1lIiwiZnVsbFBhdGgiLCJmaWxlbmFtZSIsIlBhZ2VSZW5kZXJlciIsImh0bWwiLCJjb250YWluZXJSZWYiLCJzY3JpcHRzTG9hZGVkUmVmIiwiU2V0Iiwic3R5bGVzTG9hZGVkUmVmIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiY2xlYW51cFJlZiIsInNjcm9sbFRpbWVvdXRSZWYiLCJjdXJyZW50IiwicGFyc2VyIiwiRE9NUGFyc2VyIiwiZG9jIiwicGFyc2VGcm9tU3RyaW5nIiwiaGVhZCIsInF1ZXJ5U2VsZWN0b3IiLCJzdHlsZVByb21pc2VzIiwiZ29vZ2xlRm9udHNMaW5rIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVsIiwiaHJlZiIsImFwcGVuZENoaWxkIiwiZ29vZ2xlRm9udHNMaW5rMiIsImNyb3NzT3JpZ2luIiwiZm9udExpbmsiLCJhbGxBc3NldHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwiZ2V0QXR0cmlidXRlIiwicHVzaCIsImFzIiwic3JjIiwic3RhcnRzV2l0aCIsImJvZHkiLCJpbWFnZUNvdW50IiwiZml4ZWRTcmMiLCJzb21lIiwiYSIsImFzc2V0IiwicHJlbG9hZExpbmsiLCJ0YWdOYW1lIiwic3R5bGVJZCIsImhhcyIsImNsb25lIiwiY2xvbmVOb2RlIiwic2V0QXR0cmlidXRlIiwic3R5bGVQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXNvbHZlZCIsInJlc29sdmVPbmNlIiwic2V0VGltZW91dCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJhZGQiLCJ0ZXh0Q29udGVudCIsInN1YnN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInRpdGxlVGV4dCIsInJlcGxhY2VkVGV4dCIsInRpdGxlIiwiZXhpc3RpbmdUaXRsZSIsIm5ld1RpdGxlIiwidGl0bGVFbCIsImV4aXN0aW5nIiwiY29udGVudCIsInJlcGxhY2VkQ29udGVudCIsImJvZHlDbGFzc2VzIiwiY2xhc3NOYW1lIiwiQXJyYXkiLCJmcm9tIiwiYXR0cmlidXRlcyIsImF0dHIiLCJuYW1lIiwidmFsdWUiLCJjaGVja0Fzc2V0RXhpc3RzIiwicGF0aCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJvayIsImZpeEFzc2V0VXJsIiwidGVzdCIsImZpbGVuYW1lV2l0aG91dFNpemUiLCJpbWciLCJ3ZWxjb21lU2VjdGlvbiIsImNsb3Nlc3QiLCJpc1dlbGNvbWVTZWN0aW9uIiwiaW1nRWxlbWVudCIsIm9yaWdpbmFsV2lkdGgiLCJwYXJzZUludCIsIm9mZnNldFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJ3aWR0aCIsInJvdW5kIiwiaGVpZ2h0IiwiY3VycmVudFN0eWxlIiwiaXNJbkxvZ29DYXJvdXNlbCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwic3R5bGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm9iamVjdEZpdCIsInNyY0xvd2VyIiwidG9Mb3dlckNhc2UiLCJpc0xvZ29JbWFnZSIsImlzSW5IZWFkZXIiLCJpc0luRm9vdGVyIiwiaGFzTG9nb0NsYXNzIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsInNpemVNdWx0aXBsaWVyIiwiY2xhc3NlcyIsImFsdCIsIm5ld0xvZ28iLCJvcGFjaXR5U3R5bGUiLCJoZWFkZXJQb3NpdGlvblN0eWxlIiwibGluayIsInJlcGxhY2VDaGlsZCIsIm5ld1N0eWxlIiwibWF0Y2giLCJmaXhlZCIsInJlbW92ZUF0dHJpYnV0ZSIsImxpbmtFbCIsInBvaW50ZXJFdmVudHMiLCJjdXJzb3IiLCJ0ZXh0RGVjb3JhdGlvbiIsImR1bW15UGhvbmUiLCJkdW1teUVtYWlsIiwiZW5kc1dpdGgiLCJzbGljZSIsInJvdXRlTWFwIiwiZSIsInBhdGhNYXRjaCIsInJlcGxhY2VCcmFuZGluZyIsInRlbXBEaXYiLCJpbm5lckhUTUwiLCJ3YWxrZXIiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiTm9kZUZpbHRlciIsIlNIT1dfVEVYVCIsIm5vZGUiLCJuZXh0Tm9kZSIsImhhc0F0dHJpYnV0ZSIsInRleHQiLCJvcmlnaW5hbFRleHQiLCJoZWFkaW5nIiwibmV3VGV4dCIsImNoaWxkcmVuIiwiZGlyZWN0VGV4dE5vZGVzIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwiTm9kZSIsIlRFWFRfTk9ERSIsInRleHROb2RlIiwicmVwbGFjZWQiLCJzY3JpcHQiLCJqc29uRGF0YSIsIkpTT04iLCJwYXJzZSIsImpzb25TdHJpbmciLCJzdHJpbmdpZnkiLCJyZXBsYWNlSW5PYmplY3QiLCJvYmoiLCJpc0FycmF5IiwibWFwIiwia2V5IiwicmVwbGFjZUNvbnRhY3RJbmZvIiwiZHVtbXlBZGRyZXNzIiwidHJpbSIsIm5vZGVUZXh0Iiwib3JpZ2luYWxOb2RlVGV4dCIsImh0bWxFbCIsImJvZHlIdG1sIiwianNvblN0ciIsImRlY29kZWQiLCJwYXJzZWQiLCJwYXJzZUVycm9yIiwidXJsTWF0Y2giLCJzdWJkb21haW4iLCJ1cmxUb0ZpeCIsImZpeGVkVXJsIiwiZml4VXJsc0luT2JqZWN0IiwiYmFja2dyb3VuZF9iYWNrZ3JvdW5kIiwiYmFja2dyb3VuZF9pbWFnZSIsImZpeGVkT2JqIiwiZml4ZWRKc29uIiwicmVFbmNvZGVkIiwiY29uc29sZSIsIndhcm4iLCJzcmNzZXQiLCJmaXhlZFNyY3NldCIsInBhcnRzIiwiam9pbiIsInByZWZpeCIsImJlZm9yZSIsImFmdGVyIiwiY2xlYW5lZEh0bWwiLCJtb2RpZnlIb21lcGFnZUhlYWRpbmdzIiwiaGVhZGluZ1JlcGxhY2VtZW50cyIsIm9yaWdpbmFsIiwicmVwbGFjZW1lbnQiLCJPYmplY3QiLCJlbnRyaWVzIiwidHJpbW1lZE9yaWdpbmFsIiwic2V0dGluZ3MiLCJyb3RhdGluZ190ZXh0Iiwicm90YXRpbmdUZXh0IiwiaXNIb21lcGFnZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaW1nRWwiLCJob3ZlckJveGVzIiwiaG92ZXJCb3giLCJob3ZlckJveEVsIiwiaG92ZXJJdGVtcyIsImhvdmVyQ29udGVudHMiLCJpbmRleCIsImNvbnRlbnRFbCIsIm9wYWNpdHkiLCJ2aXNpYmlsaXR5IiwiZGlzcGxheSIsInpJbmRleCIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsInJlbW92ZSIsInNob3dIb3ZlckNvbnRlbnQiLCJkYXRhSWQiLCJ0YXJnZXRDb250ZW50Iiwic3R5bGVBdHRyIiwiYmdNYXRjaCIsImltZ1VybCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiYmdJbWFnZSIsImJhY2tncm91bmRJbWFnZSIsInRlc3RJbWciLCJJbWFnZSIsImFsdFVybCIsImFsdFRlc3RJbWciLCJpdGVtIiwiaXRlbUVsIiwiaGFuZGxlSG92ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwidGl0bGVMaW5rcyIsInN0b3BQcm9wYWdhdGlvbiIsIml0ZW1XcmFwIiwicHJlbG9hZEltZyIsImxlZnQiLCJyaWdodCIsInBvc2l0aW9uIiwidG9wIiwiaGVhZGVyIiwiaGVhZGVyRWwiLCJjb250YWluZXIiLCJjb250YWluZXJFbCIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJmaXhIZWFkZXJXaWR0aCIsInNjcm9sbEhhbmRsZXIiLCJjbGVhclRpbWVvdXQiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhlcm9TZWN0aW9ucyIsImhlcm9TZWN0aW9uIiwicGhvbmVFbWFpbEVsZW1lbnRzIiwibWFyZ2luIiwicGFkZGluZyIsImljb25MaXN0cyIsImljb25MaXN0IiwibGlzdEVsIiwiaXRlbXMiLCJhbGxIaWRkZW4iLCJfYW5pbWF0aW9uIiwiYW5pbWF0aW9uVHlwZSIsImFuaW1hdGlvbkRlbGF5IiwiX2FuaW1hdGlvbl9kZWxheSIsImFuaW1hdGlvbiIsImFuaW1hdGVkSGVhZGxpbmVzIiwiaGVhZGxpbmUiLCJoZWFkbGluZUVsIiwid2lkZ2V0RWwiLCJtYXJnaW5Ub3AiLCJ3aWRnZXRDb250YWluZXIiLCJ0ZXh0U3BhbnMiLCJ0ZXh0V3JhcHBlciIsIm1pbldpZHRoIiwib3ZlcmZsb3ciLCJ3aGl0ZVNwYWNlIiwiZHluYW1pY1dyYXBwZXIiLCJsb29wIiwiaXRlcmF0aW9uRGVsYXkiLCJyb3RhdGVfaXRlcmF0aW9uX2RlbGF5IiwiYW5pbWF0aW9uX3R5cGUiLCJoZWFkbGluZUlkIiwiY2xlYXJJbnRlcnZhbCIsImN1cnJlbnRJbmRleCIsInNwYW4iLCJpZHgiLCJ0ZXh0T3ZlcmZsb3ciLCJpc0FjdGl2ZSIsIm9yaWdpbmFsVmlzaWJpbGl0eSIsIm9yaWdpbmFsRGlzcGxheSIsIm9yaWdpbmFsUG9zaXRpb24iLCJ0ZXh0V2lkdGgiLCJzY3JvbGxXaWR0aCIsInJvdGF0ZVRleHQiLCJuZXh0U3BhbiIsInNldEludGVydmFsIiwiZm9vdGVyIiwiYmdVcmwiLCJwYXJlbnRDb250ZW50IiwiY3JlYXRlUGxhY2Vob2xkZXJTdmciLCJ3IiwiaCIsInBsYWNlaG9sZGVyU3ZnIiwiYmFja2dyb3VuZENvbG9yIiwiZWxlbWVudCIsImZpeGVkQmdVcmwiLCJpc0hvdmVyQm94SW1hZ2UiLCJ1cGRhdGVkU3R5bGUiLCJmYWxsYmFja1N0eWxlIiwiaG9tZXBhZ2VIZXJvU2VjdGlvbiIsImhlcm9FbCIsInNsaWRlc2hvdyIsInNsaWRlc2hvd0VsIiwic3dpcGVySW5zdGFuY2UiLCJzd2lwZXIiLCJwYXJhbXMiLCJsb29wRGVzdHJveSIsImxvb3BlZFNsaWRlcyIsInVuZGVmaW5lZCIsImxvb3BBZGRpdGlvbmFsU2xpZGVzIiwibG9vcENyZWF0ZSIsInVwZGF0ZSIsInVwZGF0ZVNsaWRlcyIsInVwZGF0ZVNsaWRlc0NsYXNzZXMiLCJzcGVlZCIsImF1dG9wbGF5IiwiZGlzYWJsZU9uSW50ZXJhY3Rpb24iLCJwYXVzZU9uTW91c2VFbnRlciIsIndhaXRGb3JUcmFuc2l0aW9uIiwiZGVsYXkiLCJzdG9wT25MYXN0U2xpZGUiLCJyZXZlcnNlRGlyZWN0aW9uIiwicnVubmluZyIsInN0YXJ0Iiwic3RvcCIsImNoZWNrQXV0b3BsYXkiLCJoZXJvU2xpZGVzaG93SWQiLCJzZXRQcm9wZXJ0eSIsIm1pbkhlaWdodCIsImJhY2tncm91bmRfc2xpZGVzaG93X2dhbGxlcnkiLCJzbGlkZUR1cmF0aW9uIiwiYmFja2dyb3VuZF9zbGlkZXNob3dfc2xpZGVfZHVyYXRpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJzaG91bGRMb29wIiwic3dpcGVyRWxlbWVudCIsInNsaWRlVG9DbGlja2VkU2xpZGUiLCJzbGlkZXNob3dJZCIsInNsaWRlcyIsImFjdHVhbFNsaWRlcyIsInNsaWRlIiwiY3VycmVudFNsaWRlSW5kZXgiLCJzaG93U2xpZGUiLCJhY3R1YWxJbmRleCIsInRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb25BY3R1YWwiLCJiYWNrZ3JvdW5kX3NsaWRlc2hvd190cmFuc2l0aW9uX2R1cmF0aW9uIiwic2hvd1NsaWRlV2l0aFRyYW5zaXRpb24iLCJsb2ciLCJpbWFnZVVybCIsInNsaWRlSW5kZXgiLCJzbGlkZUVsIiwic2xpZGVTdHlsZSIsInNsaWRlSW1hZ2UiLCJzZWN0aW9uIiwic2VjdGlvbkVsIiwiYWxsU2NyaXB0cyIsInNjcmlwdFByb21pc2VzIiwic2NyaXB0SWQiLCJuZXdTY3JpcHQiLCJhc3luYyIsImRlZmVyIiwibG9hZFByb21pc2UiLCJzY3JpcHRUZXh0IiwiYWxsIiwidGhlbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlYWR5U3RhdGUiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJqUXVlcnkiLCJyZWFkeSIsIlVJa2l0Iiwib2ZmY2FudmFzQnV0dG9ucyIsImJ0biIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0SWQiLCJ0YXJnZXQiLCJvZmZjYW52YXMiLCJzaG93Iiwib2ZmY2FudmFzTWVudXMiLCJtZW51IiwibWVudUVsIiwidGFyZ2V0QXR0ciIsInRvZ2dsZSIsImlzT3BlbiIsImNsb3NlQnV0dG9ucyIsImNhdGNoIiwiZGl2IiwiYmFja2dyb3VuZCIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJmb250RmFtaWx5IiwiYm9yZGVyIiwiYm9yZGVyVG9wIiwiYm9yZGVyUmFkaXVzIiwibWFyZ2luQm90dG9tIiwiYm94U2hhZG93IiwiY29sb3IiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJ0ZXh0U2hhZG93IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/PageRenderer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz84MDgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MzBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cusman%5C%5Csrc%5C%5Ccomponents%5C%5CPageRenderer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);